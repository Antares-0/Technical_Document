# Go特性

## 一、defer关键字
1. defer关键字的主要作用就是“延迟执行”，主要用于资源回收、链接关闭、异常处理、日志记录等常用场景
2. 使用方法：`defer func()`
3. 原理：defer关键字描述的函数会在return语句执行前被执行，每个defer语句按照自然逻辑会被压入栈中，执行时从栈中依次取出函数进行调用
   - 执行顺序：按照代码顺序反向，发生panic的时候同理，跳出当前代码块之前，defer会被执行
     ```go
     func main() {
         i := test()
         fmt.Println(i)
         // 3 2 1 0
     }
     func test() int {
         defer fmt.Println("1")
         defer fmt.Println("2")
         fmt.Println("3")
         return 0
     }
     ```
   - defer中影响return
     - 第一种情况，命名返回值，会影响return最终的值
     - 第二种情况，无命名返回值，不会影响
     ```go
     func main() {
         fmt.Println("getAns")
         fmt.Println(getAns(1))
         fmt.Println("getAnsReturn")
         fmt.Println(getAnsReturn(1))
     }

     func getAns(a int) int {
         fmt.Println("getAns Inner", a)
         defer func(num int) {
             a = a * 2
             fmt.Println("getAns defer Inner", a)
         }(a)
         return a
     }

     func getAnsReturn(a int) (b int) {
         fmt.Println("getAnsReturn Inner", a)
         defer func(p int) {
             b = p * 2
             fmt.Println("getAnsReturn defer Inner", b)
         }(a)
         return
     }
     // getAns
     // getAns Inner 1
     // getAns defer Inner 2
     // 1
     // getAnsReturn
     // getAnsReturn Inner 1
     // getAnsReturn defer Inner 2
     // 2
     ```
   - defer函数的参数值确定是在<font color='yellow'>传入的时候就计算完毕</font>，而不是在执行时，相当于是把函数所需要的变量都压入栈中，所有的值都是在顺序执行时就确定好的
     ```go
     func main() {
         fmt.Println(test())
     }
     
     func test() int {
         i := 0
         defer func(a int) {
             fmt.Println("deferIn")
             fmt.Println(a)
             fmt.Println("deferOut")
         } (i) // 表示defer函数的入参
         i++
		 return i
     }
     // deferIn
     // 0
     // deferOut
     // 1
     ```
4. defer实战：一个用于记录函数执行时间的小方法
   ```go
   func main() {
       process()
   }

   func process() {
       // 注意最后这个小括号非常重要
       // 代码解析：运行到这里的时候，编译器需要先执行 getFuncExecuteTime("myFunctionName") 方法获取对应的函数，也就是会开启now:=time.Now()
       // 代码解析：获取到最后一个函数的时候，将函数的所有参数压入defer堆栈
       defer getFuncExecuteTime("myFunctionName")()
       time.Sleep(3 * time.Second)
   }

   // 表示接受string输出func
   func getFuncExecuteTime(myFunctionName string) func() {
       now := time.Now()
       fmt.Println("Now: ", now)
       return func() {
           fmt.Println(myFunctionName, "execute time is", time.Since(now))
       }
   }
   ```


## 二、类型推断(常量推断为例)
1. 定义：类型推断是编程语言在变异时自动解释表达式中数据类型的能力；使用得当的话会提高代码的易读性。
2. 使用：使用`:=`触发go的类型推断，或者省略类型信息来实现
   ```go
   var a int = 10
   var a = 10
   a := 10
   ```
3. 编译原理：词法解析 -- 语法分析 -- 抽象语法树构建 -- 类型检查 -- 中间代码 -- 代码优化 -- 生成机器码
   - 词法解析与语法分析阶段
     - 赋值语句右边的常量解析为一个未定义的类型
     - 逐个读取该常量的UTF8编码格式的字符串，字符串的首字符是`"`，数字的首字符是`0-9`，小数包含`.`
     - 简单来说，类型推断的第一步就是判断赋值语句右边的常量是个什么类型
   - 抽象语法树生成与类型检查
     - AST(Abstract Syntax Tree)阶段，通过`math/big.Int`或者`math/big.Float`进行高精度存储
     - 类型检查阶段，高精度存储的部分没有改变，但是通过标志标识了该变量是`int`类型
     - SSA(Static Single Assignment)阶段，将`int`类型转换为`int64`











参考资料：
1. defer简介：https://blog.csdn.net/weixin_45925028/article/details/134307405
2. 类型推断：《Go语言底层原理剖析》第三章
3. 