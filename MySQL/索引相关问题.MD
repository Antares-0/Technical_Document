# 索引相关问题


## 一、使用自增主键作为索引的优点和缺点
1. 优点
   - 有序性：B+树的叶子节点存储着数据，叶子节点之间通过指针形成了链表。主键自增意味着新插入的数据总是添加到索引的末端，不会中间插入或导致页面分裂。提高了范围查询的效率，也降低了插入和删除对索引的维护成本。
   - 插入性能：减少了插入导致的页面分裂，由于新插入的数据总是添加到有序链表的末尾，减少了数据移动和页面分裂的可能性，提高了插入性能；自增锁机制有助于减少插入操作时的并发操作。
   - 减少了索引维护的成本：自增类型的主键有利于减少索引的维护成本，由于主键的值是递增的，不会引起频繁的B+树的重排或者调整，索引维护的开销相对比较小。
   - 简化数据分布：自增类型的主键有助于简化数据的分布。在分布式系统中，如果主键是自增的，各个节点插入数据时不容易发生主键冲突，减少了一致性维护的复杂性。
   - 提高缓存命中率：自增主键的有序性有助于提高缓存的命中率。数据库引擎可以更好地利用缓存，因为相邻的数据有更高的可能被同时访问。
2. 缺点
   - 分布式问题：分布式系统中，每个节点的自增主键可能会导致冲突，需要额外的逻辑来协调全局一致性（例如UUID）
   - 数据迁移和数据合并困难：数据库合并或者迁移时，自增主键可能导致冲突，需要重新调整序列或者处理重复问题。
   - 热点问题：在高并发写入场景下，不断增长的主键可能会成为写入的热点，所有写操作都几种在一个位置，影响写入性能。
   - 信息泄露：由于主键自增，某些攻击者可以轻易猜到下一条数据可能的相关信息，安全性有一定的问题。
   - 删除和重用问题：删除记录后，自增主键不会重用已删除的ID，长期运行可能导致ID空间的浪费。
   - 特定业务场景：自增类型的主键并不是最优选择，例如某些业务场景希望主键是跨表唯一的，自增主键不能满足需求。
3. 总结：
   - 优点：因为有序，所以插入性能比较好、索引维护的成本比较低、对范围查询的支持也更好、占用的空间小
   - 缺点：分布式场景下有冲突问题、信息容易被泄漏、数据迁移和合并有困难

## 二、UUID能不能做主键？能
1. 主键的特点是什么？非空且唯一，UUID符不符合这两个特点？符合
2. 优点
   - 全局唯一：UUID可以保证在全球范围内的唯一性
   - 安全性：UUID的生成不依赖与数据库表结构或者存储引擎，不容易猜测
   - 易于管理：UUID自动生成，不需要程序员做什么维护
   - 可扩展性：使用UUID作为主键可以提高数据库的可扩展性，由于UUID的全局唯一性，可以轻松地添加新的记录，UUID不仅仅是表之间独立的，而且是库之间独立的
3. 缺点：
   - 性能问题：UUID是128位的字符串，通常被表示为32个字符的十六进制数。相比自增的整数 UUID 更大，占用的存储空间也更多，这会增加索引大小，导致查询变慢，尤其是在大表中。 
   - 无序性：UUID是无序的，这意味着每次插入新数据时，索引树需要频繁调整和重建。在 B-tree 索引结构中，自增的整数可以保证数据是顺序插入的，从而提高插入效率和减少碎片化，而 UUID 则会导致更多的页面拆分和索引重组，影响性能。 
   - 可读性差：UUID由一串看似随机的字符组成，难以在人类可读性方面进行快速识别和调试。而自增整数更直观，方便开发人员理解和操作。 
   - 存储空间浪费：UUID占用更多的存储空间，例如使用 CHAR(36) 或 BINARY(16) 存储 UUID，相比于 BIGINT 类型的自增 ID，这会占用更多的磁盘空间，并导致更高的内存和 I/O 开销。

## 三、MySQL在删除一个记录的时候，发生了什么？
1. 记录更新：记录头发生了变化，deleted_flag被置为1，表示这条数据被删除；但是数据没有被清空。
2. 存储碎片：由于删除标记的存在，删除操作会在表中留下空洞，这些空洞会导致存储碎片。
3. 索引更新：相关的索引必须被更新
4. 性能影响：由于删除后数据存在了“空洞”，它会直接影响后续数据的插入和查询
5. 日志记录：会生成对应的日志，方便后续回滚等
6. 【优化】为了整理碎片和空洞，可以通过重建表命令(ALTER TABLE)来整理数据。

## 四、MySQL的索引为什么不用跳表
1. B+树是多叉树结构，它的扇出非常高，通常三层左右可以存放2kw的数据，按照最复杂的情况计算，查询一个数据，最多需要进行3次磁盘IO就能找到。
2. 跳表是类似链表的结构，如果要存放2kw数据，差不多在2的24次方左右，更不要说Redis的跳表最高支持32层，如果按照最差情况估计，获取一条数据可能需要读取磁盘32次。
3. 【读操作，B+树更优秀】因此存放同样量级的数据，B+树的高度比跳表低，最坏情况下进行的磁盘IO次数更少，查询更快。 
4. 【写操作，跳表更优秀】而针对写操作，B+树需要拆分合并索引数据页，跳表则独立插入（类似链表），并根据随机函数确定层数，没有旋转和维持平衡的开销，因此跳表的写入性能会比B+树要好。 
5. 其实，mysql的存储引擎是可以换的，完全可以造一个索引为跳表的存储引擎装到mysql里；facebook造了个rocksDB的存储引擎，里面就用了跳表，它的写入性能确实是比innodb要好，但读性能确实比innodb要差不少。
6. 读多写少的场景，B+树依然占有绝对优势

## 五、Redis的ZSET为什么不用B+树而用跳表
1. redis是内存数据库，进行读写数据都是操作内存，不存在磁盘IO，读内存的数据肯定比磁盘IO快得多。 
2. B+树为了保持树的平衡是有一系列合并拆分操作的，需要额外的计算开销；而跳表插入数据时，只需要随机一下层高，不需要太多的计算。 
3. 跳表实现简单，相比B+树、AVL树、少了旋转树结构的开销，因此redis使用跳表来实现ZSET，而不是树结构。

## 六、MySQL索引效率低下问题
1. 使用二级索引作为删除条件而不是主键造成的效率低下
   - 问题描述：
     - 表table的索引(a, b)
     - 删除语句 delete * from table where a = 10 and b < 18 
     - desc delete * from table where a = 10 and b < 18结果如下，需要特别关注的`select_type`和`ref`和`Extra`

       | id | select_type | table | type  | possible_keys | key | key_len | ref | rows | Extra                              |
       |----|-------------|-------|-------|---------------|-----|---------|-----|------|------------------------------------|
       | 1  | SIMPLE      | table | range | a_b, a_b_c    | a_b | 12      | _   | 13   | Using index condition; Using where |
     
   - 经验教训：
     - 查询条件中`a=10`实际上是命中了索引的，`b<18`的条件也命中了索引，但是请记住，现在使用的都是二级索引
     - 【问题一】当二级索引取出的数据过多时，也会影响Mysql的性能，因为需要回表操作
     - 【问题二】对二级索引使用删除操作，会出现`gap lock`问题
   - 一句话总结：删除和更新操作，尽量使用主键或者唯一键进行操作定位，而不是使用范围查询，推荐的做法是查询只读库获取主键，然后使用主键删除写库的内容
2. 对二级索引使用删除操作造成的`gap lock`问题：【一句话总结：当二级索引是“男”时，加间隙锁锁定的条目数量太多了，严重影响性能】
   - 为什么基于二级索引进行删除会出现`gap lock`问题？
     - 知识背景：
       - 在可重复读隔离级别下，InnoDB会自动加间隙锁，防止幻读问题的出现，但是间隙锁会降低性能
       - 在InnoDB中，（非唯一的）二级索引重复时，将按照主键排序。
       - 由于二级索引与主键索引不同，可能存在重复的二级索引值：例如二级索引为“男”的记录可能对应主键为(1,3,5)
     - 原因详解：
       - **非唯一二级索引因键值重复，间隙划分需结合主键值**。例如，二级索引键值为 “男” 的记录可能对应主键 1、3、5，此时 “男” 的索引节点实际是 (男，1)、(男，3)、(男，5)。
       - **间隙不仅基于二级索引键值，还需包含主键值以区分重复记录，导致间隙范围更复杂**。例如，删除 (男，3) 记录时，间隙可能是( (男，1), (男，5) )，锁定范围更大。
       - <font color='yellow'>二级索引针对**主键**进行加锁，请记住，是在二级索引上实现的，而不是在主键索引上，主键索引上加的是行锁</font>
     - 因此，非唯一二级索引的间隙锁影响更显著：由于重复键值的存在，删除或更新操作可能锁定更大范围的间隙，甚至跨多个键值区间，降低并发插入性能。
     - 唯一二级索引的间隙锁效果，接近主键索引
   - 基于主键删除不会出现这种问题吗？
     - 不一定，主键索引是唯一的聚簇索引，其记录是连续存储的，且删除时锁定的间隙范围更明确。相比非唯一的二级索引，逐渐索引的**间隙锁范围更小**，更不容易出现`gap lock`问题
     - 但是不代表基于主键删除没有这种问题
3. MySQL同一张表上建立的索引超过7个，通常会影响效率


参考资料
1. 自增主键的优缺点：https://www.cnblogs.com/maidongdong/p/18172154
2. UUID做主键的缺点：https://blog.csdn.net/Dd_ddc/article/details/141962540
3. MySQL删除记录：https://www.modb.pro/db/621840
4. MySQL为什么不用跳表：https://zhuanlan.zhihu.com/p/501653725