# Go算法题相关核心编程


## 一、编程规约
1. 命名返回值：go支持在方法上声明变量，并获取返回值的写法，方法上的返回变量相当于声明局部变量
   ```go
   func sumReturn(a int, b int) sum int {
       // sum变量已经在返回值中声明了
       sum = a + b
       // 直接使用return
       return 
   }
   // 等价于
   func sumNormal(a int, b int) int {
       sum := a + b
       return sum
   }
   ```
   - 为什么会有命名返回值的做法？名义上是更直观，代码更优雅
   - 有命名返回值的执行原理：
     - 声明初始化：每一个命名的返回值会声明为一个局部变量，并根据变量类型初始化为响应的0值
     - 声明赋值：在执行完全部的代码逻辑之后<font color='yellow'>(包括defer)</font>，将该变量返回给外部方法
   - 命名返回值与无命名返回值的差异：命名返回值会被defer的逻辑影响，而无命名返回值不会
     ```go
     func main() {
         fmt.Println("getAns")
         fmt.Println(getAns(1))
         fmt.Println("getAnsReturn")
         fmt.Println(getAnsReturn(1))
     }

     func getAns(a int) int {
         fmt.Println("getAns Inner", a)
         defer func(num int) {
             a = a * 2
             fmt.Println("getAns defer Inner", a)
         }(a)
         return a
     }

     func getAnsReturn(a int) (b int) {
         fmt.Println("getAnsReturn Inner", a)
         defer func(p int) {
             b = p * 2
             fmt.Println("getAnsReturn defer Inner", b)
         }(a)
         return
     }
     // getAns
     // getAns Inner 1
     // getAns defer Inner 2
     // 1
     // getAnsReturn
     // getAnsReturn Inner 1
     // getAnsReturn defer Inner 2
     // 2
     ```
2. 



## 二、数据类型
1. go的数据类型太多了，与Java完全不同，go设计这么多数据类型的初衷是实现最高效的空间利用，尽可能少地使用空间
2. 基本数据类型分类
   - 整数：
     - 无符号整数：
       - uint8(0, 255) 
       - uint16(0, 65535) 
       - uint32(0, 4294967295) 
       - uint64(0, 18446744073709551615) 
       - uint(取决于操作系统位数)
     - 有符号整数：
       - int8(-128, 127) 
       - int16(-32768, 32767) 
       - int32(-2147483648, 2147483647) 
       - int64(-9223372036854775808, 9223372036854775807) 
       - int(取决于操作系统位数)
     - 特殊整数类型：uintptr(), 无符号整数类型，用于存储指针地址，其大小足以容纳所在平台的指针值(uint类型)
   - 浮点数：
     - 单精度浮点数：float32
     - 双精度浮点数：float64
   - 复数：在浮点数或者十进制整数后添加`i`，会自动变成复数
     - 低精度复数：(float32, float32)
     - 高精度复数：(float64, float64)
   - 布尔值：bool
   - 字符串：string
   - Unicode（符文类型）：rune，实际上是int32的别名，不如utf8格式编码对空间的利用高效
3. 字符串
   - 双引号定义的字符串
     ```go
     str := "hello，世界"
     // 双引号中的字符串会被转义
     ```
   - 反引号定义的字符串（字符串字面量）
     ```go
     str := `go is a tool.
     java is a tool. /n
     `
     // 打印效果不会被转义，所见即所得
     ```
   - len函数与编码格式
     - 获取一个utf8编码的字符串长度，是按照字节计算的
       ```go
       str := "hello, 世界"
       fmt.Println(len(str)) // 13
       fmt.Println(utf8.RuneCountInString(str)) // 9
       ```
     - go的range函数隐式支持了按照utf8遍历的规则
       ```go
       str := "hello, 世界"
	   for i, s := range str {
		   fmt.Printf("%d\t%q\t%d", i, s, i)
		   // 0	'h'	104
		   // 1	'e'	101
		   // 2	'l'	108
		   // 3	'l'	108
		   // 4	'o'	111
		   // 5	','	44
		   // 6	' '	32
		   // 7	'世'	19990
		   // 10	'界'	30028
	   }
       ```
4. 
5. 



## 三、字符串处理相关库
1. 其他类型转字符串
   ```go
   // int 类型
   num := 19
   str := strconv.Itoa(num)
   // int64等
   num64 := int64(num)
   str64 := strconv.FormatInt(num64, 10)
   // 
   ```
2. 字符串转其他类型

## 四、标准库
1. math包
    - max.MaxInt64、max.MaxUint64、max.MaxFloat64等，表示该数据类型支持的最大值
    -
2.


## 五、集合
1. 数组：数组是具有固定长度，拥有多个相同数据类型元素的序列
   - 数组的长度必须是常量表达式，数组的长度在创建的时候就必须确定
   - 创建数组的写法
   ```go
   // 普通数组声明
   var a [3]int
   // 数组字面量
   var b [3]int = [3]int{1, 2, 3}
   var c = [3]int{1, 2} // 第三个是0
   d := [...]int{1, 2, 3} // 长度由真实数据长度决定
   ```
   - 如果数组中的元素是可以比较的，则数组可以直接比较，如果数组中的长度和其中各个位置的数据全部相等，则两个数组相等
2. slice：拥有相同类型元素的可变长度的序列
   - slice的基本概念
     - 底层数组：slice是上层的一种“视图结构”，真正存储数据的是底层数组
     - 指针：指向**底层数组**中第一个可以从slice中访问的元素
     - 长度：slice的长度，用`len`获取
     - 容量：slice从指针到底层数组的最后一个元素的长度，用`cap`获取
   - slice与数组如何区分？简单来说，没有确定长度的，一律都是slice，就看方括号里面有没有数字
     - `var arr1 []int`：无长度定义，是slice
     - `arr2 := make([]int, 5)`：make定义的一定是slice
     - `arr3 := []int{}`：无长度定义，是slice
     - `arr4 := []int{1, 2, 3}`：无长度定义，是slice
     - `arr5 := [...]int{1, 2, 3}`：不定长度，但有定义定义，是数组
     - `var arr6 [5]int`：有长度定义，则是数组
     - <font color="yellow">如果在中括号中没有任何定义，是slice，哪怕后面的数量是确定的</font>
       - ```go
         func main() {
             // 数组
             a := [...]int{1, 2, 3}
             // slice
             b := []int{1, 2, 3}
             fmt.Printf("Type of a: %T\n", a)
             fmt.Printf("Type of b: %T\n", b)
		 }
         // Type of a: [3]int
         // Type of b: []int
         ```
       - ```go
         
         ```
   - 方法名上声明了`[]int`，只有slice才可以，数组不可以







参考文档
1. 数组与slice如何区分：https://www.cnblogs.com/sinclairni/p/14106519.html











