# 算法笔记《卷Ⅰ》

----

## 整数

1. 二进制的运算

    - 与运算（&）、或运算（|）、异或运算（^）
    - 右移运算符（>>）、左移运算符（<<）、无符号右移运算符（>>>）
    - 通常除以2可以使用`>>1`代表，位移计算通常更快

2. 计算`num`的二进制形式中`1`的个数，这是一个打表方法，快速统计位运算

   ```java
   // i & (i - 1) 
   public int[] countBits(int num){
       int [] result = new int[num + 1];
       for (int i = 1; i <= num; i++){
           result[i] = result[i & (i-1)] + 1;
       }
   }
   // i / 2
   public int[] countBits(int num){
       int [] result = new int[num + 1];
       for (int i = 1; i <= num; ++i){
           result[i] = result[i >> 1] + (i & 1);
         	// the same as
         	// result[i] = result[i >> 1] + i % 2;
       }
   }
   ```

3. 位运算，统计`num`的二进制写法中`1`的个数

   ```java
   for (int i = 31; i >= 0; i--){
   		ans += (num >> i) & 1;
   }
   ```

4. 特别的数字

   题目：一个数组中，所有的数字都出现了`n`次，只有一个数字出现了`m`次，请找出。

   ```java
   public int singleNumber(int[] nums, int n, int m){
       int [] bitSums = new int[32];
       for (int num : nums){
           for (int i = 0; i <= 31; i++){
               bitSums[i] += (num >> (31 - i)) & 1;
           }
       }
       int result = 0;
       for (int i = 0; i < 32; i++){
           result = (result << 1) + bitSums[i] % n;
       }
       return result / m;
   }
   ```

5. 快速幂算法

   ```java
   // 快速幂
   public static long fastGetRes(int num, int pow) {
       int tem = 1;
       int pow_remain = pow;
       while (pow_remain > 0){
           // 寻找合适的指数次幂
           int pow_log = 1;
           int pow_res = num;
           while (pow_log < pow_remain){
               pow_log *= 2;
               if (pow_log < pow_remain) {
                   pow_res *= pow_res;
               } else {
                   pow_log /= 2;
                   break;
               }
           }
           tem *= pow_res;
           pow_remain -= pow_log;
       }
       return tem;
   }
   ```

   ```java
   // 快速幂运算
   int res = 1;
   while(b != 0){
   	if(b%2) res*=a;// 该位是否有效
     a*=a;// 下一位权重
     b/=2;// 下一位指数（模2）
   }
   return res;
   ```

   ```java
   // 矩阵快速幂算法
   
   ```

6. 判断素数的方法及相关问题

    - 前两种不介绍，遍历到`n`和遍历到`sqrt(x)`不再重复，没有优化价值。

    - `ACM`范围内可代码实现的最优方法——埃氏筛法

      > 算法细节：埃氏筛法相当于一种预处理，提前计算好范围内的所有素数，这样无论数据量多大，出什么样的问题都可以轻松应对。
      >
      > 算法内容：首先将`n`个数写下来，其中2是最小的素数，将表中所有的2的倍数划去，表中剩下的最小的数字就是3，再将所有3的倍数划去，以此类推。每次都遍历得到表中当前最小的数，然后将所有该数的倍数划去......
      >
      > 应用场景：对许多素数进行检测、统计素数出现的次数
      >
      > 时间复杂度：$O(n * log(log n))$

      ```java
      // 预处理，预处理的优势就在于可以应对多次查询而只用O(1)的时间复杂度
      int n;
      boolean[] log = new boolean[n + 1];
      for (int i = 0; i <= n; i++){
          log[i] = true;
      }
      log[1] = false; // 代表1不是质数
      for (int i = 2; i <= n; i++){
          if (log[i]){
              for (int j = 2 * i; j <= n; j = j + i){
                  log[j] = false;
              }
          }
      }
      // 第一种问法：n以内素数的个数
      int count = 0;
      for (int i = 0; i <= n; i++){
          if (log[i]){
              count++;
          }
      }
      return count;
      // 第二种问法：给定区间[a,b]，求区间内的素数个数
      int count1 = 0;
      for (int i = 0; i <= a; i++){
          if (log[i]){
              count1++;
          }
      }
      int count2 = 0;
      for (int i = 0; i <= b; i++){
          if (log[i]){
              count2++;
          }
      }
      return count2 - count1;
      // 第三种问法：给定n，判断是不是素数
      return log[n];
      ```

    - 孪生素数方法（时间复杂度没有提升，只是会更快一点）

      > 孪生素数的方法基于一个规律：所有的素数要么是`6n + 1`要么是`6n - 1`，比较好证明，分别枚举`6n + 1` 、`6n + 2`、`6n + 3`、`6n + 4`、`6n + 5`就能够发现这个小规律。所以在筛查素数的时候只需要每6个迭代一次。
      >
      > `6n + 1`和`6n - 1`是一对孪生素数。

      ```java
      public boolean isPrime(int num){
          if (num == 2 || num == 3){
              return true;
          }
          // 不满足孪生素数规律的一定不是
          if (num % 6 != 1 && num % 6 != 5){
              return false;
          }
          // 满足孪生素数规律的也不一定是
          int temp = Math.sqrt(num);
          for (int i = 5; i <= temp; i += 6){
              if (num % i == 0 || num % (i + 2) == 0){
                  return false;
              }
          }
          // 全部筛过，确定是素数
          return true;
      }
      ```

7. 最大公因数的求法

   最大公因数的求法包括三种算法，分别是更相减损法、辗转相除法、`stein`算法。

   三种算法的基本特点如下：

   | 算法        | 特点                                                       |
      | ----------- | ---------------------------------------------------------- |
   | 更相减损法  | 时间复杂度在`O(n)`级别，在两个数差距比较大的时候效率尤其差 |
   | 辗转相除法  | 时间复杂度稳定在`O(logn)`级别                              |
   | `stein`算法 | 在大数范围内（至少超过`long`的级别）才需要                 |

    - 更相减损法

      > 以较大的数减去较小的数，接着将差与较小的数比较，并用大数减去小数，重复这个操作，直到所得到的减数和差相等为止。

      ```java
      public int gcd(int a, int b){
          if (a == b){ // 两数相等则终止
              return a;
          } else {
              if (a > b){
                  a = a - b;
                  return gcd(a,b);
              } else {
                  b = b - a;
                  return gcd(a,b);
              }
          }
      }
      ```

    - 辗转相除法

      > 也称作欧几里得算法，主要借助除法求最大公因数。
      >
      > 其中值得一提的是，求出了最大公因数就可以求出最小公倍数：
      >
      > $最小公倍数 = a * b / gcd(a,b)$

      ```java
      public int gcd(int a, int b){
          // 保证a >= b;
          if (a < b){
              int temp = b;
              b = a;
              a = temp;
          }
          int r = a % b;
          if (r == 0){ // 相除余数为0则终止
              return b;
          } else {
              a = b;
              b = r;
              return gcd(a,b);
          }
      }
      
      // 确保 a < b 的一行递归代码版本
      public int gcd(int a. int b){
          return b == 0 ? a : gcd(b, a % b);
      }
      // 确保 a < b 的循环版本
      public int gcd(int a, int b){
          while (b != 0){
              int r = b;
              b = a % b;
              a = r;
          }
          return a;
      }
      ```

    - `stein`算法（仅适用于数超大时，这里的示例是`int`）

      > 算法过程：
      >
      > 若`a`和`b`都是偶数，则记录下公约数`2`，然后两个数字都除以`2`
      >
      > 若其中一个数是偶数，则偶数除以`2`。（因为这时候的`2`不可能是公因数了）
      >
      > 如果这两个都是奇数，则$a=|a-b|$，$b=min(a,b)$，继续重复上述过程。

      ```java
      public int gcd_stein(int a, int b){
          int acc = 0;
          while ((a & 1) == 0 && (b & 1) == 0){
              acc++;
              a >>= 1;
              b >>= 1;
          }
          while ((a & 1) == 0) a >>= 1;
          while ((b & 1) == 0) b >>= 1;
          if (a < b) {
              int temp = a;
              int a = b;
              int b = temp;
          }
          while ((a = (a - b) >> 1) != 0){
              while ((a & 1) == 0) a >>= 1;
              if (a < b) {
                  int t = a;
                  a = b;
                  b = t;
              }
          }
      }
      ```

8.

----

## 数组

1. 数组最大的好处就是访问元素直观而有效，可以在给定`index`的条件下使用`O(1)`的复杂度就得到元素中的值。

2. 双指针解题

   **反向双指针**：方向相反的双指针通常用来求**排序数组**中的两个数字之和，给定某个数组，先排序，指定一个起始指针和末尾指针，结果大于`target`就向左移动右指针，小于`target`就向右移动左指针。

   **同向双指针**：方向相同的双指针经常用来求**正数数组**中子数组的和或乘积，初始化的时候两个指针`P1`和`P2`都在最左边的同一个起点，如果两个指针之间的数组之和或乘积大于`target`，那么右移`P1`指针，反之移动`P2`指针。

3. 和或乘积为某一固定值的连续子数组问题

    - **正整数**组成的数组，解决连续子数组问题时，不论求和还是求乘积，都可以直接使用双指针的方法。
    - 包含了**负整数和零**的，要先求和或乘积预处理，然后使用`HashMap<Integer,Integer>`记录下这些和或乘积及出现的次数（注意初始的时候要`put(0,1)`）；每次遍历到新数字，先判断有没有满足条件的，再预处理这个数字。

4. 尺取法（数组与双指针的经典结合）

    - 尺取法的基本定义：顾名思义，像尺子一样取一段，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的时候，所以说尺取法是一种高效的枚举区间的方法，是一种技巧，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案，所以要先判断是否可以使用尺取法再进行计算。
    - 尺取法典型例题（Q594）
    - l

5. 约瑟夫环问题【本质上是找规律的思路，公式是次要的】

   > 问题定义：`m`个人围成一圈，指定一个数字`n`，从第一个人开始报数，每轮报到`n`的选手出局，由下一个人接着从头开始报，求最后剩下的人？
   >
   > $n > 2 且 m > 1$

    - 解法一：模拟法【时间复杂度为$O(m*n)$】

      使用链表或循环队列模拟。

    - 解法二：公式法（迭代循环）

      > 关键是理解推导公式的生成过程：
      >
      > $f(n, m):= $`n`个人报数，每报到`m`的时候杀掉那个人，最终胜利者的编号
      >
      > 递推公式：$f(n,m) = (f(n-1,m) + m) \% n$
      >
      > 推导原理：每杀掉一个人，其实就是把这个数组向前移动了M位。
      >
      > 模拟过程：【11个人杀掉喊3的】
      >
      > 1. 假设我们已经知道11个人时，胜利者的下标位置为6。那下一轮10个人时（也就是刚刚杀掉一个人），胜利者的下标位置为多少？
           >
           >    第一轮结束后胜利者相当于前移了3位，因为前面三个在第一轮遍历中存活下来了。
      >
      > 2. 假设我们已经知道10个人时，胜利者的下标位置为3。那下一轮11个人时，胜利者的下标位置为多少？ （1的逆过程）
           >
           >    $f(11,3) = (f(10,3) + 3) \% 11$
      >
      > 3. 现在改为人数改为N，报到M时，把那个人杀掉，那么数组是怎么移动的？
           >    答：每杀掉一个人，下一个人成为头，相当于把数组向前移动M位。若已知`N-1`个人时，胜利者的下标位置位$f(n−1,m)$，则`N`个人的时候，就是往后移动`M`为，(因为有可能数组越界，超过的部分会被接到头上，所以还要模`N`)。

      ```java
      public int findWinner(int n, int m){
          // n是人数，m是报数
          int p = 0;
          for (int i = 2; i <= n; i++){
              p = (p + m) % i;
          }
          return p; // 根据数组下标或人的编号决定是否 +1 
      }
      ```

      > 特别的，$f(2^n,2) = 1$

6. 蓄水池抽样算法

    - 算法应用：随机取出一个链表的元素（如果是定长数据流的话，可以用哈希，但是不定长的数据流，只能使用蓄水池抽样算法了）

      使用蓄水池抽样算法，就只因为不能全部存下我们需要的所有元素，选择用一个固定大小的蓄水池将元素记录下来。

    - 算法描述：从前往后处理每个样本，每个样本成为答案的概率为$1/i$，其中`i`为样本编号（编号从1开始），最终可以确保每个样本成为答案的概率均为`1/n`。简单来说，只要下标从1开始，我们可以使用数组的下标来代表

    - 算法证明：

      假设最终成为答案的样本编号为`k`，那么`k`成为答案的充要条件为在遍历到`k`时被选中并且遍历大于`k`的所有元素时，均没有被选择（不包括`k`）,`n`为数组长度。

   $$
   P(k被选择) = \frac{1}{k} * (1 - \frac{1}{k + 1}) * (1 - \frac{1}{k + 2}) * ... * (1 - \frac{1}{n})
   $$

   ​		其中首项$1/k$为选中`k`的概率，后面每项分别为编号`[k + 1, n]`的样本不被选择的概率。

   ​	化简得到：
   $$
   P = \frac{1}{k} * \frac{k}{k + 1} *  \frac{k + 1}{k + 2} * ... * \frac{n - 1}{n} = \frac{1}{n}
   $$
   ​		因此，在每一次 `getRandom` 时，从前往后处理每个节点，同时记录当前节点的编号，当处理到节点`k`时，在$[0,k)$区间内进行随机，若随机到结果为`0`（发生概率为$1/k$），则将节点`k`的值存入答案，最后一次覆盖答案的节点即为本次抽样的结果。

    - 代码实现

      ```java
      class Solution {
          int[] nums;
          Random random;
      
          public Solution(int[] nums) {
              this.nums = nums;
              random = new Random();
          }
      
          public int pick(int target) {
              int ans = 0;
              for (int i = 0, cnt = 0; i < nums.length; ++i) {
                  if (nums[i] == target) {
                      ++cnt; // 第 cnt 次遇到 target
                      if (random.nextInt(cnt) == 0) {
                          ans = i;
                      }
                  }
              }
              return ans;
          }
      }
      ```

7. 求数组中的中位数

    - 方法一：排序

      ```java
      public int findMid(int[] nums){
          Arrays.sort(nums);
          int n = nums.length;
          return n % 2 == 1 ? nums[n / 2] : (nums[n / 2] + nums[n / 2 - 1]) / 2
      }
      ```

    - 快速选择

      快速选择算法：从一个给定的集合中，选出第k个大小的数字，或者给出其所在下标。

      快速选择算法的**平均时间复杂度是$O(n)$**

      > 快速选择算法的思想：
      >
      > - 利用快速排序的分治思想，求得待搜索数组按照的主元S[q]（pivot）（主元的选定有好几种方法，这里不详细讨论，可参考快速排序），以主元为界分成左右两个区间
      >
      > - 通过比较主元的位置，判断第K个大小的数在主元左区间？在主元又区间？还是就是主元？（还要注意边界条件的判断，有可能在边界）
      >
      > - 进入子区间递归调用



---

## 字符串

1. `Java`中常用的`String`函数

   | 函数                        | 函数功能                                       |
      | :-------------------------- | ---------------------------------------------- |
   | `chaAt`                     | 返回指定下标处的字符                           |
   | `compareto`                 | 按照字典顺序比较两个字符串                     |
   | `equals`                    | 判断两个字符串的长度和内容是否相等             |
   | `indexOf`                   | 返回字符串中某个字符或子字符串首次出现的下标   |
   | `lastIndexOf`               | 返回字符串中某个字符或子字符串最后出现的下标   |
   | `length`                    | 返回字符串的长度                               |
   | `split`                     | 将字符串按照指定的分隔符进行分割，返回一个数组 |
   | `substring`                 | 按照下标截取子字符串                           |
   | `toLowerCase / toUpperCase` | 将字符串中的所有字母变为大写或小写             |

    - `java`中的`indexOf API`使用的是暴力匹配算法，能不用尽量别用。

      ```java
      public static int indexOfLatin1Unsafe(byte[] src, int srcCount, byte[] tgt, int tgtCount, int fromIndex) {
          assert fromIndex >= 0;
          assert tgtCount > 0;
          assert tgtCount <= tgt.length;
          assert srcCount >= tgtCount;
          char first = (char)(tgt[0] & 0xff);
          int max = (srcCount - tgtCount);
          for (int i = fromIndex; i <= max; i++) {
              // Look for first character.
              if (getChar(src, i) != first) {
                  while (++i <= max && getChar(src, i) != first);
              }
              // Found first character, now look at the rest of v2
              if (i <= max) {
                  int j = i + 1;
                  int end = j + tgtCount - 1;
                  for (int k = 1;
                       j < end && getChar(src, j) == (tgt[k] & 0xff);
                       j++, k++);
                  if (j == end) {
                      // Found whole string.
                      return i;
                  }
              }
          }
          return -1;
      }
      ```

2. `java`正则表达式

    - 正则表达式的基本使用

      ```java
      import java.util.regex.Pattern;
      import java.util.regex.Matcher;
      // 1.正则表达式模式
      String regStr = "\\d\\d\\d\\d";
      // 2.创建模式对象（正则表达式模式对象）
      Pattern pattern = Pattern.compile(regStr);
      // 3.创建匹配器
      Matcher matcher = pattern.matcher(context);
      // 4.开始循环匹配
      while(matcher.find()){
          System.out.println(matcher.group(0));
      }
      ```

    - 在`String`类中使用正则表达式

      ```java
      // 直接使用replaceAll
      String content = "JDK1.3JDK1.4";
      content = content.replaceAll("JDK1\\.3|JDK1\\.4","JDK");
      // 直接使用matches，是整体匹配，正则表达式中没必要有^、$ 
      String tel = "13688899999";
      boolean answer = tel.matches("1(38|39)\\d{8}");
      // 分割
      String text = "hello#abc-jack12smith~北京";
      String[] srr = text.split("-|~|#|\\d+")
      ```

    - 正则表达式三个常用类

      `java.util.regex`包下包括下面三个类`Pattern`、`Matcher`、`PatternSynaxException`：

      `Pattern`：该对象是一个正则表达式对象。无公共构造方法，要创建一个`Pattern`对象，调用其公共静态方法，它返回一个`Pattern`对象。该方法接受一个正则表达式作为它的第一个参数。

      `Matcher`：该对象是对输入字符串进行解释和匹配的引擎。无公共构造方法。要调用`Pattern`对象的`matcher`方法来获得一个`Matcher`对象

      `PatternSynaxException`：该类是一个非强制异常类，表示一个正则表达式模式中的语法错误。

      > `Pattern`类的方法`matches`：
      >
      > ```java
     > // matches是在执行整体匹配，验证整体匹配是否成功
     > // 使用matches可以不使用^和$定位符，因为是整体匹配，而不是像find方法从context中部分匹配
     > boolean isMatch = Pattern.matches(pattern, context);
     > // Pattern的matches方法底层上使用的是Matcher的matches方法
     > ```
      >
      > `Matcher`类
      >
      > | 方法                                             | 说明                                                         |
           > | ------------------------------------------------ | ------------------------------------------------------------ |
      > | `public int start()`                             | 返回以前匹配的初始索引                                       |
      > | `public int start(int group)`                    | 返回以前的匹配操作期间，由给定组捕获的子序列的初始索引       |
      > | `public int end()`                               | 返回最后匹配字符之后的偏移量                                 |
      > | `public int end(int group)`                      | 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量 |
      > | `public boolean lookingAt()`                     | 尝试将从区域开头开始的输入序列与该模式匹配                   |
      > | `public boolean find()`                          | 尝试查找与该模式匹配的输入序列的下一个子序列                 |
      > | `public boolean find(int start)`                 | 重置此匹配器，然后尝试查找匹配该模式，从指定索引开始的输入序列的下一个子序列 |
      > | `public boolean matches()`                       | 尝试将整个区域与模式匹配                                     |
      > | `public String replaceAll(String replacement)`   | 替换模式与给定替换字符串相匹配的输入序列的每个子序列         |
      > | `public String replaceFirst(String replacement)` | 替换模式与给定替换字符串相匹配的输入序列的第一个子序列       |
      >
      > ```java
     > // replaceAll实现的替换不会在原字符串上，而是会返回新的字符串
     > String regStr = "helloworld";
     > String context = "helloworldhello";
     > Pattern pattern = Pattern.compile(regStr);
     > Matcher matcher = pattern.matcher(context);
     > String newContext = matcher.replaceAll("世界你好"); // 返回新的字符串中变化了
     > ```

    - `java`正则表达式底层实现

      > 【无分组的情况】
      >
      > `String regStr = "\\d\\d\\d\\d"`的`matcher.find()`里面发生了什么？
      >
      > 1. `matcher`根据指定规则，定位满足规则的子字符串
      > 2. 找到后将子字符串的开始索引记录到`matcher`对象的属性`int[] groups`中；把该子字符串结束的`索引+1`的值记录到`groups[1]`
      > 3. `groups[0]-groups[1]`范围内的字符串被截取并存在`matcher.group(0)`中，使用打印语句输出到屏幕
      > 4. 同时记录`oldLast`的值为子字符串的结束的索引+1，即下次执行`find`时，从该位置开始`oldLast`
      > 5. 重复上述过程

      ```java
      // matcher.group()的底层实现
      public String group(int group) {
          if (first < 0)
              throw new IllegalStateException("No match found");
          if (group < 0 || group > groupCount())
              throw new IndexOutOfBoundsException("No group " + group);
          if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
              return null;
          return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString(); // 根据传入的group进行截取
      }
      ```

      >【有分组的情况】
      >
      >`String regStr = "(\\d\\d)(\\d\\d)"`的`matcher.find()`里面发生了什么？
      >
      >1. `matcher`根据指定规则，定位满足规则的子字符串
      >
      >2. 找到后将子字符串的开始索引记录到`matcher`对象的属性`int[] groups`中；把该子字符串结束的`索引+1`的值记录到`groups[1]`
      >
      > 记录第一组`()`内的字符串到`groups[2]`和`groups[3]`中；
      >
      > 记录第二组`()`内的字符串到`groups[4]`和`groups[5]`中；
      >
      > 如果有更多的分组依此类推
      >
      >3. `groups[0]-groups[1]`范围内的字符串被截取并存在`matcher.group(0)`中，使用打印语句输出到屏幕
      >
      > 第一组的内容被记录在`matcher.group(1)`中
      >
      > 第二组的内容被记录在`matcher.group(2)`中
      >
      >4. 同时记录`oldLast`的值为子字符串的结束的索引+1，即下次执行`find`时，从该位置开始`oldLast`
      >
      >5. 重复上述过程

    - 正则表达式语法（基本符号、元字符）

        1. 转义符

           `java`中`\\`相当于`\`

           | 匹配对象 | 表达式 |
                   | -------- | ------ |
           | "("      | "\\("  |
           | "."      | "\\."  |

        2. 限定符（多个重复都是贪婪匹配）

           | 符号    | 含义                                     | 示例          | 说明                                                 |
           | ------- | ---------------------------------------- | ------------- | ---------------------------------------------------- |
           | `*`     | 指定字符重复`0`次或`n`次（无要求）       | `(abc)*`      | 仅包含任意个`abc`的字符串，等效于`\w*`               |
           | `+`     | 指定字符可以重复`1`次或`n`次（至少一次） | `m+(abc)*`    | 以至少一个`m`开头，后接任意个`abc`的字符串           |
           | `?`     | 指定字符可以重复`0`次或`1`次（最多一次） | `m + abc?`    | 以至少一个`m`开头，后接`ab`或`abc`的字符串（⚠0️⃣）     |
           | `{n}`   | 只能输入`n`个字符                        | `[abcd]{3}`   | 由`abcd`中字母组成的任意长度为3的字符串              |
           | `{n,}`  | 指定至少`n`个匹配                        | `[abcd]{3,}`  | 由`abcd`中字母组成的任意长度不小于3的字符串（⚠1️⃣）    |
           | `{n,m}` | 指定至少`n`个但不多于`m`个匹配           | `[abcd]{3,5}` | 由`abcd`中字母组成的任意长度不小于3且不大于5的字符串 |

           > ⚠0️⃣：`?`的作用域仅限于前一个字符，如果要扩大就要使用括号将前面的内容括起来
           >
           > ⚠1️⃣：`java`默认的匹配是贪婪匹配，在可能的情况下优先匹配更多的，例如：`a{3,}`当出现`aaaaaa`优先返回`aaaaaa`，不返回`aaa`和`aaa`

        3. 选择匹配符

           在匹配某个字符串的时候时选择性的，既可以匹配这个又可以匹配那个，这时候需要使用选择匹配符号`|`

           ```java
           String regStr = "han|含|翰";
           // 2.创建模式对象（正则表达式模式对象）
           Pattern pattern = Pattern.compile(regStr);
           // 3.创建匹配器
           Matcher matcher = pattern.matcher(context);
           // 4.开始循环匹配
           while(matcher.find()){
               System.out.println(matcher.group(0));
           }
           ```

        4. 分组组合

           分组：我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分可以看作是一个子表达式或一个分组。

            - 分组：常用分组构造形式（这里介绍的都是捕获的，也就是说都可以用`group(1)`等形式得到匹配内容的）

              | 常用分组构造形式   | 说明                                                         |
                        | ------------------ | :----------------------------------------------------------- |
              | `(pattern)`        | 非命名捕获。捕获匹配的字符串。编号为0的第一个捕获是由整个正则表达式模式匹配的文本，其他捕获结果则根据左括号的顺序从1开始自动编号。 |
              | `(?<name>pattern)` | 命名捕获。将匹配的字符串捕获到一个组名称或编号名称中。用于`name`的字符串不能包含任意变电符号，并且不能以数字开头。可以使用单引号代替尖括号，例如`(?'name')` |

              ```java
              // 命名捕获
              String regStr = "(?<g1>\\d\\d)(?<g2>\\d\\d)";
              Pattern pattern = Pattern.compile(regStr);
              Matcher matcher = pattern.matcher(content);
              while (matcher.find()){
                  // 非命名捕获可以照常使用
                  System.out.println(matcher.group(0));
                  // 命名捕获，通过组名来取
                  System.out.println(matcher.group("g1"));
              }
              ```

            - 分组：特别分组（这里介绍的都是非捕获的，也就是说都**不可以**用`group(1)`等形式得到匹配内容）

              捕获：把正则表达式中子表达式或分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，以左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

              | 分组构造形式  | 说明                                                         |
                        | ------------- | ------------------------------------------------------------ |
              | `(?:pattern)` | 匹配`pattern`但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。（⚠0️⃣） |
              | `(?=pattern)` | 非捕获匹配。（⚠1️⃣）                                           |
              | `(?!pattern)` | 该表达式匹配不处于匹配`pattern`的字符串的起始点的搜索字符串。非捕获匹配。（⚠2️⃣） |

              ```java
              // ⚠0️⃣ (?:pattern)
              String context = "industryindustries"
              String regStr_1 = "industr(?:y|ies)"; // 匹配industry或industries
              String regStr_2 = "industry|industries";
              // 二者的含义相同，但显然1的表达更简洁
              Pattern pattern = Pattern.compile(regStr);
              Matcher matcher = pattern.matcher(content);
              while (matcher.find()){
                  System.out.println(matcher.group(0));
                  // 括号的形式看起来像一个分组，但是并不能使用 matcher.group(1) 获取内容
                  // 这种写法主要是为了取消分组的效果提高匹配效率，所以也就是说这个看起来像分组一样的东西并不是分组
                  /* System.out.println(matcher.group(1)); */
              }
              ```

              ```java
              // ⚠1️⃣ (?=pattern)
              String content = "helloworldhellofriendhelloschool"
              String regStr_1 = "hello(?=world|friend)"; // 只匹配后面是world和friend的hello
              Pattern pattern = Pattern.compile(regStr);
              Matcher matcher = pattern.matcher(content);
              while (matcher.find()){
                  System.out.println(matcher.group(0));
                  // hello hello
                  // 非捕获匹配
                  /* System.out.println(matcher.group(1)); */
              }
              ```

              ```java
              // ⚠2️⃣ (?!pattern)
              String content = "helloworldhellofriendhelloschool"
              String regStr_1 = "hello(?=world|friend)"; // 只匹配后面不是world和friend的hello
              Pattern pattern = Pattern.compile(regStr);
              Matcher matcher = pattern.matcher(content);
              while (matcher.find()){
                  System.out.println(matcher.group(0));
                  // hello
                  // 非捕获匹配
                  /* System.out.println(matcher.group(1)); */
              }
              ```

        5. 字符匹配符

           | 符号    | 含义                                             | 示例           | 解释                                                   |
                   | ------- | ------------------------------------------------ | -------------- | ------------------------------------------------------ |
           | `[` `]` | 可接受的字符列表（单个字符匹配）⚠0️⃣               | `[efgh]`       | e、f、g、h中的任意一个字符                             |
           | `[`^`]` | 不接受的字符列表                                 | `[^abc]`       | 接受除了a、b、c之外的任意一个字符                      |
           | `-`     | 连字符                                           | `A-Z`          | 任意大写字母                                           |
           | `.`     | 匹配除`\n`以外的任何字符                         | `a..b`         | 以a开头b结尾中间包含任意两个字符的长度为4的字符串      |
           | `\\d`   | 匹配单个数字字符                                 | `\\d{3}(\\d)?` | 以单个非数字字符开头，后接任意个数字的字符串           |
           | `\\D`   | 匹配单个非数字字符                               | `\\D(\\d)*`    | 以单个非数字字符开头，后接任意个数字的字符串           |
           | `\\w`   | 匹配单个数字、大小写字母、下划（`[0-9a-zA-Z_]`） | `\\d{3}\\w{4}` | 以3个数字字符开头的长度为7的数字字母字符串             |
           | `\\W`   | 匹配单个非数、大小写字母、下划（`[^0-9a-zA-Z_]`) | `\\W+\\d{2}`   | 以至少1个非数字字母字符串开头，2个数字字符结尾的字符串 |
           | `\\s`   | 匹配任何空白字符`[\\f\\n\\r\\t\\v]`              | `\\s+`         | 任意长度的空白字符都可以被匹配                         |
           | `\\S`   | 匹配任何非空白字符`[^\\f\\n\\r\\t\\v]`           | `\\S\\s{2}`    | 以一个非空白字符开头的两个空格结尾的字符串             |
           | `\\f`   | 匹配换页符                                       |                |                                                        |
           | `\\n`   | 匹配换行符                                       |                |                                                        |
           | `\\r`   | 匹配回车符                                       |                |                                                        |
           | `\\t`   | 匹配制表符                                       |                |                                                        |
           | `\\v`   | 匹配垂直制表符                                   |                |                                                        |

           > ⚠0️⃣：当`?`、`.`等写入`[]`中的时候，就仅仅代表`?`、`.`的匹配了，没有其他含义。中括号内的内容都是它们本身的含义。

        6. 定位符

           定位符：规定要匹配的字符串出现的位置，比如在字符串开始的时候还是在结束的时候。

           | 符号  | 含义                   | 示例             | 说明                                                         |
                   | ----- | ---------------------- | ---------------- | ------------------------------------------------------------ |
           | `^`   | 指定起始字符           | `^[0-9]+[a-z]`   | 以至少一个数字开头，后接任意个小写字母的字符串               |
           | `$`   | 指定结束字符           | `^[0-9]-[a-z]+$` | 以一个数字开头后接连字符`-`，并以至少一个小写字母结尾的字符串 |
           | `\\b` | 匹配目标字符串的边界   | `han\\b`         | 这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置 |
           | `\\B` | 匹配目标字符串的非边界 | `han\\B`         | 和`\b`的含义刚刚相反                                         |

    - 正则表达式语法

        1. 实现不区分大小写【`i`代表`ignore`】

           `(?i)abc`：`a`、`b`、`c`都不分大小写

           `a(?i)bc`：只有`b`、`c`不区分大小写

           `a((?i)b)c`：只有`b`不区分大小写

           `Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);`

        2. 实现非贪婪匹配

           | 关键符号 | 说明                                                         |
                   | -------- | ------------------------------------------------------------ |
           | `?`      | 当此字符紧随任何其他限定符`(*、+、?、{n}、{n,}、{n,m})`之后时，匹配模式是"非贪心的"。非贪心的模式匹配尽可能短的字符串。 |

           ```java
           String non_greedy = "o+?";
           String greedy = "o+";
           String context = "oooo";
           // 非贪心模式
           Pattern pattern = Pattern.compile(non_greedy);
           Matcher matcher = pattern.matcher(content);
           while (matcher.find()){
               System.out.println(matcher.group(0));
               // o o o o 非贪心模式
           }
           // 贪心模式
           Pattern pattern_ = Pattern.compile(greedy);
           Matcher matcher_ = pattern.matcher(content);
           while (matcher_.find()){
               System.out.println(matcher_.group(0));
               // oooo 贪心模式
           }
           ```

        3. 匹配任何字符，包括`\\r\\n`

           ```java
           // 使用[\\s\\S]
           String allMatch = "[\\s\\S]";
           Pattern pattern = Pattern.compile(allMatch);
           Matcher matcher = pattern.matcher(content);
           while (matcher.find()){
               System.out.println(matcher.group(0));
           }
           ```

        4. 反向引用

            - 圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用，这种引用既可以实在正则表达式内部，也可以是在正则表达式外部，内部反向引用`\\`分组号，外部反向引用使用`$`分组号。

            - 实例：

              ```java
              // 要匹配两个连续的相同数字，前面包起来，后面双斜杠加数字
              String regStr = "(\\d)\\1";
              // 要匹配五个连续的相同数字
              String regStr = "(\\d)\\1{4}"; 
              // 要匹配个位与千位相同，十位与百位相同的数
              String regStr = "(\\d)(\\d)\\2\\1";
              ```

            - 经典结巴程序

              ```java
              String context = "我要...要...学学学...编...编程java";
              // 去掉.
              Pattern pattern_1 = Pattern.compile("\\.");
              Matcher matcher_1 = pattern_1.matcher(context);
              context = matcher.replaceAll("");
              // 去掉重复的字 使用(.)\\1+匹配
              Pattern pattern_2 = Pattern.compile("(.)\\1+"); // 分组的内容记录到$1
              Matcher matcher_2 = pattern_2.matcher(context);
              // 使用$在 【外部】匹配
              context = matcher_2.replaceAll("$1"); // $1表示第一组中匹配到的内容
              // 去掉重复的字：一行代码
              context = Pattern.compile("(.)\\1+").matcher(context).replaceAll("$1");
              ```

    - 案例实际应用

      ```java
      // 汉字匹配(用十六进制的方式)
      String regStr = "^[\u0391-\uffe5]+$";
      // 邮政编码(比如：1-9开头的一个六位数)
      String regStr = "^[1-9]\\d{5}$";
      // QQ号(比如：1-9开头的一个5-10位数)
      String regStr = "^[1-9]\\d{4,9}$";
      // 手机号码(比如：以13、14、15、18开头的11位数)
      String regStr = "^1[3|4|5|8]\\d{9}$";
      // 验证是不是整数或小数
      String regStr = "^[-+]?([0-9]\\d*|0)(\\.\\d+)?$";
      ```

3. 双指针与字符串：将字符串看作字符的数组，也可以同样使用双指针的思路解决一些问题。

   比如不含重复字符的最长子字符串、包含所有字符的最短字符串问题等等。

4. 对于变位词、重复字符、包含某些特定字符的问题，我们必须想到词频统计。

   词频统计一般有两种实现形式，如果题目中规定了只包含数字或字符，可以用有限大小的数组来实现词频统计；如果题目中没有规定，那么最好还是使用`HashMap`来实现词频统计。

   ```java
   // 词频统计实现形式——数组实现
   public int[] countChars(String word){
       char[] crr = word.toCharArray();
       int[] count = new int [26]; // 只统计小写字母
       for (int i = 0; i < crr.length; i++){
           count[crr[i] - 'a']++;
       }
       return count;
   }
   // 词频统计实现形式——哈希表实现
   public void countChars(String word){
       char[] crr = word.toCharArray();
       Map<Character, Integer> map = new HashMap<>(); 
       for (int i = 0; i < crr.length; i++){
           map.put(crr[i], map.getOrDefault(crr[i],0) + 1);
       }
   }
   ```

5. 回文字符串问题

    - **反向双指针思路**：最常用的、最能直接想到的解法就是使用双指针求解，即使用双指针从字符串的两端向中央不断移动。

    - **中心延伸双指针**：还可以从字符串中央开始，逐渐向两边延伸；但是考虑到字符串有奇数长度或偶数长度的，可以使用`i + 1`等价变成奇数长度。

    - `Manacher`算法

      > `Manacher`算法介绍

      ```java
      // Manacher算法
      public void Manacher(String a){
          char[] crr = new char[a.length() * 2];
          
      }
      
      ```



6. 回文字符串与动态规划结合



7. 字符串匹配算法

   > 表：总时间复杂度
   >
   > | 算法         | 匹配时间                   |
      > | ------------ | -------------------------- |
   > | 暴力匹配     | $O(n * m)$                 |
   > | RK算法       | 最坏$O(n * m)$，最好$O()$  |
   > | 有限自动机   | $O(n)$ + $O(m *            |
   > | KMP算法      | $O(n)$ + $O(m)$            |
   > | BM算法       | 最坏$O(m*n)$，最好$O(n/m)$ |
   > | Sunday算法   | 最坏$O(m*n)$，最好$O(n/m)$ |
   > | Horspool算法 |                            |
   >
   > 表：`n`代表文本长度，`m`代表子串长度。$|\sum|$代表的是字符集的大小。
   >
   > | 算法                     | 预处理时间  | 匹配时间      |
      > | ------------------------ | ----------- | ------------- |
   > | 暴力匹配算法             | $0$         | $O((n-m+1)m)$ |
   > | `Rabin-Karp`算法         | $\Theta(m)$ | $O((n-m+1)m)$ |
   > | 有限自动机算法           | $O(m *      | \sum          |
   > | `Knuth-Morris-Pratt`算法 | $\Theta(m)$ | $\Theta(n)$   |

    - 暴力匹配算法（`Brute Force`）：

      思想：首先将原字符串和子串左端对齐，逐一比较；如果第一个字符不能匹配，则子串向后移动一位继续比较；如果第一个字符匹配，则继续比较后续字符，直至全部匹配。

      ```java
      // 没有什么用的暴力算法
      String text = "texttexttexttext";
      String subString = "tex";
      List<Integer> list = new ArrayList<Integer>();
      for (int i = 0; i <= text.length() - subString.length(); i++){
          if (subString.equals(text.substring(i,i + subString.length()))){
              list.add(i);
          }
      }
      return list;
      ```

    - `RK`算法：

      思想：根据字符串的内容简单计算出一个“哈希值”，比较哈希值来确定字符串是否有可能匹配，如果哈希值同，那么逐个检查；哈希值不同的一定不匹配。算法中比较重要的就是计算哈希值和哈希值的滚动。

      > 字符集大小$d$一般作为基数，或者对于小写字母字符集使用31这个数作为基数更强地避免哈希冲突
      >
      > 子串$P$长度$m$
      >
      > 文本$T$长度$n$
      >
      > 素数$q$——$q$取随机素数，满足$q * d < 2^{31} - 1$即可
      >
      > 子串“哈希值”计算：$p = d^{0} * P[m] + d^{1} * P[m-1] + d^{2} * P[m - 2] +...$
      >
      > > 注意，哈希值也有通过字符简单相加得到的，只不过这种非常容易产生`Hash`冲突，如`abc`、`bac`、`cba`的`Hash`一定相等，会产生无谓损失，使用这种乘法计算的后果就是数据太大，必须要取模运算。
      >
      > 文本“哈希值”计算：$t_{s + 1} = d * (t_{s} - d^(m-1) * T[s + 1]) + T[s + m + 1]$（相当于滑动窗口）

      ```java
      // 代码实现
      String subString = "text";
      String targetString = "texttexttexttext";
      public List<Integer> find(String subString, String targetString){
          int MOD = 524287; // 2^19 - 1，第七个梅森素数 int MOD = (int)Math.pow(2,19) - 1;
          int Character_Set_Size = 26; // 假定是小写字母字符集，共26个，作为基数
          int HashCode_SubString = 0; // 子串的哈希值
          int HashCode_Target = 0; // 文本的哈希值
          int h = (int)(Math.pow(Character_Set_Size, subString.length() - 1) % MOD); // h要提前计算
          for (int i = 0; i < subString.length(); i++){
              HashCode_SubString = (Character_Set_Size * HashCode_SubString + (subString.charAt(i) - 'a')) % MOD;
              HashCode_Target = (Character_Set_Size * HashCode_Target + (targetString.charAt(i) - 'a')) % MOD;
          }
          List<Integer> list = new ArrayList<>();
          for (int i = 0; i <= targetString.length() - subString.length(); i++){
              if (HashCode_Target == HashCode_SubString){
                  if (subString.equals(targetString.substring(i,i + subString.length()))){
                      list.add(i);
                  }
              }
              if (i < targetString.length() - subString.length()){
                  // 要注意越界，如果不加MOD会出现负数
                  HashCode_Target = ((Character_Set_Size * (HashCode_Target + MOD - ((targetString.charAt(i) - 'a') * h % MOD)) + 
                                     targetString.charAt(i + subString.length()) - 'a')) % MOD;
              }
          }
          return list;
      }
      ```

    - *有限自动机算法（不常见）：

      > 有限自动机算法先创建一个状态转移自动机，然后以主串作为输入逐次读入数据，不断进行状态转移

      ```mermaid
      graph LR
          A("初始化自动机")
          C("根据自动机进行状态转移")
          D("开始")
          E("结束")
          D-->A
          A-->C
          C-->E
      ```

      ```java
      public List<Integer> StringAutoMachine(String main, String pattern) {
          List<Integer> list = new ArrayList<>();
          HashMap<Integer, HashMap<Character, Integer>> jumpTable = new HashMap<>();
          int Set_size_of_character = 26;
          makeJumpTable(jumpTable,pattern, Set_size_of_character);
          Integer q = 0;
          for (int n = 0; n < main.length(); n++){
              HashMap<Character,Integer> map = jumpTable.get(q);
              int oldState = q;
              q = map.get(main.charAt(n));
              if (q == null){
                  return null;
              }
              if (q == pattern.length()){
                  list.add(n - pattern.length() + 1);
              }
          }
          return list;
      }
      
      public void makeJumpTable(HashMap<Integer, HashMap<Character, Integer>> jumpTable, String pattern, int Set_size_of_character) {
          for (int q = 0; q <= pattern.length(); q++) {
              for (int k = 0; k < Set_size_of_character; k++) {
                  char c = (char) ('a' + k);
                  String pq = pattern.substring(0, q) + c; // 在末尾添加一个字符c，表示当前接收到了一个新的字符c
                  int nextState = findSuffix(pq, pattern);
                  HashMap<Character, Integer> map = jumpTable.getOrDefault(q, new HashMap<>());
                  map.put(c, nextState);
                  jumpTable.put(q, map);
              }
          }
      }
      
      public int findSuffix(String pq, String pattern) {
          int suffixLen = 0;
          int k = 0;
          while (k < pq.length() && k < pattern.length()) {
              int i = 0;
              for (i = 0; i <= k; i++) {
                  if (pq.charAt(pq.length() - 1 - k + i) != pattern.charAt(i)) {
                      break;
                  }
              }
              if (i - 1 == k) {
                  suffixLen = k + 1;
              }
              k++;
          }
          return suffixLen;
      }
      ```

    - `KMP`算法：

      > KMP算法的核心就是`next`数组的计算。与双指针的思路类似。

      ```mermaid
      graph LR
          A("初始化next数组")
          C("从前向后匹配，遇到不匹配根据next数组移动j")
          D("开始")
          E("结束")
          D-->A
          A-->C
          C-->E
      ```

      ```java
      public List<Integer> KMP(String main, String pattern){
          List<Integer> answer = new ArrayList<>();
          int[] next = computeTemporaryArray(pattern);
          int i = 0;
          int j = 0;
          // 注意不是移动i，而是移动j
          while (i < main.length() && j < pattern.length()){
              if (pattern.charAt(j) == main.charAt(i)){
                  i++;
                  j++;
              } else {
                  if (j != 0){
                      j = next[j - 1];
                  } else {
                      i++;
                  }
              }
              if (j == pattern.length()){
                  answer.add(i - j); // 使用i - j计算开始位置
                  // 相当于重新开始KMP算法
                  i = i - j + 1;
                  j = 0;
              }
          }
          return answer;
      }
      // 计算next数组
      public int[] computeTemporaryArray(String pattern){
          int[] next = new int[pattern.length()];
          int i = 1;
          int j = 0;
          while (i < pattern.length()){
              if (pattern.charAt(i) == pattern.charAt(j)){
                  next[i] = j + 1;  // 注意是j + 1，而不是next[i - 1] + 1
                  i++;
                  j++;
              } else {
                  if (j != 0){
                      // 这个分支i不变
                      j = next[j - 1];
                  } else {
                      next[i] = 0;
                      i++;
                  }
              }
          }
          return next;
      }
      ```

    - `BM`算法：（最佳时间复杂度$O(n/m)$，相当于一直在跳跃前进；最差时间复杂度$O(m*n)$，与暴力解法一致，每次只能移动一步）

      > BM的实际运行要优于KMP算法。
      >
      > BM算法的核心是坏字符规则和好后缀规则。
      >
      > 坏字符规则：主串和模式串的匹配顺序是从后往前倒着匹配的，遇到不匹配的字符就标记为坏字符，在`index`数组中查找应当移动的步数。
      >
      > 好后缀规则：从后向前匹配，匹配的字符串标记为好后缀，根据`suffix`和`prefix`数组进行移动。
      >
      > 在两种规则中取最大的移动步数进行移动，直到遍历完成。

      ```mermaid
      graph LR
          A("初始化坏字符index数组")
          B("初始化好后缀suffix数组和prefix数组")
          C("在当前位置的基础上根据二者较大的值进行移动")
          D("开始")
          E("结束")
          D-->A
          D-->B
          A-->C
          B-->C
          C-->E
      ```

      ```java
      public static final int SIZE_OF_CHARACTER = 256; // 字符集的大小
      
      public List<Integer> Boyer_Moore(String main, String pattern) {
          List<Integer> list = new ArrayList<>();
          int[] index = new int[SIZE_OF_CHARACTER];
          int[] suffix = new int[pattern.length()];
          boolean[] prefix = new boolean[pattern.length()];
          // 两个预处理
          getSuffix_getPrefix(pattern, suffix, prefix);
          getLastIndexOfChar(pattern, index);
          int current_location = 0; // 代表模式串的头在主串的哪个位置
          while (current_location <= main.length() - pattern.length()) {
              // back_fit_location代表的是坏字符的位置，初始化的时候坏字符的位置肯定在最后一个，用一个for循环确定坏字符的位置
              int back_fit_location = pattern.length() - 1;
              for (; back_fit_location >= 0; back_fit_location--) {
                  if (main.charAt(current_location + back_fit_location) != pattern.charAt(back_fit_location)) {
                      break;
                  }
              }
              // back_fit_location == -1 就代表匹配成功
              if (back_fit_location < 0) {
                  list.add(current_location);
                  // 匹配成功只前进一步
                  current_location++;
              } else {
                  int bad_character_move_step = back_fit_location - index[main.charAt(back_fit_location + current_location)];
                  int good_suffix_move_step = 0;
                  if (back_fit_location < pattern.length() - 1) {
                      good_suffix_move_step = goodSuffixMove(back_fit_location, suffix, prefix);
                  }
                  current_location += Math.max(bad_character_move_step, good_suffix_move_step);
              }
          }
          return list;
      }
      
      // 预处理pattern字符串，将字符串中最后一个字母的位置存在index数组中
      public void getLastIndexOfChar(String pattern, int[] index) {
          int pattern_len = pattern.length();
          Arrays.fill(index, -1);
          for (int i = 0; i < pattern_len; i++) {
              index[pattern.charAt(i)] = i;
          }
      }
      
      // 好后缀规则计算移动比较费劲
      public int goodSuffixMove(int back_fit_location, int[] suffix, boolean[] prefix) {
          // 好后缀的长度
          int len_of_good_suffix = suffix.length - 1 - back_fit_location;
          // 如果该好后缀在模式串的前面出现过，那么移动距离就应当是back_fit_location - suffix[len_of_good_suffix] + 1
          if (suffix[len_of_good_suffix] != -1) return back_fit_location - suffix[len_of_good_suffix] + 1;
          for (int r = back_fit_location + 2; r < suffix.length - 1; r++) {
              if (prefix[suffix.length - r] == true) {
                  return r;
              }
          }
          return suffix.length;
      }
      
      // 预处理pattern字符串，统计有关好后缀的内容，将信息存储在suffix数组和prefix数组中
      public void getSuffix_getPrefix(String pattern, int[] suffix, boolean[] prefix) {
          Arrays.fill(suffix, -1);
          for (int i = 0; i < pattern.length() - 1; i++) {
              int fit_location = i;
              int count = 0;
              while (fit_location >= 0 && pattern.charAt(fit_location) == pattern.charAt(pattern.length() - 1 - count)) {
                  fit_location--;
                  count++;
                  suffix[count] = fit_location + 1; // fit_location + 1表示公共后缀子串在main[0,i]中的起始下标
                  // 长度为count的后缀在pattern前面重复的起始位点是 fit_location + 1
              }
              if (fit_location == -1) {
                  prefix[count] = true;
              }
          }
      }
      ```

    - `Sunday`算法：

      > Sunday算法与BM算法基本类似，非常不同地是，Sunday算法的字符串匹配是正向的，坏字符的定义是当前匹配区间的下一个。
      >
      > Sunday算法的实际运行要优于BM算法和KMP算法。

      ```mermaid
      graph LR
          A("初始化坏字符index数组")
          C("从前向后匹配，不匹配时查看当前区间的下一个字符")
          B("在模式串中寻找该字符并根据index数组移动")
          D("开始")
          E("结束")
          D-->A
          A-->C
          C-->B
          B-->E
      ```

      ```java
      public List<Integer> Sunday(String main, String pattern) {
          List<Integer> answer = new ArrayList<>();
          int[] index = new int[26]; // 默认小写字符集
          Arrays.fill(index, -1);
          for (int i = 0; i < pattern.length(); i++) {
              index[pattern.charAt(i) - 'a'] = i;
          }
          int currentLocation = 0;
          while (currentLocation <= main.length() - pattern.length()) {
              int fit_location = 0;
              for (; fit_location < pattern.length() && main.charAt(currentLocation + fit_location) == pattern.charAt(fit_location); fit_location++);
              // 说明匹配成功
              if (fit_location == pattern.length()){
                  answer.add(currentLocation);
                  currentLocation++;
              } else {
                  if (currentLocation + pattern.length() >= main.length()){
                      break;
                  }
                  // 匹配失败
                  char flag = main.charAt(currentLocation + pattern.length());
                  currentLocation += pattern.length() - index[flag - 'a'];
              }
          }
          return answer;
      }
      ```

    - `Horspool`算法

      > `Horspool`算法与BM算法类似，但是是BM算法的简化版。

      ```mermaid
      graph LR
          A("初始化坏index数组")
          C("从后向前匹配，不匹配时查看当前区间的z字符")
          B("在模式串中寻找该字符并根据index数组移动")
          D("开始")
          E("结束")
          D-->A
          A-->C
          C-->B
          B-->E
      ```



     ```java
     public List<Integer> Horspool(String main, String pattern){
         if (main.length() < pattern.length() || main.length() == 0 || pattern.length() == 0){
             return null;
         }
         List<Integer> list = new ArrayList<>();
         int[] index = new int[26];
         Arrays.fill(index, pattern.length());
         for (int i = 0; i < pattern.length() - 1; i++){
             index[pattern.charAt(i) - 'a'] = pattern.length() - i - 1;
         }
         int backFitLocation = pattern.length() - 1;
         while (backFitLocation <= main.length() - 1){
             int k = 0;
             while (k <= pattern.length() - 1 && pattern.charAt(pattern.length() - 1 - k) == main.charAt(backFitLocation - k)){
                 k++;
             }
             if (k == pattern.length()){
                 list.add(backFitLocation - pattern.length() + 1);
                 backFitLocation++;
             } else {
                 backFitLocation += index[main.charAt(backFitLocation) - 'a'];
             }
         }
         return list;
     }
     ```


7. 括号匹配问题





----

## 链表

1. 链表节点的内存分配不是在创建表时就一次性地完成，而是每添加一个节点分配一次内存。

    - 链表经常涉及的代码包括：创建节点、删除节点、插入节点，要熟练掌握。
    - 创建哨兵节点可以省去很多不必要的麻烦。

2. 双指针与链表：双指针思路与链表的结合可以解决非常多的链表问题；主要有两种形式，**快慢双指针**和**前后双指针**。

    - **前后双指针**：删除倒数第`k`个节点

      前指针先走`k + 1`步，当前指针到达末尾时，后指针正好移动到倒数第`k + 1`个节点。

    - **快慢双指针**：判断一个链表中是否包含环，以及环的入口，以及环的长度

      **判环**：快指针每次移动2个节点，慢指针每次移动1个节点，如果有环最后会在环中相遇

      **环的大小**：判断是否存在环后，如果存在环，那么两个指针一定在环中相遇，所以记录下这个环的位置，持续地`.next`，再次遇到这个环时走过的步数就是环的大小。

      **环的入口**：使用双指针一前一后，先移动环的大小个节点，相遇处就是入口节点；或者在判断是否有环以后，可以根据相遇节点作为前指针，后指针在`head`处，相遇处即为环的入口。

3. 双向链表和循环链表，是特殊一些的单向链表，需要注意的是在处理他们的前序节点和后续节点时，必须严格采用删除、新建的模板。

----

## 哈希表

1. 哈希表的基本知识

   哈希表中插入、删除或查找一个元素只需要`O(1)`的时间复杂度。

   在`java`中，哈希表有两个对应的类型，分别是`HashSet`和`HashMap`

    - `HashSet`的基本函数

   | 函数         | 函数功能                        |
      | ------------ | ------------------------------- |
   | `add()`      | 在`HashSet`中添加一个元素       |
   | `contains()` | 判断`HashSet`中是否包含一个元素 |
   | `remove()`   | 从`HashSet`中删除一个元素       |
   | `size()`     | 返回`HashSet`中的元素           |

    - `HashMap`的基本函数

   | 函数           | 函数功能                                                 |
      | -------------- | -------------------------------------------------------- |
   | `containsKey`  | 判断`HashMap`中是否包含某个键                            |
   | `get`          | 如果键存在，返回对应的值，否则返回`null`                 |
   | `getOrDefault` | 如果键存在，返回对应的值，否则返回输入的默认值           |
   | `put`          | 如果键不存在，则添加一组键到值的映射，否则修改键对应的值 |
   | `putIfAbsent`  | 当键不存在时添加一组键到值得映射                         |
   | `remove`       | 删除某个键                                               |
   | `replace`      | 修改某个键对应的值                                       |
   | `size`         | 返回`HashMap`中键到值的映射数目                          |

2. 哈希表的底层设计

   ```java
   ！需要进一步更优秀的资料
   ```

   由于哈希表的增删改查都只需要`O(1)`的时间复杂度，因此可以用来设计某些更高级的”数据结构“。

3. `HashMap`具有很多优秀的特质，在算法题中会经常出现。

---

## 栈

1. 栈的基础知识

   `java`中栈的基本操作包括如下三种，他们的时间复杂度都是`O(1)`

   | 函数   | 函数功能                         |
      | ------ | -------------------------------- |
   | `push` | 元素入栈                         |
   | `pop`  | 位于栈顶的元素出栈，并返回改元素 |
   | `peek` | 返回位于栈顶的元素，该元素不出栈 |

2. 根据栈的主要特点——先进后出，在解决多括号匹配问题、后缀表达式（逆波兰式）中，栈这种数据结构非常有用，最有用的部分大概还是在深度优先遍历的时候使用栈。

3. 单调栈算法

   单调栈主要可以解决”需要动态查找两端最近的较大值“之类的问题，比如接雨水等习题。

   单调栈的伪代码：

   ```java
   Stack<Integer> stack = new Stack<>();
   for (int i = 0; i < nums.length; i++){
   	if (stack.isEmpty() || nums[stack.peek()] < nums[i]){ // 比较的是nums[stack.peek()]和nums[i]
   		stack.push(i); // 入栈的是下标
   	} else {
   		while (!stack.isEmpty() && nums[stack.peek()] > nums[i]){
               int log = stack.pop();
               // 相关逻辑
           }
           stack.pop(i); // 下标入栈
   	}
   }
   ```

---

## 队列

1. 队列的基本知识

   `java`中`Queue`的基本操作

   | 操作             | 抛异常的  | 不抛异常的 |
      | ---------------- | --------- | ---------- |
   | 插入元素         | `add`     | `offer`    |
   | 删除元素         | `remove`  | `poll`     |
   | 返回最前面的元素 | `element` | `peek`     |

   注意，`java`写代码时想使用队列，要用下面的代码，使用`LinkedList<>`。

   ```java
   Queue<Integer> queue = new LinkedList<>();
   ```

2. 队列的特点主要是先进先出，因此队列在解决滑动窗口问题、广度优先搜索的时候，具有非常广泛的用途。

3. 双端队列`Deque`【`double ended queue`】

   ```java
   // 双端队列的实现A，基于数组的线性双端队列，通常作为栈或队列使用，但是栈的效率不如LinkedList
   Deque<Integer> deque = new ArrayDeque<>(); // 队列写法
   // 双端队列的实现B，基于链表的链式双端队列，通常作为栈或队列使用，但是队列的效率不如ArrayDeque
   Deque<Integer> deque = new LisnkedList<>(); // 栈写法
   ```

   | 复杂操作          | 含义                                                         |
      | ----------------- | ------------------------------------------------------------ |
   | `addFirst(<E> e)` | 从双端队列的头部加入元素                                     |
   | `addLast(<E> e)`  | 从双端队列的尾部加入元素                                     |
   | `contains(<E> e)` | 双端队列是否包含元素`e`                                      |
   | `getFirst()`      | 检索双端队列的第一个元素                                     |
   | `getLast()`       | 检索双端队列的尾部元素                                       |
   | `offerFirst()`    | 在此双端队列的头部插入指定的元素                             |
   | `offerLast()`     | 在此双端队列的尾部插入指定的元素                             |
   | `peekFirst()`     | 检索但不删除此双端队列的头部元素，如果双端队列为空，返回`null` |
   | `peekLast()`      | 检索但不删除此双端队列的尾部元素，如果双端队列为空，返回`null` |
   | `pollFirst()`     | 检索并删除双端队列的第一个元素，如果双端队列为空，返回`null` |
   | `pollLast()`      | 检索并删除双端队列的尾部元素，如果双端队列为空，返回`null`   |
   | `pop()`           | 弹出尾部元素，等价于`removeFirst()`，双端队列为空会报异常    |
   | `push()`          | 向队头加入元素，等价于`addFirst()`，双端队列为空会报异常     |
   | `removeFirst()`   | 返回并移除队头元素，双端队列为空会报异常                     |
   | `removeLast()`    | 返回并移除队尾元素，双端队列为空会报异常                     |
   | `size()`          | 返回双端队列大小                                             |








# 算法笔记《卷Ⅱ》

----

## 树

1. 树的基本知识

    - 一个非空二叉树只有一个父节点
    - 二叉树的叶节点没有子节点
    - 二叉树具有典型的递归性质，用递归的方法可以解决很多问题

   ```java
   // 二叉树的基本代码
   public class TreeNode{
       int val;
       TreeNode left;
       TreeNode right;
       // 构造函数
       TreeNode(int x) {
           val = x;
       }
   }
   ```

2. 二叉树的遍历

    - 深度优先遍历

        1. 中序遍历

           中序遍历是先遍历左子树，再添加根节点，最后遍历右子树；主要有两种写法，分别是递归版本和循环版本。

           ```java
           // 递归版本
           public List<Integet> inorderTraversal(TreeNode root){
               List<Integer> nodes = new ArrayList<>();
               dfs(root, nodes);
               return nodes;
           }
           // 辅助函数dfs
           private void dfs(TreeNode root, List<Integer> nodes){
               if (root != null){
                   dfs(root.left, nodes);
                   nodes.add(root.val);
                   dfs(root.right, nodes);
               }
           }
           ```

           由于递归的时间复杂度往往很高，所以有必要掌握下面的循环版本：

           ```java
           // 循环版本
           public List<Integer> inorderTraversal(TreeNode root){
               List<Integer> nodes = new ArrayList<>();
               Stack<TreeNode> stack = new Stack<>();
               TreeNode cur = root;
               while (cur != null || !stack.isEmpty()){
                   while (cur!=null) {
                       stack.push(cur);
                       cur = cur.left;
                   }
                   TreeNode log = stack.pop();
                   nodes.add(log.val);
                   cur = log.right;
               }
           }
           ```

        2. 前序遍历

           前序遍历是先遍历根节点，再遍历左子树，最后遍历右子树，模板照比中序遍历大同小异，也是呈现如下的两种模式。

           ```java
           // 递归版本
           public List<Integet> preorderTraversal(TreeNode root){
               List<Integer> list = new ArrayList<>();
               dfs(root, list);
               return list;    
           }
           
           private void dfs(TreeNode root, List<Integer> list){
               if (root == null){
                   return;
               }
               list.add(root.val);
               dfs(root.left, list);
               dfs(root.rigth, list);
           }
           ```

           同样地，递归版本容易超时，所以也提供如下的递归版本

           ```java
           // 循环版本
           public List<Integer> preorderTreversal(TreeNode root){
               List<Integer> list = new ArrayList<>();
               Stack<TreeNode> stack = new Stack<>();
               TreeNode cur = root;
               wihle (cur != null || !stack.isEmpty()){
                   while (cur != null){
                       list.add(cur.val);
                       Stack.push(cur);
                       cur = cur.left;
                   }
                   TreeNode log = stack.pop();
                   cur = log.right;        
               }
               return list;
           }
           ```

        3. 后序遍历

           后续遍历是先遍历左子树，再遍历右子树，最后访问根节点，后序遍历的递归代码大同小异：

           ```java
           // 递归版本
           public List<Integer> postorderTraversal(TreeNode root){
               List<Integer> nodes = new ArrayList<>();
               dfs(root, node);
               return nodes;
           }
           // 辅助函数
           private void dfs(TreeNode root, List<Integer> list){
               if (root != null){
                   dfs(root.left, list);
                   dfs(root.right, list);
                   list.add(root.val);
               }
           }
           ```

           后续遍历的循环代码略显笨重，要重点记忆

           ```java
           // 循环版本
           public List<Integer> postorderTraversal(TreeNode root){
               List<Integer> result = new ArrayList<>();
               Stack<TreeNode> stack = new Stack<>();
               TreeNode cur = root;
               TreeNode prev = null;
               while (cur != null || !stack.isEmpty()){
                   while(cur != null){
                       stack.push(cur);
                       cur = cur.left;
                   }
                   TreeNode log = stack.peek();
                   if (log.right != null && log.right != prev){
                       cur = log.right;
                   } else {
                       stack.pop();
                       result.add(log.val);
                       prev = log;
                       cur = null;
                   }
               }
               return result;
           }
           ```

    - 广度优先遍历

      广度优先遍历使用队列，与深度优先遍历使用栈是不同的；在解决具体问题的时候可以使用两个队列交互入队出队。

      ```java
      public List<Integer> bfs(TreeNode root){
          Queue<TreeNode> queue = new LinkedList<>();
          queue.offer(root);
          List<Integer> list = new ArrayList<>();
          while(!queue.isEmpty()){
              TreeNode log = queue.pop();
              list.add(list.val);
              if (log.left != null){
                  queue.offer(log.left);
              }
              if (log.right != null){
                  queue.offer(log.right);
              }
          }
          return list;
      }
      ```

3. 二叉搜索树（**BST**，`Binary Sort Tree`）

    - 二叉树特点介绍：二叉搜索树是能够高效地进行如下操作的数据结构：

      插入一个数值

      查询是否包含某个数值

      删除某个数值

      二叉搜索树的每一项操作时间复杂度都是$O(log n)$

    - 二叉搜索树的基本特点：

      > 若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。
      >
      > 若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。
      >
      > 任意结点的左、右子树也分别为二叉搜索树。

    - 二叉搜索树的实现

      >



4. 平衡二叉搜索树（**AVL**）

    - 定义：

      > 左子树与右子树高度之差的绝对值不超过1
      >
      > 树的每个左子树和右子树都是AVL树
      >
      > 每一个节点都有一个平衡因子（balance factor），任一节点的平衡因子是-1、0、1（每一个节点的平衡因子 = 右子树高度 - 左子树高度)

    - 平衡二叉搜索树的节点插入



5. 红黑树

    - 【面试题】红黑树的红色节点和黑色节点的意义

      红色节点：红节点其实就是2-3树中3节点的表示

      黑色节点：黑节点其实就是2-3树中2节点的表示

    - 红黑树的基本性质

   一棵红黑树是满足下面红黑性质的二叉搜索树：

   > 性质一：每个节点是红色的或是黑色的；
   >
   > 性质二：根节点是黑色的；
   >
   > 性质三：每个叶子节点（`NULL`）是黑色的；
   >
   > 性质四：如果一个节点是红色的，则它的两个子节点都是黑色的；
   >
   > 性质五：对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。

   红黑树的每个节点包含5个属性，分别是：`color`、`key`、`left`、`right`、`p`。

   从某个节点`x`出发到达一个叶节点的任意一条简单路径上的黑色节点个数称为该节点的黑高，记作$bh(x)$。根据性质`5`，黑高的概念是明确的，因为从该节点出发的所有下降到其叶节点的简单路径的黑色节点个数都相同。于是定义红黑树的黑高为其根节点的黑高。

    - 红黑树为什么是一种比较优秀的搜索树？

   引理：一棵有`n`个内部节点的红黑树，高度至多为$2*log_2^{(n+1)}$。

   证明：首先证明以任意节点`x`为根的子树中至少包含$2^{bh(x)} - 1$个内部节点。如果节点`x`的高度为0，则`x`必为叶节点`NULL`，且以`x`为根节点的子树至少包含$2^{bh(x)} - 1 = 0$个内部节点。接下来考虑一个高度为正值且有两个子节点的内部节点`x`，每个子节点有黑高$bh(x)$或$bh(x) - 1$，这主要取决于自身的颜色是红还是黑。由于`x`子节点的高度比`x`本身的高度要低，可以利用归纳假设得出每个子节点至少有$2^{bh(x) - 1} - 1$个内部结点的结论。于是，以`x`为根的子树至少包含$(2^{bh(x) - 1} - 1) + (2^{bh(x) - 1} - 1) + 1 = 2^{bh(x)} - 1$个内部结点，因此得证。

   为证明引理的内容，设`h`为树的高度。根据性质4，从根节点到叶节点的任何一个简单路径上都至少有一半的节点为黑色，所以，根的黑高至少为$h/2$；于是有$n >= 2^{h/2} - 1$，整理得到$lg(n+1) >= h / 2$，或者$h <= 2 * lg(n + 1)$。

   这就说明红黑树的高度基本维持在$log$级别，因此是一种比较优秀的搜索树。

    - 旋转操作

   二叉搜索树上的旋转操作保证了树在变化前后的搜索树性质不受影响。二叉搜索树的旋转操作分为两种，分别是左旋和右旋：

   ![image-20220401114919376](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220401114919376.png)

   ```java
   // 左旋操作伪代码
   y = x.right;        
   x.right = y.left;   // 图中的β
   if (y.left != null){
       y.left.p = x;   // 更改图中β的父节点
   }
   y.p = x.p;          // 更改y
   if (x.p == null){
       T.root = y;
   }
   else if (x == x.p.left){
       x.p.left = y;
   }
   else {
       x.p.right = y;
   }
   y.left = x;
   x.p = y;
   ```

    - 插入和删除操作

   插入和删除操作的时间复杂度均在$log_2^{n}$级别。

   具体的插入和删除操作主要依照分类讨论的思想，按照不同情况对红黑树进行简单调整以保证红黑树在进行完插入和删除操作后依然是红黑树。具体细节太过繁杂。

6.

7. `Java`中`TreeSet`和`TreeMap`的使用

   > 如果题目的数据集合是动态的，并且随着集合的变化需要根据数据大小动态地查找，那么可能会用`TreeSet`和`TreeMap`。

   `Java`根据红黑树这种平衡的二叉搜索树实现了`TreeSet`和`TreeMap`两种数据结构，具体实现需要看源代码

   ```java
   // java的TreeSet源码
   // java的TreeMap源码
   ```

    - `TreeSet`的常用函数

      | 序号 | 函数      | 函数功能                                         |
           | ---- | --------- | ------------------------------------------------ |
      | 1    | `ceiling` | 返回键大于或等于给定值的最小键；没有就返回`null` |
      | 2    | `floor`   | 返回键小于或等于给定值的最小键；没有就返回`null` |
      | 3    | `higher`  | 返回键大于给定值的最小键；没有就返回`null`       |
      | 4    | `lower`   | 返回键小于给定值的最小键；没有就返回`null`       |

    - `TreeMap`的常用函数

      | 序号 | 函数                        | 函数功能                                              |
           | ---- | --------------------------- | ----------------------------------------------------- |
      | 1    | `ceilingEntry / ceilingKey` | 返回键大于或等于给定值的最小映射/键；没有则返回`null` |
      | 2    | `floorEntry / floorKey`     | 返回键小于或等于给定值的最小映射/键；没有则返回`null` |
      | 3    | `higherEntry / higherKey`   | 返回键大于给定值的最小映射/键；没有则返回`null`       |
      | 4    | `lowerEntry / lowerKey`     | 返回键小于给定值的最小映射/键；没有则返回`null`       |

   `TreeMap`和`TreeSet`也都含有`contains`方法，但这个方法的时间复杂度在$O(logn)$级别，尽量不要直接使用；如果复杂度不允许，可以在创建`TreeMap`和`TreeSet`的同时维护一个`Set`，必要时直接使用`Set`中的`contains`方法。







----

## 堆

1. 堆（Heap）的基本知识

    - 堆的定义：堆是一种特殊的数据结构，堆通常使用完全二叉树实现；而完全二叉树是可以使用数组实现的。

    - 堆与`AVL`及红黑树的区别：堆是建立在二叉树上的；而`AVL`及红黑树建立在二叉搜索树上。

    - 堆的分类：堆从类型上主要分为最大堆和最小堆，区别在于顶端元素的值是大于其他元素还是小于其他元素。

    - ==堆中的元素可以重复==。

    - 堆的实现

      ```java
      // 手动实现堆
      // 手动实现就可以借助数组实现
      public class PriorityQueue<E extends Comparable>{
          // 全局变量ArrayList
          public ArrayList<E> list;
          // 构造方法
          public PriorityQueue() {
              list = new ArrayList<>();
          }
          // 构造方法
          public PriorityQueue(int capacity) {
              list = new ArrayList<>(capacity);
          }
          // 构造方法
          public PriorityQueue(E[] objects){
              for (E x : objects){
                  list.add(x);
              }
          }
          // 添加元素
          public void add(E newObject){
              list.add(newObject);
              int currentIndex = list.size() - 1;
              while(currentIndex > 0){
                  int parentIndex = (currentIndex - 1) >> 1;
                  if (list.get(currentIndex).compareTo(list.get(parentIndex)) > 0){
                      E temp = list.get(currentIndex);
                      list.set(currentIndex,list.get(parentIndex));
                      list.set(parentIndex,temp);
                  } else {
                      break;
                  }
                  currentIndex = parentIndex;
              }
          }
          // 移除元素
          public E remove(){
              if (list.size() == 0){
                  return null;
              }
              E removeObject = list.get(0);
              list.set(0, list.get(list.size() - 1));
              list.remove(list.size() - 1);
              int currentIndex = 0;
              while (currentIndex < list.size()){
                  int leftChildIndex = 2 * currentIndex + 1;
                  int rightChildIndex = 2 * currentIndex + 2;
                  if (leftChildIndex >= list.size()){
                      break;
                  }
                  // 先将maxIndex设置为不超过范围的leftChildIndex
                  int maxIndex = leftChildIndex;
                  if (rightChildIndex < list.size()){
                      maxIndex = list.get(leftChildIndex).compareTo(list.get(rightChildIndex)) < 0 ? rightChildIndex : leftChildIndex;
                  }
                  if (list.get(currentIndex).compareTo(list.get(maxIndex)) < 0){
                      E temp = list.get(maxIndex);
                      list.set(maxIndex,list.get(currentIndex));
                      list.set(currentIndex,temp);
                      currentIndex = maxIndex;
                  } else {
                      break;
                  }
              }
              return removeObject;
          }
          // 返回堆顶元素
          public E peek(){
              if (list.size() == 0){
                  return null;
              } else {
                  return list.get(0);
              }
          }
          // 获取大小
          public int getSize(){
              return list.size();
          }
      }
      ```

    - `Java`中通过`PriorityQueue`（优先队列）实现了堆，默认情况下是最小堆，如果想使用最大堆的话要借助`Comparator`接口

      创建小顶堆：`PriorityQueue<Integer> heap = new PriorityQueue<>();`（默认情况即最小堆）

      创建大顶堆：`PriorityQueue<Integer> heap = new PriorityQueue<>((o1,o2) -> o2 - o1);`

      `PriorityQueue`常用的函数列表：

      | 操作         | 抛异常版本 | 不抛异常版本 |
           | ------------ | ---------- | ------------ |
      | 插入新的元素 | `add`      | `offer`      |
      | 删除堆顶元素 | `remove`   | `poll`       |
      | 返回堆顶元素 | `element`  | `peek`       |

    - 堆的时间复杂度

      使用堆求最大值或最小值：$O(1)$

      添加或删除元素：$O(logn)$

2. 堆能够解决的典型问题：

   包括求出现频率最高的`k`个数字、避免排序的第`k`大数字、和最小的`k`个数对等等，基本上题干中有第`k`个满足什么条件的元素，基本都可以借助堆实现，只要让堆顶弹`k`次就能够得到我们想要的答案。



---

## 前缀树

1. 前缀树（**Trie**）的基本知识

   前缀树又叫字典树，它用一个“树状”的树结构存储一个字典中的所有单词，前缀树的每个节点是一个数组，通常数组的长度是26，用来表示26个小写英文字母，如果两个单词的前缀是一样的，那么这两个单词在前缀树中对应的路径的前面的节点是重叠的；前缀树的每个节点中需要包含两个内容，第一个是26个节点组成的数组，另外是一个标记（可以是`boolean`，也可以是`int`），用来标识字符串的末尾。

   ```java
   // 前缀树的实现
   class Trie{
       static class TrieNode{
           Trie[] children;
           boolean isword;
           // 构造方法
           public TrieNode(){
               children = new TrieNode[26];
           }
       }
   }
   ```

2. 前缀树可以用来解决的问题，不止限于字符串，对于数字可以用`0`和`1`表示，其实也可以使用类似的想法。



----

## 线段树

| 条件                   | 方法                         |
| ---------------------- | ---------------------------- |
| 数组不变，区间查询     | **前缀和**、树状数组、线段树 |
| 数组单点修改，区间查询 | **树状数组**、线段树         |
| 数组区间修改，单点查询 | **差分**、线段树             |
| 数组区间修改，区间查询 | **线段树**                   |

1. 前缀和

   一维前缀和：依次累加，欲求出某一区间的和只需要相减。

   ```java
   // 一维前缀和
   int[] nums;
   int[] sum = new int[nums.length + 1];
   for (int i = 0; i < nums.length; i++){
       sum[i + 1] = sum[i] + nums[i];
   }
   // 某一区间内的数字和
   int sum_a_b = sum[b + 1] - sum[a];
   ```

   二位前缀和：以左上角为起点，其余每个点内的数值都是以左上角和当前点所构成的矩形中全部的元素和。

   ```java
   // 二维前缀和
   int[][] nums;
   int[][] sum = new int[nums.length + 1][nums[0].length + 1];
   for (int i = 0; i < nums.length; i++){
       for (int j = 0; j < nums[0].length; j++){
           sum[i+1][j+1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + nums[i][j];
       }
   }
   // 求某一特定区域内的数字和
   int sum_x1_y1_x2_y2 = sum[x2 + 1][y2 + 1] - sum[x1][y1];
   ```

2. 树状数组

    - 复杂度：树状数组是一个查询和修改复杂度都是$log(n)$的数据结构，主要用于数组的单点修改和区间求和。
    - 基本样式：

   ![image-20220401153742733](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220401153742733.png)

   ​	灰色数组代表原来的数组，红色结构代表树状数组，每个树状数组的节点都代表所有与其有直接连线的元素之和。

   ​	简单来说：

   > `tree_array[1] = nums[1]`
   >
   > `tree_array[2] = nums[1] + nums[2] = nums[1] + tree_array[1]`
   >
   > `tree_array[3] = nums[3]`
   >
   > `tree_array[4] = nums[1] + nums[2] + nums[3] + nums[4] = tree_array[2] + nums[3] + nums[4]`
   >
   > ...

    - 创建树状数组的过程（包括更新）

      首先要考虑到，原数组中的元素`nums[i]`究竟会在树状数组中哪些元素中出现？需要更新的树状数组元素首先是`tree_array[i]`本身，其次是在上图中依次相连的节点，比如更新原数组中的元素$6$——`nums[i] = 6`，需要一次向上找到红色节点6，然后是8，这个更新过程可以用下面的`update()`函数本身替代。通过这种沿着边依次向上查找的方案，就能够更新全部涉及到6号的元素。

    - 区间求和的过程

      ⚠：目前尚未找到可以直接从0开始的方法，目前采用0位搁置，从1位开始的算法。

      区间求和的过程相当于更新过程的逆过程，借助下面的图片体会一下：

      ![image-20220401191708956](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220401191708956.png)

      如果想求从1-7号元素的和，我们需要按照次序分别找到上述的4号节点和6号节点和7号节点，翻译过来就是使用$2^k$表示$7$。沿途的所有数字求和即可，在下面的代码中体现为`getSum()`函数。

   ```java
   // 树状数组模板
   int[] nums; // [0, nums.length - 1]是真实数据
   // 树状数组建立
   int[] tree_array = new int[nums.length + 1]; // 转化到树状数组，存储信息的节点为[1, nums.length]
   // lowbit函数，用于求x的二进制表示中最低位的1
   public int lowbit(x){
       return x & (-x);
   }
   // add函数，用于创建树状数组和更新调用，所有的index都是对树状数组成立的index
   public void add(int index, int val){
       for (int i = index; i <= nums.length; i += lowBit(i)){
           tree_array[i] += val;
       }
   }
   // update函数，用于动态修改数组
   public void update(int index, int val){
       add(index, val - nums[index - 1]);
       nums[index - 1] = val;
   }
   // query函数，用于动态查询
   public int query(int location){
       int ans = 0;
       for (int i = loaction; i > 0; i -= lowBit(i)){
           ans += tree_array[i];
       }
       return ans;
   }
   // 初始化数组
   for (int i = 0; i < n; i++){
       add(i + 1, nums[i]);
   }
   ```



- 二维树状数组



3. 差分数组

   差分数组通过计算数组中相邻元素的差值作为辅助数组，帮助我们在区间修改和单点查询中起到很大的作用。

   思路比较简单，直接上模板。

   ```java
   // 原数组
   int[] nums;
   // 创建差分数组
   int[] diff = new int[nums.length + 1];
   diff[0] = nums[0] - 0;
   for (int i = 1; i < nums.length; i++){
       diff[i] = nums[i] - nums[i - 1];
   }
   diff[nums.length] = 0 - nums[nums.length - 1];
   // 更新区间，为区间[left, right]中所有的元素都加上val，left和right是数组中的下标，也就是0、1、2、3...
   public void update(int left, int right, int val){
       diff[left] += val;
       diff[right + 1] -= val;
   }
   // 单点查询
   int[] ans = new int[nums.length];
   ans[0] = 0 + diff[0];
   for (int i = 1; i < nums.length; i++){
       ans[i] = ans[i - 1] + diff[i];
   }
   ```

   ⚠注意事项

   关于边界控制，见下图

   ![image-20220402144321727](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220402144321727.png)

   更新策略：$dif[start] = dif[start] + val$、$dif[end + 1] = dif[end + 1] - val$

4. 线段树

    - 复杂度：对编号连续的一些点进行修改或者统计操作，修改和操作的复杂度都是$O(log_2^n)$。

    - 基本要求：使用线段树进行统计的必须符合区间加法，否则不可能通过分成的子区间来得到$[L,R]$的统计结果。

      区间加法性质：仅当对于区间$[L,R]$的问题的答案可以由$[L,M]$和$[M+1,R]$的答案和并得到。

      | 符合区间加法的例子                                 | 不符合区间加法的例子   |
           | -------------------------------------------------- | ---------------------- |
      | 数字之和——总数字之和=左区间数字之和+右区间数字之和 | 01序列的最长连续0      |
      | 最大公因数——总GCD = GCD（左区间GCD，右区间GCD）    | 区间的众数             |
      | 最大值——最大值 = Max（左区间最大值，右区间最大值） | 区间的最长不下降子序列 |

    - 关于用数组模拟树的操作

      树的左子节点可以表示为：$index << 1$

      树的右子节点可以表示为：$index << 1 | 1$

      ![image-20220403132444623](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220403132444623.png)

    - 线段树基本原理说明

        - 数据结构层面



     - 区间更新：

     线段树比树状数组高级的一点就在于可以实现区间修改，而树状数组仅支持点修改，因此有必要引入惰性标记概念。

     懒惰标记：本区间已经被更新了，但是子区间却没有被更新过；具体来说分为两个标记：相对标记和绝对标记。

     > 相对标记：指的是可以共存的标记，且打标记的顺序与答案无关，即标记可以叠加。例如为区间所有元素加上`a`这类操作。
     >
     > 绝对标记：指不可以共存的标记，每一次都要把标记下传，再给当前节点打上新的标记。例如将某个区间内的元素变为`a`这种操作，标记必须下推。

     - 线段树的关键函数说明（以求和问题为案例）

       > 线段树关键`6`函数
       >
       > 极简版本：`pushUp()`、`build()`
       >
       > 查询：`query()`
       >
       > 需要点更新：`update(5 args)`
       >
       > 区间更新套件：`pushDown()`、`update(6 args)`

       ```java
       // pushUp(), 由于底层新元素的变动，必须更改所有包含该节点的区段和
       public void pushUp(int index)
       // pushDown(), 配合懒惰标记使用, 由于逐个更新区间中所有的元素太耗时，使用pushDown()的递归来替代逐个更新的过程
       public void pushDown(int index, int left_node, int right_node)
       // 构建初始的线段树，只需要使用到pushUp()函数
       public void bulid(int left, int right, int index)
       // 点更新操作，先从[1,n]区间向下递归找到点[m,m]，再利用pushUp()由该点[m,m]向上合并更新沿途的所有区段，最终回到顶层区段[1,n]
       public void update(int left, int right, int location, int val, int index)
       // 区间更新操作，区间更新操作是先向下使用尽可能少的区段覆盖掉当前待更新的区段[L,R]，为上述区段集合打上懒惰标记来模拟该区域已经被更新
       public void update(int left, int right, int L, int R, int val, int index)
       // 区间查询操作，区间查询与区间更新类似，需要注意的是沿途的所有懒惰标记此时必须利用pushDown()函数更新，也就是在函数入口处直接设置pushDown()
       public int query(int left, int right, int L, int R, int index)
       ```

- 第一层——线段树实现**【点更新模板】**【与树状数组同功能】【数组实现线段树】【递归函数】

  ```java
  // 创建基本线段树，使用数组实现
  int[] nums;                             // 原数组
  int[] sum = new int[nums.length << 2];  // 线段树核心数组，一般开4倍n的大小
  // pushUp函数，index是当前节点在sum中的位置
  public void pushUp(int index){
      sum[index] = sum[index << 1] + sum[index << 1 | 1];
  }
  // Bulid函数建立线段树
  public void bulid(int left, int right, int index){
      if (left == right){
          sum[index] = nums[left];
          return;
      }
      int mid = (left + right) >> 1;
      build(left, mid, index << 1);
      build(mid + 1, right, index << 1 | 1);
      pushUp(index);
  }
  // 点修改 nums[location] += val (五参数update)
  public void update(int left, int right, int location, int val, int index){
      if (left == right){
          sum[index] += val;
          return;
      }
      int mid = (left + right) >> 1;
      if (location <= mid){
          update(left, mid, location, val, index << 1);
      } else {
          update(mid + 1, right, location, val, index << 1 | 1);
      }
      pushUp(index);
  }
  // 区间查询，区间查询A[L,R]
  public int query(int left, int right, int L, int R, int index){
      if (L <= left && right <= R){
          return sum[index];
      }
      int mid = (left + right) >> 1;
      int ans = 0;
      if (L <= mid){
          ans += query(left, mid, L, R, index << 1);
      } 
      if (R > mid){
          ans += Query(mid + 1, right, L, R, index << 1 | 1);
      }
      return ans;
  }
  ```

- 第二层——线段树实现**【区间更新模板】**【相对标记】【数组实现线段树】【递归函数】

  ```java
  // 创建基本线段树，使用数组实现
  int[] nums;                             // 原数组
  int[] sum = new int[nums.length << 2];  // 线段树核心数组
  int[] flag = new int[nums.length << 2]; // 懒惰标记数组，与核心数组一样，一般开4倍n的大小
  // pushUp函数，index是当前节点在sum中的位置
  public void pushUp(int index){
      sum[index] = sum[index << 1] + sum[index << 1 | 1];
  }
  // pushDown函数，index是当前节点在sum中的位置，left_node是左边节点的数量，right_node是右边节点的数量
  public void pushDown(int index, int left_node, int right_node){
      if (flag[index] != 0){
          flag[index << 1] += flag[index];
          flag[index << 1 | 1] += flag[index];
          sum[index << 1] += flag[index] * left_node;
          sum[index << 1 | 1] += flag[index] * right_node;
          flag[index] = 0;
      }
  }
  // Bulid函数建立线段树
  public void bulid(int left, int right, int index){
      if (left == right){
          sum[index] = nums[left];
          return;
      }
      int mid = (left + right) >> 1;
      build(left, mid, index << 1);
      build(mid + 1, right, index << 1 | 1);
      pushUp(index);
  }
  // 区间修改 nums[L,R] += val (六参数update)
  public void update(int left, int right, int L, int R, int val, int index){
      if (L <= left && right <= R){
          sum[index] += val * (right - left + 1); // 区间内所有元素加val，相当于sum加val * (right - left + 1)
          flag[index] += val;                     // 表示该区间的sum正确，但是具体值仍需要根据flag调整
          return;
      }
      int mid = (left + right) >> 1;
      pushDown(index, mid - left + 1, right - mid);
      if (L <= mid){
          update(left, mid, L, R, val, index << 1);
      }
      if (R > mid){
          update(mid + 1, right, L, R, val, index << 1 | 1);
      }
      pushUp(index);
  }
  // 区间查询，区间查询A[L,R]
  public int query(int left, int right, int L, int R, int index){
      if (L <= left && right <= R){
          return sum[index];
      }
      int mid = (left + right) >> 1;
      pushDown(index, mid - left + 1, right - mid);
      int ans = 0;
      if (L <= mid){
          ans += query(left, mid, L, R, index << 1);
      } 
      if (R > mid){
          ans += Query(mid + 1, right, L, R, index << 1 | 1);
      }
      return ans;
  }
  ```

- 函数调用

  | 函数                                                         | 实际写法                                       |
       | ------------------------------------------------------------ | ---------------------------------------------- |
  | `pushUp(int index)`                                          | 一般是从`1`开始                                |
  | `build(int left, int right, int index)`                      | `build(1, n, 1)`                               |
  | `update(int left, int right, int location, int val, int index)` | `update(1, n, INPUT_LOC, INPUT_VAL, 1)`        |
  | `query(int left, int right, int L, int R, int index)`        | `query(1, n, INPUT_L, INPUT_R, 1)`             |
  | `update(int left, int right, int L, int R, int val, int index)` | `update(1, n, INPUT_L, INPUT_R, INPUT_VAL, 1)` |

  不难发现，前两层级的线段树使用可以简单概括为如下步骤

  > 前两层线段树的使用方式
  >
  > 1. `pushUp`函数实现
  > 2. 依赖`pushUp`的`build`函数实现，此时已经创建了基本的线段树
  > 3. 依赖`pushUp`的`update`函数实现
  > 4. 根据修改规则使用`update`动态修改
  > 5. 依赖递归的`query`函数实现
  > 6. 根据要求使用`query`进行动态查询

- 非递归实现原理

    - 从旧线段树出发，区分三个下标：

      原数组下标：需要维护统计信息的数组的下标，这里都默认下标从1开始。

      线段树下标：加入线段树中某个位置的下标。

      存储下标：该元素所在叶节点的编号，即实际存储的位置。

  ![image-20220403214659106](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220403214659106.png)

    - 改进的非递归线段树和点修改下的区间查询

      查询想法是：用蓝色的两条线将线段树查询区间框住，这就间接导致我们必须引入图中两个橘色的节点来保证框住的可行性。

      对左边的蓝色线而言，若该节点是其父节点的左子节点，那么就要将该节点的右子节点计入结果；

      对右边的蓝色线而言，若该节点是其父节点的右子节点，那么就要将该节点的左子节点计入结果；

      简单来说，就是左侧的右边和右侧的左边包围的才是查询区间。

      将沿途的红色对勾节点对应的数值加和，就得到了查询答案。

  ![image-20220404124826650](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220404124826650.png)

    - 改进的非递归线段树下标对应：

      根据非递归线段树的要求，我们不能在$[1,n]$的范围内存元素，而是要在$[2,n+1]$的范围内存元素，保证所有对应真实数据的叶子节点两边必须有其他元素，总共需要开辟$n + 2$大小的空间。现在我们有：
      $$
      原数组下标 + 1 = 线段树下标 \newline
      线段树下标 + N - 1 = 存储下标 \newline
      原数组下标 + N = 存储下标
      $$
      $N$如何确定？$N$的含义是这棵树可以存放$N$个元素，也就是说，$N$是大于等于$n + 2$的$2$的某个次方，这是可以计算出来的。

      ![image-20220404123732051](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220404123732051.png)

    - 区间修改下的区间查询

      方法之一：如果题目是最终下推一次所有标记就可以的类型，我们可以直接打上标记不更新，靠最终一次的遍历得到全部结果。

      方法之二：如果题目查询跟修改混在一起，那么采用标记永久化的思想，也就是不下推标记。

      递归线段树是在查询区间时逐个下推标记，这样到达子区间的时候答案已经是正确的了；非递归线段树做不到，因为它是从下至上进行的，遇到标记就更新答案。

      左边的蓝色节点$H$从下往上走，在蓝色节点到达$4$时，注意到，左边蓝色节点之前计算过的所有节点$G、H、8、9、I、J$都是目前蓝色节点的子节点，也就是说，当前蓝色节点$4$的懒惰标记是要影响这个节点已经计算过的所有数。多用一个变量来记录这个蓝色节点已经计算过多少个数， 根据个数以及当前蓝色节点的懒惰标记，来更新最终答案。
      更新完答案之后，再加上$5$号节点的答案，同时当前蓝色节点计算过的个数要+4（因为$5$号节点代表4个数的和）。然后当这个节点到达$1$节点时，可以更新$1$号节点的懒惰标记。
      这里，本来左右蓝色节点相遇之后就不再需要计算了（正常情况下分别到达$2$和$3$号节点就可以结束了）但是由于有了懒惰标记，左右蓝色节点的公共祖先上的懒惰标记会影响目前的所有数，所以还需要一路向上查询到根，沿途更新答案。

      ![image-20220404125158567](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220404125158567.png)

    - 区间修改

      修改的时候，给某个区间的懒惰标记加上了$val$，这个区间的子区间向上查询时，会经过这个节点，也就是会计算这个懒惰标记，但是如果路径经过这个区间的父节点，就不会计算这个节点的懒惰标记，也就会出错。这里其实跟递归线段树一样，改了某个区间的懒惰标记仍需要向上更新所有包含这个区间的$sum$，来保持上面所有节点的正确性。

- 第三层——线段树实现【点修改】【区间修改】【数组实现线段树】【非递归函数】

  【用的还是少一些，限制条件较高】【低掌握程度】

  限制要求：

    1. 非递归线段树只能维护相对标记，绝对标记问题不可以使用非递归线段树。
    2. 非递归线段树对点修改和区间查询非常友好，但是对于区间更新略显疲态；有一种例外是，在所有操作结束后一次性下推所有标记然后求结果，这种区间查询非递归线段树也比较友好。

  简单来说：使用到动态实时区间修改并查询尽量不要使用非递归版本，点更新+区间查询适合使用非递归版本或者树状数组。

  ```java
  // 定义
  int[] nums;
  int[] sum = new int[nums.length << 2];
  int[] flag = new int[nums.length << 2];
  // 建树
  public void build(int index){
      int N = 1;
      while (N < n + 2){
          N <<= 1;
      }
      for (int i = 0; i <= n; i++){
          sum[N + i] = nums[i]; // 原数组下标 + N = 存储下标
      }
      for (int i = N - 1; i > 0; --i){
          sum[i] = sum[i << 1] + sum[i << 1 | 1];
          flag[i] = 0;
      }
  }
  // 点修改
  public void update(int location, int val){
      for (int s = N + location; s > 0 ; s >>= 1){
          sum[s] += val;
      }
  }
  // 点修改下的区间查询
  public int query(int L, int R){
      int ans = 0;
      for (int s = N + L - 1, t = N + R + 1; s ^ t ^ 1 > 0; s >> 1, t >> 1){
          if (~s & 1 > 0) ans += sum[s ^ 1];
          if ( t & 1 > 0) ans += sum[t ^ 1];
      }
  }
  // 区间修改
  public void Update(int L,int R,int C){
      int s,t,Ln=0,Rn=0,x=1;
      //Ln:  s一路走来已经包含了几个数
      //Rn:  t一路走来已经包含了几个数
      //x:   本层每个节点包含几个数
      for(s=N+L-1,t=N+R+1;s^t^1;s>>=1,t>>=1,x<<=1){
          //更新Sum
          Sum[s]+=C*Ln;
          Sum[t]+=C*Rn;
          //处理Add
          if(~s&1) Add[s^1]+=C,Sum[s^1]+=C*x,Ln+=x;
          if( t&1) Add[t^1]+=C,Sum[t^1]+=C*x,Rn+=x;
      }
      //更新上层Sum
      for(;s;s>>=1,t>>=1){
          Sum[s]+=C*Ln;
          Sum[t]+=C*Rn;
      } 
  }
  // 区间修改下的区间查询
  public int Query(int L,int R){
      int s,t,Ln=0,Rn=0,x=1;
      int ANS=0;
      for(s=N+L-1,t=N+R+1;s^t^1;s>>=1,t>>=1,x<<=1){
          //根据标记更新 
          if(Add[s]) ANS+=Add[s]*Ln;
          if(Add[t]) ANS+=Add[t]*Rn;
          //常规求和 
          if(~s&1) ANS+=Sum[s^1],Ln+=x;
          if( t&1) ANS+=Sum[t^1],Rn+=x; 
      }
      //处理上层标记
      for(;s;s>>=1,t>>=1){
          ANS+=Add[s]*Ln;
          ANS+=Add[t]*Rn;
      }
      return ANS;
  }
  ```


- 第四层——线段树实现【`class`模式】【点修改、区间修改】

  ```java
  
  ```







---

## 二分查找

1. 二分查找是一种优化的暴力查找，优化基于一个假设：数组或序列已经被排好了顺序。

2. 高级二分查找思想：

   只要答案具有二分性，就可以使用二分查找。

3. 二分查找的基本模板

   ```java
   // 模板一，默认数组是递增排序的
   public int BinarySearch(int[] nums, int target){
       int left = 0;
       int right = nums.length - 1;
       while (left <= right){
           int mid = left + (right - left) / 2;
           if (nums[mid] == target){
               return mid;
           } else if (nums[mid] < target){
               left = mid + 1;
           } else if (nums[mid] < target){
               right = mid - 1;
           }
       }
       return -1;
   }
   // 模板二 （明显更优秀一些）
   public int BinarySearch(int[] nums, int target){
       int left = 0;
       int right = nums.length;
       while (left < right){
           int mid = left + (right - left) / 2;
           if (nums[mid] == target){
               return mid;
           } else if (nums[mid] < target){
               left = mid + 1;
           } else if (nums[mid] < target){
               right = mid;
           }
       }
       return -1;
   }
   ```

4. 二分查找的细节

    - 为什么`while`循环的条件中是`left <= right`或`left < right`?

      > 因为初始化`right`的赋值是`nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`，前者相当于两端都闭区间`[left, right]`，后者相当于左闭右开区间`[left, right)`，因为索引大小为`nums.length`是越界的。

    - `left <= right`与`left < right`的区别

      > `left <= right`的循环终止条件是`left == right + 1`，写成区间的形式就是`[right + 1, right]`，在这种情况下没有数被漏掉，循环可以直接结束，这正是模板一的思路想法，从一开始设置的`right`就可以看出，区间内的任何一个元素都有可能是答案所在，必须精准地遍历每一个元素。

      > `left < right`的循环终止条件是`left == right`，写成区间的形式就是`[right, right]`，不难发现这个时候`right`还没有被检查，这样的循环终止条件就与模板二十分匹配，因为`right`这个位置始终不是答案所在的位置，从一开始它就是越界的下标，随着后面的逐渐遍历，它如果被更新了也只是“必定不满足题意的`mid`”所在的位置。

5. **高级版本** 数组中存在重复元素时，如何寻找最右边的元素和最左边的元素？

    - 寻找最左边的元素（也可以理解为小于`target`的元素有多少个）

      ```java
      // 二分查找之寻找最左边的元素
      // [1,2,2,2,2,3] target = 2;
      public int left_bound(int[] nums, int target) {
          int left = 0;
          int right = nums.length; 
          while (left < right) {
              int mid = (left + right) / 2;
              if (nums[mid] == target) {
                  right = mid;
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else if (nums[mid] > target) {
                  right = mid;
              }
          }
          return left;
      }
      ```

      为什么这个版本可以查找到最左边的元素？或者可以定位到数组中刚好小于`target的`位置？

      > 关键在于`nums[mid] == target`这句代码，当前值等于`target`是，我们不是急着返回，而是要求继续缩减右边的空间到`mid`，这样就保证了退出循环时一定是`left == right`且所在位置是刚好小于等于`target`的第一个位置。

      如果没找到可不可以返回`-1`？当然可以，去掉`return left;`这句话，换成下面的代码：

      ```java
      // 整个数组的元素都小于target，有nums.length个元素都小于target，这时候返回 -1 表示没找到
      if (left == nums.length) return -1;
      // 否则就是数组中没有找到target，但是有left个元素小于target，这时候看看left所在的位置等不等于target，等于就返回left，不等就说明没找到
      return nums[left] == target ? left : -1; // 因为终止条件是left == right，所以实际上返回right也是一样的
      ```

    - 寻找最右边的元素（也可以理解为小于等于`target`的元素有多少个）

      ```java
      public int right_bound(int[] nums, int target) {
          int left = 0, right = nums.length;
          while (left < right) {
              int mid = (left + right) / 2;
              if (nums[mid] == target) {
                  left = mid + 1; 
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else if (nums[mid] > target) {
                  right = mid;
              }
          }
          return left - 1; // right - 1是一样的
      }
      ```

      为什么这个代码可以找到最右边的元素？

      > 关键在于`nums[mid] == target`这行代码，当前值是`target`的时候，我们不是急着返回而是要求继续缩减左侧空间到`mid`，这样就保证了退出循环时一定是`left == right`。

6. 总结：

    - 模板一全家桶（思考相对麻烦一点，但好写）

      ```java
      // 基础模板
      public int BinarySearch(int[] nums, int target){
          int left = 0;
          int right = nums.length - 1;
          while (left <= right){
              int mid = left + (right - left) / 2;
              if (nums[mid] == target){
                  return mid;
              } else if (nums[mid] < target){
                  left = mid + 1;
              } else if (nums[mid] < target){
                  right = mid - 1;
              }
          }
          return -1;
      }
      // 寻找左侧边界
      private int BinarySearch(int[] numbers, int target){
          int start = 0;
          int end = numbers.length - 1;
          while (start <= end){
              int mid = (start + end) / 2;
              if (numbers[mid] == target){
                  end = mid - 1;
              } else if (numbers[mid] > target){
                  end = mid - 1;
              } else if (numbers[mid] < target){
                  start = mid + 1;
              }
          }
          return end + 1;
          // return start; 也是可以的
      }
      // 寻找右侧边界
      private int BinarySearch(int[] numbers, int target){
          int start = 0;
          int end = numbers.length - 1;
          while (start <= end){
              int mid = (start + end) / 2;
              if (numbers[mid] == target){
                  start = mid + 1;
              } else if (numbers[mid] > target){
                  end = mid - 1;
              } else if (numbers[mid] < target){
                  start = mid + 1;
              }
          }
          return end;
          // return start - 1; 也是可以的
      }
      ```

    - 模板二全家桶（相对不好写，但是好想，因为终止条件总是 `left == right`）

      ```java
      // 基础模板
      public int BinarySearch(int[] nums, int target){
          int left = 0;
          int right = nums.length;
          while (left < right){
              int mid = left + (right - left) / 2;
              if (nums[mid] == target){
                  return mid;
              } else if (nums[mid] < target){
                  left = mid + 1;
              } else if (nums[mid] < target){
                  right = mid;
              }
          }
          return -1;
      }
      // 寻找左侧边界
      public int left_bound(int[] nums, int target) {
          int left = 0;
          int right = nums.length; 
          while (left < right) {
              int mid = (left + right) / 2;
              if (nums[mid] == target) {
                  right = mid;
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else if (nums[mid] > target) {
                  right = mid;
              }
          }
          return left; // return right也是可以的
      }
      // 寻找右侧边界
      public int right_bound(int[] nums, int target) {
          int left = 0;
          int right = nums.length; 
          while (left < right) {
              int mid = (left + right) / 2;
              if (nums[mid] == target) {
                  left = mid + 1;
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else if (nums[mid] > target) {
                  right = mid;
              }
          }
          return left - 1; // return right - 1也是可以的，因为上述过程中找到的是刚好大于target的第一个元素，所以要减一
      }
      ```

        - 关键点：

          基础情况（没有重复元素）需要注意的是搜索区间的开闭问题

          寻找左右边界的情况主要是要注意，当`numbers[mid] == target`的时候的更新策略。

7. 二分查找思想的应用范围可以适用于**寻找**合适的答案中。

   当答案的结果难以通过算法直接求出且其结果具有二分性（小于某一临界值的答案均不可行而大于某一临界值的答案均可行或反之）时，可以采用枚举答案并测试答案是否满足题意来求解问题。

8. 关于精度比较的二分查找

   【宫水三叶786】

----

## 排序

1. 排序算法汇总

   这里的空间复杂度主要是考虑额外再需要申请的空间数量级。

   | 排序算法 | 基本思想 | 时间复杂度(平均)  | 时间复杂度(最坏)  | 时间复杂度(最好)  | 空间复杂度(待考)  | 稳定性 |
      | -------- | -------- | ----------------- | ----------------- | ----------------- | ----------------- | ------ |
   | 插入排序 |          | $O(n^2)$          | $O(n^2)$          | $O(n)$            | $O(1)$            | 稳定   |
   | 希尔排序 |          | $O(n^{1.3})$      | $O(n^2)$          | $O(n)$            | $O(1)$            | 不稳定 |
   | 选择排序 |          | $O(n^2)$          | $O(n^2)$          | $O(n^2)$          | $O(1)$            | 不稳定 |
   | 堆排序   | 堆       | $O(n*log_{2}{n})$ | $O(n*log_{2}{n})$ | $O(n*log_{2}{n})$ | $O({n})$          | 不稳定 |
   | 冒泡排序 |          | $O(n^2)$          | $O(n^2)$          | $O(n)$            | $O(1)$            | 稳定   |
   | 快速排序 | 分区     | $O(n^2)$          | $O(n^2)$          | $O(n*log_{2}{n})$ | $O(n*log_{2}{n})$ | 不稳定 |
   | 归并排序 | 归并     | $O(n*log_{2}{n})$ | $O(n*log_{2}{n})$ | $O(n*log_{2}{n})$ | $O(n)$            | 稳定   |
   | 计数排序 | 计数     | $O(n+k)$          | $O(n+k)$          | $O(n+k)$          | $O(n+k)$          | 稳定   |
   | 桶排序   |          | $O(n+k)$          | $O(n^2)$          | $O(n)$            | $O(n+k)$          | 稳定   |
   | 基数排序 |          | $O(n*k)$          | $O(n*k)$          | $O(n*k)$          | $O(n+k)$          | 稳定   |

2. 插入排序



3. 希尔排序



4. 选择排序



5. 堆排序

    - 基本定义：堆排序是一种借助“堆”这种数据结构进行排序的算法，主要借助堆能够自动比较大小来实现排序。

    - 适用场景：主要是堆的适用场景，比如找到第`k`大的元素

    - 基本思想：建立堆，将元素全部添加进入堆，然后逐个弹出。

      ```mermaid
      graph LR
          A("建立大顶堆或小顶堆")
          B("遍历元素并添加到堆中")
          C("将堆中的元素逐个弹出来")
          D("开始")
          E("结束")
          D-->A
          A-->B
          B-->C
          C-->E
      ```

    - 时空复杂度分析

      时间复杂度： $O(n*log_{2}{n})$

      空间复杂度：$O({n})$

    - 代码实现：（忽略了堆的具体实现）

      ```java
      public void heapSort(int nums){
          PriorityQueue<Integer> heap = new PriorityQueue<>();
          for(int num : nums){
              heap.offer(num);
          }
          int[] answer = new int[nums.length];
          for (int i = 0; i < nums.length; i++){
              answer[i] = heap.poll();
          }
      }
      ```

6. 冒泡排序

    - 基本定义：冒泡排序是一种简单直观的排序算法，它重复第走访要排序的数列，一次比较两个元素，如果它们的顺序错误就交换；重复地进行直到没有再需要交换的。算法名称的又来主要是因为最小的元素会像冒泡一样浮到最上面。

    - 适用场景：非常需要稳定性的场景（也不一定），基本上没有场景使用

    - 基本思想：外层循环表示通过这一轮排序要保证最少有多少个数找到自己的位置，然后内层的遍历要减去这个固定数值，随后在流程中逐渐交换位置。

      ```mermaid
      graph LR
          A("外层循环设定本轮要确定的位置数量")
          B("内层循环次数减去该固定值")
          C("比较内层循环相邻两个数的大小，逆序则交换")
          D("开始")
          E("结束")
          D-->A
          A-->B
          B-->C
          C-->E
      ```

    - 时空复杂度分析

      时间复杂度：$O(n^2)$

      空间复杂度：$O(1)$

    - 代码实现

      ```java
      public void BubbleSort(int[] nums){
          for (int i = 1; i < nums.length; i++){
              // 加一个标志，表示如果这轮排序没有逆序的，证明已经排好了，直接跳出循环就可以了
              boolean flag = true;
              for (int j = 0; j < nums.length - i; j++){
                  if (nums[j] < nums[j + 1]){
                      // 为flag加上标志
                      flag = false;
                      int temp = nums[j];
                      nums[j] = nums[j + 1];
                      nums[j + 1] = temp;
                  }
              }
              if (!flag){
                  break;
              }
          }
      }
      ```

7. 快速排序

    - 基本定义：快速排序是一种非常高效的排序算法，`Java`的`Arrays.sort()`函数实现的就是快速排序，在需要优先排序的场景中往往都直接使用该函数，表现良好的情况下要比其他对手快2-3倍。

    - 适用场景：需要快速排序且不考虑稳定性的时候。

    - 基本思想：在输入数组中随机选择一个元素作为中间值，然后对数组进行分区，比中间值大的数移动到右边，比中间值小的数移动到左边，接下来对两边的数组做同样的步骤，直到数组的长度为1就终止该分支的排序。

      ```mermaid
      graph LR
          S("开始")
          A("在数组中随机选取一个中间值MID")
          B("大于中间值MID的移动到中间值左边")
          C("小于中间值MID的移动到中间值右边")
          D("对左半边和右半边继续排序")
          E("结束")
          S-->A
          A-->B
          A-->C
          B-->D
          C-->D
          D-->E
      ```

    - 时空复杂度分析

      时间复杂度：$O(n*log_{2}{n})$

      空间复杂度：$O(1)$

    - 代码实现

      ```java
      // 快速排序主函数
      public void quickSort(int[] nums, int left, int right){
          if (left < right){
              int pivot = partition(nums, left, right);
              quickSort(nums, left, pivot - 1);
              quickSort(nums, pivot + 1, right);
          }
      }
      // 快速排序分区函数
      public int partition(int[] nums, int left, int right){
          int random_int_location = new Random().nextInt(right - left + 1) + left;
          int random_int = nums[random_int_location];
          // 要先将随机位置和最后一个数交换
          swap(nums, random_int_location, right);
          // 初始化时small在left - 1的位置
          int small = left - 1;
          for(int i = left; i < right; i++){
              if (nums[i] < nums[right]){
                  small++;
                  swap(nums, small, i);
              }
          }
          small++;
          // 将随机数交换到它应该待的位置上
          swap(nums, small, right);
          // 现在唯一确定的就是随机数所在的位置是正确的
          return small;
      }
      // 快速排序交换函数
      public void swap(int[] nums, int a, int b){
          int temp = nums[a];
          nums[a] = nums[b];
          nums[b] = temp;
      }
      ```

8. 归并排序

    - 基本定义：归并排序是一种基于分治法的排序算法，主要利用递归的思路，先将数组分割成两个部分分别排序，再将两个已经排好序的数组拼接起来。

    - 适用场景：链表的排序比较类似这种想法，通常是将链表与归并排序结合起来考察。

    - 基本思想：先将数组分割成两个部分分别排序，再将两个已经排好序的数组拼接起来。

      ```mermaid
      graph LR
          S("开始")
          A("将数组平均分割为两个数组")
          B("分别排序两个子数组")
          C("两个子数组都已经完成排序")
          D("将两个子数组按照大小拼接")
          E("结束")
          S-->A
          A-->B
          B-->C
          C-->D
          D-->E
      ```

    - 时空复杂度分析

      时间复杂度：  $O(n*log_{2}{n})$

      空间复杂度：  $O(n)$

    - 代码实现：

      ```java
      public int[] mergeSort(int nums[]) {
          int[] ans = Arrays.copyOf(nums,nums.length);
          // end位置的值是ans.length，而不是ans.length - 1
          merge(nums, ans, 0, ans.length);
          return ans;
      }
      
      private void merge(int src[], int dis[], int start, int end) {
          if (end - start <= 1) {
              return;
          }
          int mid = (start + end) / 2;
          // 在交换过程中
          merge(dis, src, start, mid);
          merge(dis, src, mid, end);
          // i是第一个数组的起始
          int i = start;
          // j是第二个数组的起始
          int j = mid;
          // k是目标数组的起始
          int k = start;
          while (i < mid || j < end) {
              if (j == end || (i < mid && src[i] < src[j])) {
                  dis[k++] = src[i++];
              } else {
                  dis[k++] = src[j++];
              }
          }
      }
      ```

9. 计数排序

    - 基本定义：计数排序是一种线性时间的整数排序算法，如果数组的长度为`n`，整数范围（数组中最大整数与最小整数的差值）为`k`，对于`k`远小于`n`的场景，那么计数排序要非常优秀。

    - 适用场景：整数范围远远小于数据量的时候

    - 基本思想：对每个出现的数计数，然后在输出过程中按照计数顺序和数字出现次数输出

      ```mermaid
      graph LR
          A("遍历数组找到最大值与最小值")
          B("再次遍历数组并计数")
          C("按照顺序和次数输出")
          A-->B
          B-->C
      ```

    - 时空复杂度分析

      时间复杂度：  $O(n+k)$

      空间复杂度：  $O(n+k)$

    - 代码实现：

      ```java
      public int[] countSort(int[] nums){
          // 遍历找最大值最小值
          int max = Integer.MIN_VALUE;
          int min = Integer.MAX_VALUE;
          for (int num : nums){
              max = Math.max(max,num);
              min = Math.min(min,num);
          }
          int[] count = new int[max - min + 1];
          // 计数
          for (int num : nums){
              count[num - min]++;
          }
          int[] answer = new int[nums.length];
          int j = 0;
          for (int index = 0; index < count.length;index++) {
              while (count[index] != 0) {
                  answer[j++] = index + min;
                  count[index]--;
              }
          }
          return answer;
      }
      ```

10. 桶排序

    - 基本定义：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。首先将各个元素放到对应的桶中，然后在每个桶中再排序。
    - 适用场景：不常用。
    - 基本思想：
    - 时空复杂度分析：
    - 代码实现：



---

## 代码实现细节

1. `Array.sort()`是排序数组的
   `Collection.sort()`是排序`List<Integer>`的，包装类的排序要使用`Collection`

   ```java
   // n
   Integer[] nums = {1,2,3,4,5};
   Arrays.sort(a, Collections.reverseOrder());
   int[] res = new int[nums.length];
   for (int i = 0; i < nums.length; i++){
       res = Integer.valueOf(a[i]);
   }
   ```



2. 关于字符串的那些事

    - `String`可以通过`char[]`直接实现：

      ```java
      char[] crr = {'q','u','i','c','k'};
      String s = new String(crr);
      ```

    - 但是`toString`方法主要转化为字符串，而不是将`char`数组中的字符拼接起来转化为字符串。

      ```java
      public static void main(String[] args) {
          String k = "qucsoa";
          char [] chars = k.toCharArray();
          String m = chars.toString();
          System.out.println(m); // [C@3786659d
      }
      ```

    - `String`可以通过`join`将某一个字符串插入`List`中

      ```java
      List<String> list = new ArrayList<>();
      list.add("1");
      list.add("2");
      list.add("3");
      String.join(" ", wordList);
      // 得到的是"1 2 3"
      ```

    - `trim()`快速取出字符串的前导空格和尾部空格【注意底层实现原理上，`trim()`实质上是双指针实现的。】

      ```java
      String test = "  hello  ";
      String s = test.trim();
      ```

3. `List<String>`互相转换`String[]`的方法

   ```java
   // List<String> 转 String[]
   String[] srr = list.toArray(new String[list.size()]);
   // String[] 转 List<String>
   List<String> list = Arrays.asList(srr);
   ```

4. 将`List<List<String>>`转为`String[][]`的方法，主要用来改变输出，使用动态`ArrayList`能够方便处理，但是如果输出要求是数组形式就有必要转化了。

   ```java
   List<List<String>> list_list_String = new ArrayList<>();
   String [][] array_of_String = new String [list_list_String.size()][];
   int i = 0;
   for (List<String> list_String : list_list_String){
   	array_of_String[i] = list_String.toArray(new String[0]);
       // 上面那句话可以写成 list_String.toArray(0) 
   	i++;
   }
   字符串是可以的，但是int的数组不行，只能用包装类Integer
   String[] str = new String[list.size()];
   list.toArray(str);
   String[] str = (String[])list.toArray(new String[list.size()]);
   ```

5. 关于`Arrays.fill()`和`Arrays.binarySearch()`

- 使用`Arrays.fill(new int [],1)`将数组中填满数字1，仅建议在一维数组的情况下使用，二维数组会出错的：

  ```java
      public static void main(String[] args) {
          int [] [] test = new int[3][3];
          int [] fi = new int[3];
          Arrays.fill(fi,43);
  //        执行完这条代码以后的二维数组
  //        [43,43,43]
  //        [43,43,43]
  //        [43,43,43]
          Arrays.fill(test,fi);
          test[1][1] = 89;
  //        执行完这条代码以后的二维数组
  //        [43,89,43]
  //        [43,89,43]
  //        [43,89,43]
  //        因为使用同一行代码进行填充，改变了这一行的某个元素，在数组中就相当于改变了整列的元素
      }
  ```

- `Arrays.binarySearch()`

  ```java
  // 源码
  public static int binarySearch(int[] a, int fromIndex, int toIndex, int key) {
          rangeCheck(a.length, fromIndex, toIndex);
          return binarySearch0(a, fromIndex, toIndex, key);
  }
  // 源码
  private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) {
      int low = fromIndex;
      int high = toIndex - 1;
      while (low <= high) {
          int mid = (low + high) >>> 1;
          int midVal = a[mid];
  
          if (midVal < key)
              low = mid + 1;
          else if (midVal > key)
              high = mid - 1;
          else
              return mid; // key found
      }
      return -(low + 1);  // key not found.
  }
  ```

4. 两层`for`循环时如果想跳到外面的循环。可以借用外循环的名称直接`continue`

   ```java
   out:for (int i = 0; i < n; i++){
       for (int j = 0; j < m; j++){
           if (...){
               continue out;
           }
       }
   }
   ```

5. 获得数组最大值

   ```java
   int max = Arrays.stream(nums).max().getAsInt();
   ```

6. `List`和`Array`互相转化（针对元素是整数的情况）

    - 使用`list.stream().mapToInt(i -> i).toArray()`可以将`List<Integer>`快速转换成数组。

   ```java
   // int
   int[] array = list.stream().mapToInt(i -> i).toArray();
   // String
   String [] strArray = list.toArray(new String[list.size()]);
   ```

    - 使用`Arrays.asList`可以将数组快速转化成`List`

   ```java
   List<String> list = Arrays.asList(s.split());
   ```

    - 使用`Arrays.asList`可以将数和数快速转化成`List`

   ```java
   int a = 0;
   int b = 0;
   List<Integer> list = new ArrayList<>(Arrays.asList(a, b); // 直接创建了一个有a和b的list
   ```



7. 复制数组：

   ```java
   System.arrayCopy
   public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
   代码解释:
   	Object src : 原数组
   	int srcPos : 从元数据的起始位置开始
   	Object dest : 目标数组
   	int destPos : 目标数组的开始起始位置
   	int length  : 要copy的数组的长度
   ```


7. `Arrays.toString()`方法可以产生一维数组（是一维数组，而不是一维整数数组）可打印版本，再想查看数组就可以使用这样的语句：

   ```java
   int[] a = {1,2,3,4,5,6};
   System.out.println(Arrays.toString(a));
   // 输出：
   // [1, 2, 3, 4, 5, 6]
   ```

8. 代码命名规范

    - `java`类名的首字母要大写，并且采用驼峰式的方法

    - `java`方法、字段、对象引用名称，首字母小写并采用驼峰式

    - `java`的包名，全部采用小写格式，不采用驼峰

    - `java`中的`static`和`final`共同修饰的域往往全部采用大写，并用下划线分割单词。

      ```java
      // 包名全部小写
      package com.note; 
      // 包名全部小写
      import java.util.Scanner;    
      // 方法的首字母大写 + 驼峰
      public class StudentClass{     
          // 字段小写 + 驼峰
          int studentAge;
          // 编译时常量（即用final和static共同修饰）必须采用全部大写的格式
          static final int VALUE_ONE = 1;
          String studentName;
          // 方法小写 + 驼峰
          public getName(){
              System.out.println(this.name);
          }
      }
      ```

    - 封装的时候要将`public`、`protected`、`void`、`private`依次分别写下来，这样代码的可读性更高。

9. 非常重要的`java`在`ACM`中的操作

    - 读入数据可以接收的方式——使用`BufferedReader`

      ```java
      BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));
      ```

    - 读入数据最快的方式——使用`java.io`包下的`StreamTokenizer`进行处理

      需要着重记忆的就是该方法读到末尾的时候，标识是`StreamTokenizer.TT_EOF`

      ```java
      StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
      in.nextToken();
      int n = (int)in.nval;
      in.nextToken();
      long p = (long)in.nval;
      in.nextToken();
      double q = in.nval;
      ```

    - 写出数据最快的方式——使用`java.io`包下的`PrintWriter`进行处理

      记得使用`flush()`刷新

      ```java
      PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
      int n = 47;
      out.print(n);
      out.flush();
      ```


- 读入数字后再想读入一行字符串的数据，必须使用`nextline()`作为中转和暂停。

  ```java
  // 首先读入数字
  Scanner sc = new Scanner(System.in);
  int num = sc.nextInt();
  sc.nextLine();
  String s = sc.nextLine();
  ```

- 输入输出格式控制



- 注意某些评测平台的`JDK`版本，很多是没有自动拆箱和装箱机制的，需要自己手动添加。



---

## 算法优化

1. 算法优化框架

   理论上讲算法优化分为全局优化和局部优化两个层次。全局优化也成为结构优化，主要是从基本控制结构和算法、数据结构的选择上考虑；局部优化即为代码优化，包括使用尽量小的数据类型、优化表达式、优化赋值语句、优化函数参数、全局变量等。

    - 全局优化

        - 优化算法设计

          典型的算法优化（基本算法优化）

          | 问题描述     | 原算法           | 新算法                        |
                 | ------------ | ---------------- | ----------------------------- |
          | 排序         | 冒泡排序$O(n^2)$ | 归并排序、快速排序$O(n*logn)$ |
          | 递增数组查找 | 遍历$O(n)$       | 二分查找$O(log n)$            |
          |              |                  | 排序 + 二分查找$O(n*log n)$   |

        - 优化数据结构

          一个容易被人看懂的程序也同样容易被编译器读懂。

        - 优化选择结构

          > > 当`if`结构中要判断的并列条件比较多的时候，将它们拆分成多层嵌套的形式，可以减少不必要的判断：
          >
          > ```java
       > int x = 5;
       > // 并列条件比较多的场景
       > if (x > 0 && x <= 2){
       >     ...
       > }
       > if (x > 2 && x <= 4){
       >     ...
       > }
       > if (x > 4 && x <= 6){
       > 
       > }
       > if (x > 6 && x <= 8){
       > 
       > }
       > // 多层嵌套的形式
       > if (x > 0 && x <= 4){
       >     if (x > 0 && x <= 2){
       >         ...
       >     }
       >     if (x > 2 && x <= 4){
       >         ...
       >     }
       > }
       > if (x > 4 && x <= 8){
       >     if (x > 4 && x <= 6){
       >         ...
       >     }
       >     if (x > 6 && x <= 8){
       >         ...
       >     }
       > }
       > ```
          >
          > > 嵌套`switch`语句的使用。与上面嵌套`if`差不多
          >
          > > 为`switch`中的`case`排序，将出现频率多的排在前面

        - 优化循环结构（复杂度主要是根据循环而来，所以优化循环结构非常重要）

          常用的循环优化技术如下：

          > 1. 降阶策略
               >
               >    部分题目可以通过多个二重循环记录答案来代替三重循环。例如四数之和。
          >
          > 2. 加速原理
               >
               >    将循环体内的选择结构去掉，提高循环结构的运行效率。
          >
          > 3. 代码外提
               >
               >    将循环体中与循环变量无关的运算提出，并将其放到循环外，来避免每次循环中的重复操作。
          >
          > 4. 变换循环控制条件
               >
               >    当某循环变量在循环体中除自身引用之外，已不再控制循环过程时，可以将其从循环中删除。
          >
          > 5. 合并循环
               >
               >    用一次遍历可以同时求和和最大值最小值，能用一次遍历解决的就用一次。

    - 局部优化

        - 尽可能使用小的数据类型

          > 能用`char`就不要使用`int`，能使用`int`就不要使用`long`...

        - 优化表达式

          使用圆括号将运算可能不明晰的地方指明

        - 自增、自减和三目运算符

          对于自增自减运算符在编译底层需要的代码量非常少，例如汇编中就可以只用一句话来代替。

        - 减少运算强度

          用乘法运算代替平方

        - 避免浮点运算

          浮点运算非常慢

        - 优化赋值语句

          减少无效引用，也就是尽可能多地嵌套、调用。

          ```java
          List<Integer> list = new ArrayList<>();
          int[] answer = list.stream().mapToInt(i -> i).toArray();
          return answer;
          // 简单地替换为
          return list.stream().mapToInt(i -> i).toArray();
          ```

        - 优化函数参数

          参数要尽可能的精简

2. 细节优化：

    - 直接将数字使用“+”进行拼接的效率要低于使用`StringBuilder`。

    - 访问字符串的某个字符，最好先将字符串使用`toCharArray`转化为字符数组，然后再访问；而不是使用`charAt`方法每次调用。

    - 位运算的运行时间非常优秀。能用位运算就不要用除法。

3.





----

## 解题思路

1. **数据规模与算法选择的关系**（大致关系，不精确）：

- $ 10 ^ 1$，必然的暴力搜索、递归、回溯算法，例如N皇后问题。

- $ 10 ^ 2$ ~ $10 ^ 4$，带有一定递归性质或者是暴力解法，算法复杂度基本都在$ O(n^2)$ 以上

- $10 ^ 4$，算法对应的最差时间复杂度为$O(n^2)$

- $ 10 ^ 4 $ ~ $ 10 ^ 7 $ ，对应为$ O(n * log n )$

- $ 10 ^ 7$ ~ $ 10 ^ 8$ ，对应为$ O(n)$

- $10^8$ 及以上，对应为$ O(log n )$ 甚至是 $O(1)$

- 对$ O(log n )$的直观理解（不要小看了$O(log_{2}{n})$的时间复杂度）

  | $n$             | 1    | 10   | 100  | 1000 | $10 ^ 6$ | $10 ^ 9$ |
    | --------------- | ---- | ---- | ---- | ---- | -------- | -------- |
  | $O(log_{2}{n})$ | 0    | 3    | 7    | 10   | 20       | 30       |

- 计算机一秒内大概可以执行的基本操作次数是$ 10 ^ 8$，基本操作是指赋值、运算、比较，而加减乘除等虽然不是严格的“一次”，但是可以近似看作一次运算。

| 数据量          | $ 10 ^ 1$ | $ 10 ^ 2$ | $10 ^ 3$ | $10 ^ 4$ | $10 ^ 5$ | $ 10 ^ 6 $ | $ 10 ^ 7 $ | $ 10 ^ 8$ |
| --------------- | --------- | --------- | -------- | -------- | -------- | ---------- | ---------- | --------- |
| $O(1)$          | √         | √         | √        | √        | √        | √          | √          | √         |
| $O(logn)$       | √         | √         | √        | √        | √        | √          | √ / ×      |           |
| $O(n)$          | √         | √         | √        | √        | √        | √          |            |           |
| $O(n*logn)$     | √         | √         | √        | √        | √        |            |            |           |
| $O(n^2)$        | √         | √         | √        | √ / ×    |          |            |            |           |
| $O(logn * n^2)$ | √         | √         | √ / ×    |          |          |            |            |           |

| 时间复杂度      | 对应的算法                                                 |
| --------------- | ---------------------------------------------------------- |
| $O(1)$          | 哈希表，公式计算                                           |
| $O(logn)$       | 二分查找，二叉搜索树，堆，`TreeMap`和`TreeSet`中的增删改查 |
| $O(n)$          | 普通遍历                                                   |
| $O(n*logn)$     | 排序                                                       |
| $O(n^2)$        | 冒泡排序                                                   |
| $O(logn * n^2)$ | 暴力求解，递归，回溯                                       |

2. 假设运行时间限制在1秒之内的话：

   | $(数据量) ^ {复杂度}$ | 运行结果                       |
      | --------------------- | ------------------------------ |
   | $10^6$                | 游刃有余地通过                 |
   | $10^7$                | 勉勉强强                       |
   | $10^8$                | 很悬，仅限循环体非常简单的情况 |

3. 递归`dfs()`和迭代`while(...)`的主要区别：

   能使用迭代就不要使用递归，递归好写但是效率低，不论是空间还是时间上。

4.

---

## 数学技巧

1. 判断$N!$中有多少个$0$，可以借助数学公式：

   $N!中0的个数 = N / 5 + N / 5 ^ 2 + N / 5 ^ 3 + ...$







# 算法笔记《卷Ⅲ》

----

## 贪心

1. 贪心法：贪心法是指在对问题求解时，总做出在当前看来是最好的选择。也就是是说不从整体上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但是对范围相当广的许多问题都能产生整体最优解或者是整体最优解的近似解。如果问题能够用贪心算法来求解的话，往往是非常高效的。

   困难的点在于，你要选的策略是什么？它有没有例外情况？

2. 贪心算法的典型例题：

    - 硬币问题（核心思想：尽可能优先使用面值较大的硬币）


> 有1元、5元、10元、50元的硬币各$C_1$、$C_5$、$C_{10}$、$C_{50}$、$C_{100}$、$C_{500}$枚。现在要用这些硬币来支付`A`元，最少需要多少枚钱币？假定本题至少存在一种支付方案。
>
> 限制条件：
>
> - 0 <= $C_1$、$C_5$、$C_{10}$、$C_{50}$、$C_{100}$、$C_{500}$ <= $10^9$
> - 0 <= A <= $10^9$
>
> ```java
   > // ACM模式
   > import java.util.*;
   > public class Main {
   >     public static void main(String[] args) {
   >         Scanner sc = new Scanner(System.in);
   >         int[] coins = new int[6];
   >         int[] value = {1,5,10,50,100,500};
   >         for (int i = 0; i < 6; i ++){
   >             coins[i] = sc.nextInt();
   >         }
   >         int target = sc.nextInt();
   >         int answer = 0;
   >         int coin = 5;
   >         while (target > 0 && coin >= 0){
   >             if (target >= value[coin] && coins[coin] > 0){
   >                 target -= value[coin];
   >                 coins[coin]--;
   >                 answer++;
   >             }
   >             if (target < value[coin] || coins[coin] == 0){
   >                 coin--;
   >             }
   >         }
   >         System.out.println(answer);
   >     }
   > }
   > ```

- 区间贪心

>1. 工作区间调度问题（核心思想：在可选的工作中，每次都选取结束时间最早的任务）
>
>目标：尽可能多地参加任务
>
>> 有`n`项工作，每项工作分别在$s_i$时间内开始并在$t_i$时间内结束。对于每项工作，你都可以选择参与与否，并且明显地你不能同时参加两个任务，而且参与工作的时间段不能重叠，即使是开始的瞬间和结束的瞬间的重叠也是不允许的，在这种情况下，返回你能参加的最多的工作数。
>
>> 限制条件：
>
>> - 1 <= `N` <= 100000
>> - 1 <= $s_i$ <= $t_i$ <= $10^9$
>
>```java
   >// ACM 模式
   >import java.util.Arrays;
   >import java.util.Scanner;
   >
   >public static void main(String[] args) {
   >Scanner sc = new Scanner(System.in);
   >int length = sc.nextInt();
   >int[] start = new int[length];
   >int[] end = new int[length];
   >for (int i = 0; i < length; i++){
   >    start[i] = sc.nextInt();
   >}
   >for (int j = 0; j < length; j++){
   >    end[j] = sc.nextInt();
   >}
   >int[][] task = new int[length][2];
   >for (int i = 0; i < length;i++){
   >    task[i][0] = start[i];
   >    task[i][1] = end[i];
   >}
   >Arrays.sort(task,(o1, o2) -> o1[1] - o2[1]);
   >int ans = 0;
   >int time = 0;
   >for (int i = 0; i < length;i++){
   >    if (time < task[i][0]){
   >        ans++;
   >        time = task[i][1];
   >    }
   >}
   >System.out.println(ans);
   >}
   >```
>
>2. 工作区间覆盖问题（核心思想：先排序，注意按照第一优先级起始时间的升序和第二优先级结束时间的降序实现；最重要的：起始时间在当前搜索区间内的所有区间的最晚结束时间是多久？并产生新的搜索区间，如此循环）
>
>目标：尽可能少地使用区间，来覆盖全体
>
>>有`N`头牛，它们每个都有自己的工作区间`[start_time, end_time]`，给定一个总的工作时间`T`，问最少需要多少头牛才能覆盖从1到`T`的工作时间
>
>```java
   >// ACM模式
   >public static void main(String[] args) throws Exception {
   > StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
   > in.nextToken();
   > int length = (int) in.nval;
   > in.nextToken();
   > int cows = (int) in.nval;
   > int[][] cow_time = new int[length][2];
   > for (int i = 0; i < length; i++) {
   >     in.nextToken();
   >     cow_time[i][0] = (int) in.nval;
   >     in.nextToken();
   >     cow_time[i][1] = (int) in.nval;
   > }
   > // 排序，第一位升序，第二位降序
   > Arrays.sort(cow_time, new Comparator<int[]>() {
   >     @Override
   >     public int compare(int[] o1, int[] o2) {
   >         return o1[0] - o2[0] == 0 ? o2[1] - o1[1] : o1[0] - o2[0];
   >     }
   > });
   > if (cow_time[0][0] != 1) {
   >     System.out.println(-1);
   >     return;
   > }
   > int end_this_round = cow_time[0][1];
   > int answer = 1;
   > int end_next_round = cow_time[0][1];
   > for (int i = 1; i < length; ++i) {
   >     int[] nums = cow_time[i];
   >     // start代表本轮的起始位点
   >     if (nums[0] > end_this_round + 1) {
   >         end_this_round = end_next_round;
   >         answer++;
   >     }
   >     if (nums[0] <= end_this_round + 1){
   >         end_next_round = Math.max(end_next_round, nums[1]);
   >         if (nums[1] >= cows) {
   >             end_this_round = cows;
   >             answer++;
   >             break;
   >         }
   >     }
   > }
   > if (end_this_round == cows) {
   >     System.out.println(answer);
   > } else {
   >     System.out.println(-1);
   > }
   >}
   >```
>
>

---

## 回溯

1. 回溯与动态规划

   两种算法的底层本质是一样的，都是尽可能地遍历全部的情况得出最后的答案。但是二者的区别也十分明显——作为动态规划问题，我们只需要给出可行性和最大最小值，而回溯法往往是要求给出具体的解集。根据这个特点，动态规划在遍历的过程中就可以根据比大小进行剪枝，不需要用函数递归依次记录路径，可以采用固定的数组记录答案，简单的循环就基本可以解决；回溯法虽然也可以进行剪枝判断，但是受制于必须记录路径，因此大部分情况我们都要采用递归。

   简单来说，**需要记录路径或者具体返回解集的问题，基本上是回溯问题**；而求解可行性、最大值、最小值的问题，使用动态规划就可以解决。

2. 回溯法的特点

    - 回溯法可以看作是暴力解法的升级版，在每一步的过程中代码都尝试所有的选项，如果可以就记录下来并逐步回溯到上一个分支，如果不可以就直接回溯到上一个分支，本质上就是暴力解法，但是在具体问题迭代递归的过程中，我们可以实行剪枝的操作，这样就给代码的实现带来了很强的灵活性。

    - 回溯法往往要使用深度优先遍历，深度优先遍历往往借助于递归实现。

      递归函数的模板如下：

      ```java
      // 回溯法递归函数模板
      /**
       * 
       * @param nums   供我们递归检索的数组，通常是题中提供的
       * @param index  记录当前走的步数，已经移动到了哪里
       * @param path   记录这一条路上经过的节点
       * @param ans    记录答案，有时候可以用大小为1的数组实现
       */
      private void dfs(int[] nums, int index, List<Integer> path, List<List<Integer>> ans){
          // 先写退出递归的条件
          if (index == nums.length){
              ans.add(new ArrayList<>(path)); // 要使用new ArrayList<>()才可
          } else {
              // else内容中要适当调整，根据题意剪枝
              // 回溯的分支一
              dfs(nums, index + 1, path, ans);
              // 回溯的分支二
              path.add(nums[index]);   // 先添加
              dfs(nums, index + 1, path, ans);  // 再递归
              path.remove(path.size() - 1);  // 移除
          }
      }
      ```

    - 递归的时候还可以借用栈存储状态，合适的时候将内容从栈中弹出去，递归之前将内容压入栈。

3. 回溯法常用的剪枝方法（比较关键，需要积累和实践）

    - 使用`HashSet`剪枝：回溯过的情况存到`Set`中，如果`Set`中不存在下一次要递归的内容，那么在递归，可以节省非常多的时间。

4.





----

## 博弈论

1. 博弈论问题定义：

   博弈论问题一般有如下几个特点：

   > 博弈模型为两人轮流决策的非合作博弈，即两个人轮流进行决策，并且两人都使用最优策略来获取胜利
   >
   > 博弈是有限的，即无论两个人怎样决策，都会在有限步后决出胜负
   >
   > 公平胜负：即两个人进行决策所遵循的规则相同

   博弈是信息学和数学试题中常会出现的一种类型，算法灵活多变是其最大特点，而其中有一类试题更是完全无法用常见的博弈树来进行解答。 $\color{yellow}寻找必败态即为针对此类试题给出一种解题思路$。

2. 博弈论本身非常难，基于ACM或算法题的要求，此处仅涉猎部分内容。

3. 理论铺垫：

    - 定义P-position和N-position：其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。

      无法进行任何移动的局面（也就是terminal position）是P-position；

      可以移动到P-position的局面是N-position；

      所有移动都导致N-position的局面是P-position。

    - P/N状态有如下性质：

      若面临末状态者为获胜则末状态为胜态否则末状态为必败态。
      一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。
      一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态

    - P点： 即必败点，某玩家位于此点，只要对方无失误，则必败；

    - N点： 即必胜点，某玩家位于此点，只要自己无失误，则必胜。

    - 取石子游戏算法实现

      ​	步骤1:将所有终结位置标记为必败点（P点）；

      ​	步骤2: 将所有一步操作能进入必败点（P点）的位置标记为必胜点（N点）

      ​	步骤3:如果从某个点开始的所有一步操作都只能进入必胜点（N点） ，则将该点标记为必败点（P点） ；

      ​	步骤4: 如果在步骤3未能找到新的必败（P点），则算法终止；否则，返回到步骤2

4. 常用的几个模型（通常是`Alice`先手，`Bob`后手）

    - 巴什博弈（`Bash Game`）

      > 题目内容：有`n`个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取`m`个，最后拿光的人获胜。
      >
      > 分析：如果$n = m + 1$，那么由于一次最多拿`m`个，所以无论先取者拿走了多少个，后者都能一次取光并获胜。因此取胜法则在于：如果$n = (m + 1) * r + s$，那么只要先取者拿走`s`个物品，后手者拿走`k`个，先手再拿走`m + 1 - k`个就能保证先手者必胜。总之给对手留下`(m + 1)`的倍数，就能最后获得胜利；如果$(n - 1) \% (m + 1) == 0$则后手胜利。

      ```java
      // 先手必胜的条件就是 s! = 0
      if (n % (m + 1) != 0){
          return "Alice";
      } else {
          // 否则后手必胜
          return "Bob";
      }
      ```

    - 威佐夫博弈（`Wythoff's game`）

      > 题目内容：有两堆各若干个物品，两个人轮流从某一堆或者同时从两堆中取同样多的物品，规定每次至少取一个，多者不限。
      >
      > 解决思路：设$(a_i,b_i)$表示两堆物品的数量并称其为局势，如果Alice面对$(0,0)$，那么Alice已经失败了，这种局势我们称其为奇异局势。
      >
      > 奇异局势的计算公式：$a_k = [k (1 + \sqrt5) / 2], b_k = a_k + k$。
      >
      > 【首先求出差值，差值*黄金分割比 == 最小值则是奇异局势】
      >
      > 简单来说，如果开局满足奇异局势的条件，则先手必败；反之后手必败。

      ```java
      public String Wgame(int a, int b){
          double r = (Math.sqrt(5.0) + 1) / 2;
          int d = (int)(Math.abs(a - b) * r);
          if (d != min(a,b)){
              // 不满足奇异局势，先手必胜
              return "Alice";
          } else {
              return "Bob";
          }
      }
      ```

    - 尼姆博弈`Nim game`

      > 题目内容：给定`n`堆物品，第`i`堆物品有$A_i$个，两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品获胜，两人都采取最优策略，问是否先手必胜？
      >
      > 解决思路：用$(A_1,A_2,A_3,A_4...)$代表当前的状态，还是一样要寻找必败状态，或者是奇异状态。
      >
      > 公式：将每堆石子的数量转化成二进制，如果异或结果为0，那么先手必败。

      ```java
      public String Ngame(int[] stones){
          int answer = 0;
          for (int i = 0; i < stones.length; i++){
              answer ^= stones[i];
          }
          if (answer == 0){
              // 是奇异状态，先手必败
              return "Bob";
          } else {
              // 非奇异状态，先手必胜
              return "Alice";
          }
      }
      ```

    - 斐波那契博弈

      > 问题定义：有一堆石子个数为`n`，游戏双方轮流取石子，满足：1）先手不能在第一次把所有的石子都取完；2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含）。约定取完最后一个石子的人获胜。
      >
      > 解决思路：寻找必败状态和奇异状态。根据“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。如n=83 = 55+21+5+2，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，那么一定是先手取走这5颗石子中的最后一颗，同理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。
      > 公式：如果`n`是斐波那契数，先手必败；

      ```java
      public String Fgame(int n){
          if (/*n是斐波那契数*/){
              return "Bob";
          } else {
              return "Alice";
          }
      }
      ```

5. 针对于ACM的一般博弈问题【高端】求解过程：

   ```mermaid
   graph LR
   	S("开始")
   	A("将博弈问题抽象为ICG问题")
   	B("使用SG函数")
   	C("构建为尼姆博弈问题")
   	D("求解")
   	E("结束")
   	S-->A
   	A-->B
   	B-->C
   	C-->D
   	D-->E
   ```

    - 前期准备：

        - 定义$mex$运算，这是一个施加于集合的运算，表示$最小的不属于这个集合的非负整数$。例如：$mex(0,1,2,4) = 3$

        - 对于一个给定的有向无环图，定义关于图的每个顶点的$SG$函数：$SG(x) = mex(SG(y)|y是x的后继)$

        - $SG$函数的基本求法框架：

            1. 找出必败态

            2. 找出当前所有状态的前驱结点

            3. 根据定义计算结点SG值

            4. 重复上述步骤，直到整棵树建立完成

    - $ICG$问题的定义【公平组合博弈（`Impartial Combinatori Games`）】

        1. 两人参与
        2. 游戏局面的状态集合是有限的
        3. 对于同一个局面，两个游戏者可操作的集合完全相同
        4. 游戏者轮流进行游戏
        5. 当无法进行操作时游戏结束，此时不能进行操作的一方算输
        6. 无论游戏如何进行，总可以在有限步数之内结束

      模型：事实上，这个游戏可以认为是所有公平组合游戏（ICG）的抽象模型。其实，任何一个ICG都可以通过把每个局势看成一个顶点，对每个局势和它的子局势连一条有向边来抽象成这个“有向图游戏”。

    - 如何通过$SG$函数来解决问题？

      对于$n$个棋子，设它们对应的顶点的$SG$值分别是$(a_1,a_2,...,a_3)$，再设局面$(a_1,a_2,...,a_3)$时的$Nim$游戏的一种必胜策略是把$a_i$变成$k$，那么原游戏的一种必胜策略就是把第$i$枚棋子移动到一个$SG$值为$k$的顶点。

      简单来讲，我们让每个节点都拥有一个$SG$值（假设这个值为$x$），那么对于任意一个玩家操作（移动到当前节点的某个后继节点）实际上就是把棋子移动到$\{0,...,x-1\}$的某个节点上，等价的就是从$x$个物品中取走至少一个，至多$x$个。

   > 1、性质：
   >
   > （1）所有的终结点所对应的顶点，其SG值为0，因为它的后继集合是空集——所有终结点是必败点（P点）。
   >
   > （2）对于一个`sg(x)=0`的顶点`x`，它的所有后继`y`都满足`sg(y)!=0`——无论如何操作，从必败点（P点）都只能进入必胜点（N点）【对手走完又只能把N留给我们】。
   >
   > （3）对于一个`sg(x)!=0`的顶点，必定存在一个后继点`y`满足`sg(y)=0`——从任何必胜点（N点）操作，至少有一种方法可以进入必败点（P点）【就是那种我们要走的方法。
   >
   > 2、应用：
   >
   > （1）可选步数为1-m的连续整数，直接取模即可，`SG(x) = x % (m+1)`；
   >
   > （2）可选步数为任意步，`SG(x) = x`;
   >
   > （3）可选步数为一系列不连续的数，用`mex(计算每个节点的值) `

6. 动态规划与博弈论结合【博弈论系列问题的标准常规解法】

   $\color{yellow}动态规划 + 博弈论的核心思想：在二维 dp 的基础上使用元组分别存储两个人的博弈结果。$

    - 例题：你和你的朋友面前有一排石头堆，用一个数组`piles[]`表示，`piles[i] `表示第 `i `堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。设计一个算法，求二者最后的石头数目之差。

        - 首先是对DP数组的定义

          $dp[i][j].first := 对于piles[i...j]这部分石头堆，先手能够获得的最高分数$

          $dp[i][j].second:= 对于piles[i...j]这部分石头堆，后手能够获得的最高分数$

        - 我们想求的问题可以转化为，先手和后手最终分数的差值，也就是$dp[0][n - 1].first - dp[0][n - 1].second$

        - 写状态转移方程比较简单，首先要找到所有状态和每个状态可以做的选择，然后择优。

          一个大致的框架是：

          ```java
          int n == piles.length;
          for 0 <= i < n:
              for j <= i < n:
                  for who in {first,second}:
                      dp[i][j][who] = max(left, right); // 择优
          ```

          这道题的难点在于，两人是交替选择的，先手的选择会堆后手有影响，怎样表达呢？

          ```java
          dp[i][j].first = Math.max(piles[i] + dp[i + 1][j].second, piles[j] + dp[i][j - 1].second);
          // 解释：我作为先手，面对piles[i...j]时，有两种选择：
          // 我选左边的：然后面对piles[i + 1...j]
          // 然后此时轮到对方，我是后手
          // 我选右边的：然后面对piles[i...j - 1]
          // 然后此时轮到对方，我是后手
          if (piles[i] + dp[i + 1][j].second > piles[j] + dp[i][j - 1].second ){
              // 代表选择了左边
              dp[i][j].second = dp[i + 1][j].first;
          } else {
              // 先手选择了右边
              dp[i][j].second = dp[i][j - 1].first;
          }
          // 解释：我作为后手，要先等先手选择，有两种情况：
          // 如果先手选择了最左边那堆，给我剩下了piles[i + 1...j]
          // 此时轮到我，我是先手
          // 如果先手选择了最右边那堆，给我剩下了piles[i...j - 1]
          // 此时轮到我，我是先手
          
          ```

          一个很重要的点是，我们要斜着更新数组，这样才能保证是从中心开花向最终答案逐步靠近

          ```java
          public int stoneGame(int[] piles){
              int n = piles.length;
              int[][][] dp = new int [n][n][2]; // 0表示先手，也就是first，1表示后手，也就是second	
              for (int length = 2; l <= n; l++){ // 斜着更新的妙用，从2开始
                  for (int i = 0; i <= n - 1; i++){ // 行数
                      int j = l + i - 1; // 行数对应的位置
                      int left = piles[i] + dp[i + 1][j][1];
                      int right = piles[j] + dp[i][j - 1][1];
                      if (left > right){
                          dp[i][j][0] = left;
                          dp[i][j][1] = dp[i + 1][j][0];
                      } else {
                          dp[i][j][0] = right;
                          dp[i][j][1] = dp[i][j - 1][0];
                      }
                  }
              }
              return dp[0][n - 1][0] - dp[0][n - 1][1];
          }
          ```

        - 引申：由于动态规划的本质就是记忆化搜索，其实面对一些博弈问题是可以采用记忆化搜索的形式降低思考难度的。





---

## 动态规划

1. 动态规划与回溯

   两种算法的底层本质是一样的，都是尽可能地遍历全部的情况得出最后的答案。但是二者的区别也十分明显——作为动态规划问题，我们只需要给出可行性和最大最小值，而回溯法往往是要求给出具体的解集。根据这个特点，动态规划在遍历的过程中就可以根据比大小进行剪枝，不需要用函数递归依次记录路径，可以采用固定的数组记录答案，简单的循环就基本可以解决；回溯法虽然也可以进行剪枝判断，但是受制于必须记录路径，因此大部分情况我们都要采用递归。

   简单来说，需要记录路径或者具体返回解集的问题，基本上是回溯问题；而**求解可行性、最大值、最小值的问题，使用动态规划就可以解决**。

2. 动态规划与记忆化搜索

   动态规划的转移方程有两种实现方式，一种是普通的循环，例如背包问题；另一种就是记忆化搜索了。

   动态规划的本质是记忆化搜索，然而记忆化搜索的思想与动态规划的思想并不太一致：

   动态规划：这个阶段的问题遇上一个阶段有明显关联，直接使用动态转移方程查找就可以，查找的对象就是记录在数组中的结果。（动态转移方程明确，从这个状态直接可以跳转到另一个状态）

   记忆化搜索：这个阶段的问题与上一个阶段的问题不知道有没有关联，本质上是递归，如果该层递归已经做过了，那么直接从数组中取出就可以，如果没有做过，那么递归。（动态转移方程不明确，递归记录答案）

   > 如果对记忆化搜索还不是很熟练的情况下，很可能会将各种参数都写在递归函数上，在需要剪枝的情况下这种写法非常有效，但是这种方式对实现记忆化搜索是非常困难的。

3. 动态规划小技巧

    - 动态规划的核心思想

        - 首先是大问题划分为小问题的思维。

        - 其次是用空间换时间的思维。需要计算当前情况下的结果，我们需要什么样的输入参数呢？这样的输入参数可不可以通过记录在数组中的形式来避免重复计算？

    - 动态规划一般不会涉及到三维数组，尤其对于面试测试题而言

    - 有两种变化，可以创建两个`DP`数组来回转化

    - 有三种粉刷方式，可以创建三个`DP`数组互相更新

    - 动态规划的转移方程可以列表显示，而且在列表规划的过程中，每一步都必须符合基本题意，不能凑数，一旦凑数开始，就很难再找到规律

4. 动态规划的解题思路

   > - $\color{yellow}问题定义$（问题定义的好坏直接影响时间复杂度）
   > - $\color{yellow}由问题的拆分转变为递归方法，递归方法进一步简化成为记忆化搜索，最后转变为动态规划$
   > - $\color{yellow}得到动态转移方程$
   > - $\color{yellow}解决初始化问题$
   > - $\color{yellow}选择合适的遍历方向$

5. 第一类动态规划问题——背包问题

    - 什么是背包问题

      给定一组物品，每种物品都有自己的重量和价格，要在限定的总质量内，我们如何选择，才能使得物品的总价格最高。

    - 背包问题分类

      背包问题主要分为零一背包问题、完全背包问题、多重背包问题。

    - 零一背包问题（最基础的问题，涉及了一部分记忆化搜索的内容）

      题目描述：一共有N件物品，每件物品都只有一件，第`i`件物品的重量为`w[i]`，价值是`v[i]`，在总质量不超过背包上限`W`的情况下，能够装入背包的最大价值是多少？

      > 第一种解法

      ```java
      // 空间优化版本
      int [] weights; // 要提前排序
      int [] values;   
      int [] dp = new int [W + 1]; 
      int W; // 背包容量上限
      dp[0] = 0; 
      for (int i = 0; i < weights.length; i++){ 
          for (int j = W; j >= weights[i]; j--){ // 逆向枚举 
              dp[j] = Math.max(dp[j],dp[j - weights[i]] + values[i]);
          }
      }
      ```

      > 第二种解法（挑战程序设计竞赛——基础递归解法）

      ```java
      // 从最复杂的递归开始
      int[] weights;
      int[] values;
      public int dfs(int i, int j){ // i代表第几个物品，j代表容量
          int res = 0;
          if (i == n){
              // 退出条件
              res = 0;
          } else if (j < weights[i]) {
              // 代表装不下这个物品
              res = dfs(i + 1, j);
          } else {
              res = Math.max(dfs(i + 1, j), dfs(i + 1, j - weights[i]) + values[i]); // 代表递归的两种分支，装和不装
          }
          return res;
      }
      ```

      > 第三种解法（挑战程序设计竞赛——记忆化搜索）

      ```java
      // 创建记忆化数组
      int n; // 代表物品的数量
      int W; // 代表背包的大小
      int[] w; 
      int[] v;
      int[][] dp = new int [n + 1][W + 1]; // 初始化为-1
      public int dfs(int i, int j){
          if (dp[i][j] >= 0){
              return dp[i][j]; // 这就是记忆化搜索，做过了就不再做了
          }
          int res;
          if (i == n){
              res = 0;
          } else if (j < w[i]){
              res = dfs(i + 1, j);
          } else {
              res = Math.max(dfs(i + 1, j), dfs(i + 1, j - w[i]) + v[i]);
          }
          dp[i][j] = res;
          return res;
      }
      ```

      > 第四种解法（挑战程序设计竞赛——动态规划）
      >
      > 这种解法的关键在于定义：**`dp[i][j]`代表的是从第`i`个物品开始挑选总重小于`j`时，总价值的最大值。**
      >
      > 这个定义与上面的记忆化搜索如出一辙，这就暗示我们，实际上可以通过记忆化搜索推导动态规划的状态转移方程
      > $$
      > \begin{align}
      > & dp[n][j] = 0 \\
      > & dp[i][j]=\begin{cases}dp[i + 1][j] &j<w[i]\\ max(dp[i+1][j], dp[[i + 1][j - w[i]] + v[i])& others\end{cases}
      > \end{align}
      > $$

      ```java
      int n; // 代表物品的数量
      int W; // 代表背包的大小
      int[] w; 
      int[] v;
      int[][] dp = new int [n + 1][W + 1];
      public int solve(){
          for (int i = n - 1; i >= 0; i--){ // 逆向遍历
              for (int j = 0; j <= W; j++){
                  if (j < w[i]){
                      dp[i][j] = dp[i + 1][j];
                  } else {
                      dp[i][j] = Math.max(dp[i + 1][j], dp[i+1][j - w[i]] + v[i]);
                  }
              }
          }
          return dp[0][W]; // 注意返回值
      }
      ```

      > 第五种解法（挑战程序设计竞赛——动态规划）
      >
      > 这种解法的关键在于定义：**`dp[i][j]`代表的是从`0`到`i`这`i + 1`物品中挑选出总重量不超过`j`时，总价值的最大值。**
      >
      > 这个定义与上面的记忆化搜索如出一辙，这就暗示我们，实际上可以通过记忆化搜索推导动态规划的状态转移方程
      > $$
      > \begin{align}
      > & dp[0][j] = 0 \\
      > & dp[i + 1][j]=\begin{cases}dp[i][j] &j<w[i]\\ max(dp[i][j], dp[[i][j - w[i]] + v[i])& others\end{cases}
      > \end{align}
      > $$

      ```java
      int n; // 代表物品的数量
      int W; // 代表背包的大小
      int[] w; 
      int[] v;
      int[][] dp = new int [n + 1][W + 1];
      public int solve(){
          for ()
      }
      ```

    - 完全背包问题

      题目描述：一共有N件物品，每件物品有无数件，第`i`件物品的重量为`w[i]`，价值为`v[i]`，在总质量不超过背包上限W的情况下，能够装入背包的最大价值是多少？

      ```java
      // 空间优化版本
      int [] wieghts; // 要提前排序
      int [] values;
      int [] dp = new int [W + 1];
      dp[0] = 0;
      for (int i = 0; i < weight.length; i++){
          for (int j = weights[i]; j <= W; j++){ // 正向枚举
              dp[j] = Math.max(dp[j],dp[j - weightd[i]] + values[i]);
          }
      }
      ```

    - 多重背包问题

      > 题目描述：一共有N种物品，现在第`i`种物品的数量的上限是`n[i]`，重量是`w[i]`，价值为`v[i]`。在重量不超过W的情况下，能够装入背包的最大价值是多少？

      标准解法：三重循环遍历

      ```java
      // 空间优化版本
      int [] numbers;
      int [] weights; // 要提前排序
      int [] values;
      int [] dp = new int [W + 1];
      dp[0] = 0;
      for (int i = 0; i < weight.length; i++){
          for (int j = W; j >= weights[i]; j--){ // 逆向枚举
              for (int k = 0; k <= numbers[i]; k++){
                  dp[j] = Math.max(dp[j], dp[j - k * weights[i]] + k * values[i]);
              }
          }
      }
      ```

      多重背包问题的另一种解（注意这个环境下的数据，价值被限定在较小的区间以内，而重量被无限扩大，所以这种情况下遍历价值）

      > 重新定义`dp[i + 1][j]`为前`i`个物品中挑选出价值总和为`j`时总重量的最小值（不存在时就是一个充分大的数值）

      当价值较小的解法：

      ```java
      // values的和较小的遍历
      int n; // 物品的种类数
      int max_value; // 所有价值的最大值
      int[][] dp = new int[n + 1][n * max_value + 1];
      // 初始化
      dp[0][0] = 0;
      for (int i = 0; i < n * max_value + 1; i++){
          dp[0][i] = Integer.MAX_VALUE;
      }
      // 遍历开始
      for (int i = 0; i < n; i++){
          for (int j = 0; j <= max_value * n; j++){
              if (j < v[i]){
                  dp[i + 1][j] = dp[i][j];
              } else {
                  dp[i + 1][j] = Math.min(dp[i][j], dp[i][j - v[i]] + w[i]);
              }
          }
      }
      int res = 0;
      // 遍历一遍，找到令 dp[n][j] <= W 最大的j
      for (int i = 0; i <= max_value * n; i++){
          if (dp[n][i] <= W){
              res = i;
          }
      }
      return res;
      ```

    - 关于多重背包的代码书写谬误

        - 注意零一背包问题，是逆向枚举，因为需要访问上一行记录的数据；多重背包问题，是顺向枚举，因为需要访问这一行的数据；多重背包问题，是逆向枚举，原因要部分地访问上一行的数据。

- 注意背包问题的遍历，外层必须是`N`，内层必须是需求`W`，换句话说外层必须遍历待选物品的个数，内层必须遍历背包容量，每次外层遍历都是以更新背包容量内的内容为目标。

    - 初始化的数组不够长，数组的访问特别容易越界。

- 背包问题的迭代是要涉及到容量为`0`的情况的，所以不能认为容量为`0`没有实际意义就不遍历。

- 总结：

  如果使用二维的`dp`数组，是不用考虑正向枚举或逆向枚举的。

  在内部的遍历过程中，直接使用`j >= weights[s] `消除`if `语句。

6. 第二类动态规划问题——序列DP问题

    - **LIS**（最长上升子序列，`Longest Increasing Subsequence`）

      > 注意这里的序列是不可变的，所以保证了答案的顺序性，即前面遍历的内容一定会成为后面的子答案

        - $O(n^2)$时间复杂度的解法

          ```java
          // ACM模式
          public static void main(String[] args) {
              Scanner sc = new Scanner(System.in);
              int n = sc.nextInt();
              int[] nums = new int[n];
              for (int i = 0; i < n; i++) {
                  nums[i] = sc.nextInt();
              }
              int[] dp = new int[n + 1];
              Arrays.fill(dp, 1);
              for (int i = 0; i <= n; i++) {
                  for (int j = 0; j < i; j++) {
                      if (dp[i] > dp[j]) {
                          dp[i] = Math.max(dp[i], dp[j] + 1);
                      }
                  }
              }
              int answer = 1;
              for (int i = 0; i <= n; i++) {
                  answer = Math.max(answer, dp[i]);
              }
              System.out.println(answer);
          }
          ```

        - $O(n*log{n})$时间复杂度的解法（本质是贪心 + 二分）

          ```java
          // ACM模式
          public static void main(String[] args) {
              Scanner sc = new Scanner(System.in);
              int n = sc.nextInt();
              int[] nums = new int[n];
              for (int i = 0; i < n; i++) {
                  nums[i] = sc.nextInt();
              }
              int[] dp = new int[n];
              int answer = 0;
              Arrays.fill(dp, Integer.MAX_VALUE);
              for (int i = 0; i < n; i++){
                  int start = 0;
                  int end = answer;
                  while (start < end){ // 二分查找
                      int mid = (start + end) >> 1;
                      if (dp[mid] < nums[i]){
                          start = mid + 1;
                      } else if (dp[mid] > nums[i]){
                          end = mid;
                      } else {
                          end = mid;
                      }
                  }
                  dp[start] = nums[i];
                  if (end == answer){
                      answer++;
                  }
              }
              System.out.println(answer);
          }
          ```

    - **LCS**（最长公共子序列，`Longest Common Subsequences`）

      > 递推关系式
      > $$
      > \begin{align}
      > dp[i + 1][j + 1]=\begin{cases}max(dp[i][j] + 1, dp[i][j + 1], dp[i + 1][j]) & s_{i + 1} = t_{j + 1}\\ max(dp[i][j + 1], dp[[i + 1][j])& others\end{cases}
      > \end{align}
      > $$

      ```java
      public int lengthOfLCS(String s, String t) {
          int m = s.length();
          int n = t.length();
          int[][] dp = new int[m + 1][n + 1];
          for (int i = 0; i < m; i++){
              for (int j = 0; j <= n; j++){
                  if (s.charAt(i) == t.charAt(j)){
                      dp[i + 1][j + 1] = Math.max(dp[i][j] + 1, Math.max(dp[i][j + 1],dp[i + 1][j]));
                  } else {
                      dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
                  }
              }
          }
          System.out.println(dp[m][n]);
      }
      ```

7. 第三类动态规划问题——矩阵中的DP



8. 第四类动态规划问题——滚动数组

   滚动数组动态规划（`Kadane`算法）

   Q53 Q1014

   ```java
   public int maxSubArray(int[] nums) {
       int answer = nums[0];
       int pre = 0;
       for (int num : nums){
           // 带上前面和不带上前面，哪一个更好？
           pre = Math.max(pre + num ,num);
           // 记录答案用
           answer = Math.max(pre,answer);
       }
       return answer;
   }
   
   public int maxScoreSightseeingPair(int[] values) {
       int answer = Integer.MIN_VALUE;
       int log = values[0] + 0;
       for(int i = 1;i<values.length;i++){
           answer = Math.max(answer,log + values[i] - i);
           log = Math.max(log,values[i] + i);
       }
       return answer;
   }
   ```



9. 第五类动态规划问题——多序列多变量同时规划1567

   股票问题

10. 第六类动态规划问题——回文字符串系列

    Q516

11. 第七类动态规划问题——计数动态规划

    - 问题A：

      > 有`n`个完全相同的物品，将他们划分不超过`m`组，求划分方法总数模`M`的余数

      >  主要要考虑到`1 + 1 + 2`和`1 + 2 + 1`本质上是不同的两种划分方式

      ```java
      // ACM
      public static void main(String[] args) {
          Scanner sc = new Scanner(System.in);
          int n = sc.nextInt(); // n obj
          int m = sc.nextInt(); // m group
          int mod = sc.nextInt();
          int[][] dp = new int[m + 1][n + 1];
          dp[0][0] = 1;
          for (int i = 1; i <= m; i++){
              for (int j = 0; j <= n; j++){
                  if (j - i > 0) {
                      dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;
                  } else if (i == j){ 
                      dp[i][j] = 1;
                  } else {
                      dp[i][j] = dp[i - 1][j];
                  }
              }
          }
          System.out.println(dp[m][n]);
      }
      ```

    - 问题B：

      > 有`n`种物品，第`i`种物品有$a_i$个。不同种类的物品可以互相区分但是相同种类的无法区分，从这些物品种取出`m`个的话有多少种取法？

      > 关键是要知道什么时候会出现重复，以及重复的情况出现在哪里。

      ```java
      // ACM
      public static void main(String[] args) {
          Scanner sc = new Scanner(System.in);
          int n = sc.nextInt(); // obj
          int m = sc.nextInt(); // group
          int[] nums = new int[n];
          for (int i = 0; i < n; i++) {
              nums[i] = sc.nextInt();
          }
          int mod = sc.nextInt();
          int[][] dp = new int[n + 1][m + 1];
          // get 0 obj is 1 case 
          for (int i = 0; i <= n; i++){
              dp[i][0] = 1;
          }
          for (int i = 0; i < n; i++){
              for (int j = 1; j <= m; j++){
                  if (j - 1 - nums[i] >= 0){
                      dp[i + 1][j] = (dp[i + 1][j - 1] + dp[i][j] - dp[i][j - 1- nums[i]] + mod) % mod;
                  } else {
                      dp[i + 1][j] = (dp[i + 1][j - 1] + dp[i][j] + mod) % mod;
                  }
              }
          }
          System.out.println(dp[n][m]);
      }
      ```





12. 尚不能分类的动态规划问题

13. 典型动态规划问题

    - 题目内容：【POJ_1065】有`N`个木棒，它们的长度和重量分别是`l`和`w`，需要将木棒按照$l_i$ <= $l_j$并且$w_i$<=$w_j$的顺序排列，如果不能在一组中做到，就可以另起炉灶，求通过怎样分配能够使得组数最小？不需要返回分配方案要返回最小组数。

      > 答案就等于第二个未排序维度的最长下降子序列的长度。（暂时不会证明）

      ```java
      // ACM
      public static void main(String[] args) throws Exception {
          Scanner sc = new Scanner(System.in);
          int turn = sc.nextInt();
          while (turn-- > 0){
              int length = sc.nextInt();
              int[][] sticks = new int[length][2];
              for(int i = 0; i < length; i++){
                  sticks[i][0] = sc.nextInt();
                  sticks[i][1] = sc.nextInt();
              }
              Arrays.sort(sticks, new Comparator<int[]>() {
                  @Override
                  public int compare(int[] o1, int[] o2) {
                      return o1[0] - o2[0] == 0 ? o1[1] - o2[1] : o1[0] - o2[0]; // 升序排列
                  }
              });
              int temp = -1;
              int[] dp = new int[5005];
              for (int i = 0; i < length; i++){
                  dp[i] = 1;
                  for (int j = 0; j < i; j++){
                      if (sticks[i][1] < sticks[j][1]){ // 比较第二个维度，如果出现下降，那么就说明要新开一个数组
                          dp[i] = Math.max(dp[i],dp[j] + 1);
                      }
                  }
                  temp = Math.max(dp[i],temp); // 答案等于最长下降子序列的长度
              }
              System.out.println(temp);
          }
      }
      ```

    - 题目内容：【POJ3046】有`t`组蚂蚁，总数为`a`，同一组蚂蚁没有区别，求`s~e`只蚂蚁可以组成多少个不同的组？

      > 设`dp[i][j]`表示前i种蚂蚁拿出j只能划分成多少组。
      > 则不难推出转移方程：`d[i][j] = sum(d[i-1][j-k])`，其中`k = min(x[i], j)`，`x[i]`为`i`类蚂蚁的个数。
      > 但是这样来递推复杂度太高。
      > 当`j<=x[i]`,将其右边展开得到`d[i][j] = d[i-1][j] + d[i-1][j-1] + ... + d[i-1][0]`。
      > 将第一项`d[i-1][j]`单独抽离出来，就可以发现剩下的相当与`d[i][j-1]`(根据一开始的转移方程)。
      > 所以得到`d[i][j] = d[i-1][j] + d[i][j-1]`。
      > 接下来考虑`j > x[i]`,同样将其展开，右边变成：
      >
      > `d[i-1][j] + d[i-1][j-1] + ... + d[i-1][j-x[i]]`
      >
      > 为了像`j<=x[i]`时将后面凑出一个整项，在这个式子后再添加两项。变成：
      >
      > `d[i-1][j] + d[i-1][j-1] + ... + d[i-1][j-x[i]] + d[i-1][j-1-x[i]] - d[i-1][j-1-x[i]]`
      > 将第一项抽里出来，同样发现剩下的除了最后一项外，中间的所有项可以凑成`d[i][j-1]`，所以此时转移方程如下：
      >
      > `d[i][j] = d[i-1][j] + d[i][j-1] - d[i-1][j-x[i]-1]`

      ```java
      import java.util.*;
      public class Main {
          public static void main(String[] args) throws Exception {
              Scanner sc = new Scanner(System.in);
              int type_of_ants = sc.nextInt();
              int num_of_ants = sc.nextInt();
              int questionOne = sc.nextInt();
              int questionTwo = sc.nextInt();
              int[] type_num = new int[type_of_ants];
              for (int i = 0; i < num_of_ants; i++){
                  type_num[sc.nextInt() - 1]++;
              }
              int k = 0;
              int[][] dp = new int[2][100 * 1005];
              // 初始化
              dp[0][0] = 1;
              dp[1][0] = 1;
              for (int i = 0; i < type_of_ants; i++){
                  k = i & 1;
                  for (int j = 1; j <= num_of_ants; j++){
                      if (j <= type_num[i]) dp[k][j] = (dp[k ^ 1][j] + dp[k][j - 1] + 1000000) % 1000000;
                      else dp[k][j] = (dp[k ^ 1][j] + dp[k][j - 1] - dp[k ^ 1][j - type_num[i] - 1] + 1000000) % 1000000;
                  }
              }
              int ans = 0;
              for (int i = questionOne; i <= questionTwo; i++){
                  if (dp[k][i] >= 0) ans += dp[k][i];
                  ans = ans % 1000000;
              }
              System.out.println(ans);
          }
      }
      ```



    - 





---

## 图论

1. 图的基础知识

    - 图的概况：图是一种非常重要的数据结构，用来表示物体与物体之间的关系。图由若干节点及节点之间的边组成。物体对应图中的节点，如果两个物体之间存在某种关系，那么它们在途中应该有一条边相连。

    - 图的分类：

      图可以分成有向图和无向图，给边规定了方向的图就是有向图，没有规定的话就是无向图。有向图的边用箭头表示。

      同时图还可以分为加权图和无权图，加权图中每条边用来表示两个节点之间某种特殊的关系，无权图中的边都没有权重。

    - 图的表示：图可以使用邻接表或者邻接矩阵表示。

      邻接表：

      ```mermaid
      graph LR
          A("0")
          B("3")
          C("2")
          D("1")
          E("1")
          F("2")
          G("0")
          H("2")
          I("3")
          A---E---I
          D---F
          B---H
          C---G
          
          
      ```



     邻接矩阵：节点之间相连用`1`记录，否则用`0`记录。

     $$\begin{array}{c|ccc} & 0 & 1 & 2 & 3\\ \hline 0 & 0 & 1 & 0 & 1 \\ 1 & 0 & 0 & 1 & 0 \\ 2 & 1 & 0 & 0 & 0 \\ 3 & 0 & 0 & 1 & 0  \end{array}$$

- 图的表示要根据具体场景，如果节点数目非常大而且边的数目比较稀少，那么就可以使用邻接表，这样会节省空间。

2. 图的搜索

   图的搜索有两种基本方法，分别是深度优先搜索和广度优先搜索，两种搜索方法有各自的适用场景，要具体分析。

   最简单的记忆方式：最短距离——采用广度优先搜索；符合条件的路径——采用深度优先搜索。

    - 深度优先搜索：沿着途中的边尽可能深入地搜索。

      实现上，我们需要一个先进后出的栈帮助我们实现深度优先搜索；或我们也可以使用循环实现深度优先遍历。

      深度优先搜索主要适用于寻找$\color{yellow}一条路径$，很容易知道从源点到目标节点路上所经历过的内容。

      ```java
      // 图的深度优先搜索示例
      
      ```

    - 广度优先搜索：系统地展开并检查途中的所有节点以找寻结果。

      实现上，我们需要一个先进先出的队列帮助我们实现广度优先搜索。

      广度优先搜索主要适用于寻找$\color{yellow}最短路径$，因为广度优先搜索每一次新遍历的节点到源点的距离都是相同的，所以会保证到达目标节点的时候一定是众多答案中距离最短那一个，从算法上绝对保证了路径的最短。

      ```java
      // 图的广度优先搜索示例
      
      ```

    - 广度优先搜索会把状态逐个加入队列，因此通常需要与状态数成正比的内存空间。反之，深度优先搜索是与最大的递归深度成正比的。一般与状态数相比，递归的深度不会太大，所以可以认为深度优先搜索更加节省内存。

3. 关于图论的代码实现

    - 图在遍历过程中非常需要记录已经遍历过的节点或位置，所以实现的时候通常会创建一个与原图大小相同的`boolean`数组，用`true`表示已经访问过，而`false`用来表示没有访问过。

4. 二分图与图的染色



5. 广度优先搜索的优化（双向广度优先搜索等优化算法）



6. 拓扑排序

   拓扑排序可以：对无环图进行排序或者对有向图判环。

7. 图论——链式前向星

   > 图的存储一般有两种，邻接矩阵和邻接表。邻接表中有一种存储图的数据结构叫做链式前向星。
   >
   > 如果图的边很少，开二维数组非常浪费；
   >
   > 如果图的点很多，二维数组又会在初始化时即爆炸。
   >
   > 于是便引入了链式前向星。

   链式前向星的基础结构（有向图的存储方法）

   ```java
   // 创建“边”对象
   public class Edge{
       int next;   // 下一条边的存储下标
       int to;     // 这条边的终点
       int weight; // 边的权重
   }
   // 创建“边对象”数组，大小跟边的数目有关
   Edge[] edges = new Edge[500010];
   // head数组，表示现在最后一个以start为起始节点的索引，初始化的时候一般都是0
   // head数组的大小跟
   head[]; 
   
   // 增加一条边，如果以i为起点的边新增了一条，在edge中的下标为j
   public void add(int start, int end, int weight){
       // count代表边的index
       edge[++count].next = head[start]; // 同起点的上一个点的索引
       edge[count].weight = weight;
       edge[count].to = end;
       head[start] = count; // 更新head数组，代表现在最后一个以start为起始节点的索引
   }
   
   // 遍历方法
   for (int i = head[st]; i != 0; i=edge[i].next ){
       
   }
   ```

   链式前向星的基础结构（无向图的存储方法及遍历过程）







8. 图最短路径算法









---

## 并查集

1. 并查集的定义：并查集是一种树型的数据结构，用来表示不相交集合的数据。并查集中的每个子集都是一棵树，每个元素是某棵树中的一个节点。数中的每个节点有一个指向父节点的指针，数的根节点的指针指向它们自己。

2. 并查集经常用来解决图的**动态连接**问题，比如在添加了`m`条边之后，这个图中的子图数量是多少？最大的子图有多少个节点？这类问题都可以用并查集解决。

   另外，并查集主要适用于无向图的相通性的检测，有向图的依赖性主要是靠深度优先遍历和广度优先遍历还有拓扑排序实现的。

3. 并查集的复杂度：

   并查集的真是复杂度是$O(α(n))$，其中$α(n)$是阿克曼函数的反函数。反正总之是比$O(log(n))$还要快的一种复杂度。

   不过这是一种均摊复杂度，也就是说不能保证每一次的操作都满足这个复杂度，而是多次操作之后平均每一次操作的复杂度是$O(α(n))$的意思。

4. 【何海涛并查集模板】并查集的主要功能在于两个函数，分别是合并操作`Union()`和查找操作`findFather()`

   并查集基础形态：`int[] nums` + `Union()` + `findFather()`

   并查集高级形态：`HashMap` + `Union()` + `findFather()`

   > 例题：给定一个二维数组`M`，如果`M[i][j] = 1`，代表`i`与`j`之间同属一个小组，否则`M[i][j] = 0`，小组成员之间具有传递性，问给定的二维数组中有多少个小组？

   ```java
   // 基本模板
   public int findGroup(int[][] M){
       int[] fathers = new int[M.length];
       for(int i = 0; i < fathers.length; i++){
           fathers[i] = i;
       }
       int count = M.length;
       for (int i = 0; i < M.length; i++){
           for (int j = i + 1; j < M.length; j++){
               if (M[i][j] == 1 & union(fathers, i, j)){
                   count--;
               }
           }
       }
       return count;
   }
   
   private int findFather(int[] fathers, int i){
       if(fathers[i] != i){
           fathers[i] = findFather(fathers, fathers[i]);
       }
       return fathers[i];
       // 必须是fathers[i],不能是i,因为fathers[i]被改写了
   }
   
   // 该函数的作用在于，将两个元素相连，或者是检测两个元素是否已经相连
   private boolean union(int[] fathers, int i, int j){
       int fatherOfI = findFather(fathers, i);
       int fatherOfJ = findFather(fathers, j);
       if (fatherOfI != fatherOfJ){
           fathers[fatherOfI] = fatherOfJ;
           // true表示原来没有相连，但是现在已经相连了
           return true;
       }
       // false表示已经相连了，不用再相连或检查遍历了
       return false;
   }
   ```


5. ACM并查集模板

    - 朴素并查集

   ```java
   // 初始化并查集
   int[] fathers = new int[N];
   for(int i = 0; i < N; i++){
       fathers[i] = i;
   }
   // 找父节点的find操作
   public int find(int x){
       if (fathers[x] != x){
           fathers[x] = find(fathers[x]);
   	}
       return fathers[x];
   }
   // 合并的Union操作，将a和b集合合并
   fathers[find(a)] = find(b);
   ```

    - 防退化并查集

      ```java
      
      ```



- 维护`size()`的并查集

  ```java
  // 初始化并查集，只有祖宗节点的size值才有意义，表示祖宗节点所在的集合中点的数量
  int[] fathers = new int[N];
  int[] size = new int[N];
  for (int i = 0; i < N; i++){
      fathers[i] = i;
      size[i] = 1;
  }
  // find函数可以轻松找到父节点
  public int find(int x){
      if (fathers[x] != x){
          fathers[x] = find(fathers[x]);
      }
      return fathers[x];
  }
  // 合并a和b所在的两个集合
  size[find(b)] += size[find(a)];
  fathers[find(a)] = find(b);
  // 查询某个点所在集合内元素的个数
  public int getNumbers(int a){
      return size[find(a)];
  }
  ```

- 维护到祖宗节点距离的并查集

  ```java
  // 初始化并查集
  int[] fathers = new int[N];
  int[] distance = new int[N];
  for (int i = 0; i < N; i++){
      fathers[i] = i;
      distance[i] = 0;
  }
  
  // 合并a和b所在的两个集合
  fathers[find(a)] = find(b);
  distance[find(a)] = distance; // 根据具体问题初始化find(a)的偏移量
  ```

-

6. 高级并查集模板

