# 分布式主键生成解决方案

## 一、技术层面
### （一）数据库层面
1. 单库+单表 场景
   1. 单库单表场景下，最简单的就是数据库的自增机制
   2. 自增机制的缺点就是与表的字段强相关，也就是说一个库的一个表，具有一个自增的主键
2. 单库+多表 场景
   1. 单库多表场景下，可以考虑采用sequence机制
   2. `sequence`机制介绍
      1. `sequence`是一个独立的数据库对象，它用于生成全局唯一的数字序列，可被多表、多列共享
      2. 与自增的机制完全不同，它可以保证整个数据库中所有记录的唯一性
      3. `sequence`机制的使用上，包含下列几个参数：起始值、步长、最大值、最小值、是否循环、是否包含缓存
         1. 是否循环：到达最大值或者最小值之后是否允许重新循环
         2. 是否包含缓存：缓存中预存了一些生成好的主键id，一般是20个，如果这些没有用完就关闭数据库，没有使用的就丢失了，所以使用缓存的时候不能保证序列是强连续的
      4. `sequence`机制原理
         1. 【缓存】`sequence`配置缓存：每次会在内存中预先分配20个id，用完再分配
            1. Oracle、MySQL：使用cache后没用完数据库崩溃，序列值会跳跃
            2. PostgreSQL：WAL机制（预写机制），崩溃后可以恢复保证连续性
         2. 【预分配】缓存中每次预先分配一些待使用的id
         3. 【独立维护】`sequence`在内存级别维护一个值，而不是将每次要生成的id直接写入表中
         4. 【原子性】通过锁机制，多线程下也保持正确
   3. `sequence`机制保证了同一个数据库下多个表之间（比如修改单据id + 取消单据id + 咨询单据id）之间的id唯一性
3. 多库 场景
   1. 必须依赖下面的中间件或者算法层面来保证唯一性了

### （二）中间件层面
1. 使用Redis的原子操作来实现
2. Redis天然具有快、自增的功能

### （三）算法层面
1. 雪花算法
   1. 基本内容：雪花算法由Twitter开源，其核心思想是通过一定的位运算，将时间戳、机器ID和序列号组合成一个64位的长整型ID。具体结构如下：
      1. 时间戳（41位）：记录当前时间与特定起始时间的差值，单位通常为毫秒。 
      2. 机器ID（10位）：支持部署最多1024个节点（包括机器和数据中心）。 
      3. 序列号（12位）：支持同一毫秒内生成最多4096个ID。
      ```bash
      | 1 位符号位 | 41 位时间戳 | 10 位机器ID | 12 位序列号 |
      ```
   2. 最大支持并发量
      1. 标准雪花算法的理论上限是4096qps/ms，或者是400w/s
      2. 若当前时间戳的序列空间已耗尽，会自旋等待下一个时间戳。
   3. 时钟回拨问题（雪花算法高度依赖时间，如果时间因为某些情况出现了异常，会导致出现id重复，也就是时钟回拨问题）
      1. 解决方案1：记录上一次生成ID的时间戳，如果对比两次后发现倒退，则拒绝生成或者等待时间追上
         1. 美团leaf架构：如果回拨的时间较短，等待时间追上后，再进行生成
         2. 百度UID生成：回拨后直接抛出异常
         3. 携程IDGen生成：记录上一次使用的时间戳，若发现当前时间戳小于上次时间戳，则基于上次时间戳生成ID，序列号用尽后再拒绝请求
      2. 解决方案2：Butterfly架构，使用逻辑时钟
         1. 逻辑时钟：进程启动时间作为当前的逻辑起始时间，不再依赖真实的时间而是基于逻辑时间自增
         2. 序列号与时间戳联合自增：当序列号用满之后，逻辑时间戳+1，序列号归零
         3. 预生成id应对突发流量
2. UUID通用唯一识别码（Universally Unique Identifier），利用当前日期和时间、时钟序列、以太网MAC地址等信息组合形成编号，形如“550e8400-e29b-41d4-a716-446655440000”，能够保证在同一时空的所有机器中唯一。UUID是一种构建标准，微软的GUID是其最广泛的一种应用
   1. 优点：1）客户端本地生成，效率高；2）不存在扩展性问题。
   2. 缺点：1）存储开销大，每个ID至少需要16字节空间；2）字符型ID，查询效率低；3）乱序，无法满足趋势递增。
   3. UUID简介
      1. UUID是一个128位长的标识符，16字节，可以转换为32个16进制字符的组合`4a4c96b0-90cd-43f0-83d7-7b438955ca89`
         ```txt
         字节表示--纯2进制表示
         | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 |
         | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 |
         | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 |
         | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 |
         字节表示
         | 0xAB | 0xAB | 0xAB | 0xAB | 
         | 0xAB | 0xAB | 0xAB | 0xAB | 
         | 0xAB | 0xAB | 0xAB | 0xAB | 
         | 0xAB | 0xAB | 0xAB | 0xAB | 
         16进制字符表示--纯二进制表示
         | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 |
         | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 |
         | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 |
         | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 |
         16进制字符表示
         | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |
         | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |
         | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |
         | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |
         ```
      2. UUID结构

      |            字段             |   数据类型   | 字节位置  |         备注          |
      |:-------------------------:|:--------:|:-----:|:-------------------:|
      |         time_low          | 无符号32位整数 |  0-3  |       时间戳的低位        | 
      |         time_mid          | 无符号36位整数 |  4-5  |       时间戳的中位        | 
      |    time_hi_and_version    | 无符号16位整数 |  6-7  | 时间戳的高位与版本号，前四位代表版本号 | 
      | clock_seq_hi_and_reserved | 无符号8位整数  |   8   |     时钟序列高位与保留位      | 
      |       clock_seq_low       | 无符号8位整数  |   9   |        时钟的低位        | 
      |           node            | 无符号48位整数 | 10-15 |     空间上唯一的节点标识符     | 

      ```txt
         // 代表十位数字
         0                   1                   2                   3
         // 代表个位数字
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                          time_low                             |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |       time_mid                |         time_hi_and_version   |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                         node (2-5)                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ```
         - 
      
   4. UUID是怎样保证唯一性的？
3. 

## 二、业务层面



参考文档
1. https://cloud.tencent.com/developer/article/2457482
2. SEATA：https://seata.apache.org/zh-cn/blog/seata-analysis-UUID-generator/
3. https://blog.csdn.net/qq_37679639/article/details/146876485
4. UUID官方文档（或参考doc文件夹）：https://www.rfc-editor.org/rfc/rfc4122#section-4.1.2 
5. UUID说明：https://blog.csdn.net/u012397879/article/details/136999310
6. 
