# Redis的续期机制


## 一、Redis的续期机制
1. 使用Redis作为分布式锁的存储时，如果一个任务需要长时间的执行，在这段时间内锁会过期，那么就需要一种机制来自动延长锁的有效期，也就是续期。
2. 一般有以下方案：
   - Lua脚本：检查锁是否仍然属于当前的持有者 + 适当延长
   - 看门狗机制（开启一个新的线程或者定时器来实现）：开启一个后台线程，每隔10s会进行一次检查，如果客户端还持有锁的key，那就不断的延长锁key的生存时间。
     - 例如设置的过期时间是30s，过了10s后发现线程还是持有锁，那就重新设置为30s
   - Redisson客户端：可以自动续期，使用了看门狗的机制
3. STW导致的锁过期问题：
   - 问题：当JVM在STW中，会导致缩短业务的实际执行时间，而锁又不会自动被续期，导致A线程的某一个业务没有被执行完毕就结束了，释放了锁；其他线程获取到了锁，执行完毕后，A线程重新执行，出现了问题。
   - 解决方案：版本号机制 or 看门狗机制
     - 版本号：CAS乐观锁，最后一步执行的时候看一下Redis的版本号，如果不一致，禁止执行
4. 

## 二、Redis的数据过期清除策略(key过期了怎么处理)
1. 抛开Redis本身不谈，正常对key作过期删除，可以采用的方案
   1. 立即删除：设置键的过期时间的同时开启一个定时器，到时间后进行删除。
      1. 优点：及时性非常好，对内存空间也比较友好
      2. 缺点：对CPU并不友好
   2. 惰性删除：数据到达过期时间不做处理，等下次访问的时候进行判断，过期就删除
      1. 优点：CPU友好
      2. 缺点：内存不友好
   3. 定期删除：每隔一段时间自动扫描
      - 一种立即删除和惰性删除的中间态
2. Redis中的数据过期清除策略（定时 + 惰性）
   - Redis默认每秒会进行10次过期扫描，从设定了过期时间的key中随机找20个
   - 删除其中过期的key，如果发现比例超过了1/4，就重复上一步
3. 按照Redis的过期策略，如果在某一时刻中大量的key过期，就会导致上面的循环次数变多，会严重影响读写性能，因此要尽量避免大规模同一时间的key过期。

## 三、缓存淘汰策略(内存不够的时候怎么处理)
1. 第一类 不处理，等报错(默认的配置)
   1. noeviction 发现内存不够时，不删除key，执行写入命令时直接返回错误信息。（Redis默认的配置就是noeviction）
2. 第二类 从所有结果集中的key中挑选，进行淘汰
   1. allkeys-random 就是从所有的key中随机挑选key，进行淘汰
   2. allkeys-lru 就是从所有的key中挑选最近使用时间距离现在最远的key，进行淘汰
   3. allkeys-lfu 就是从所有的key中挑选使用频率最低的key，进行淘汰。（这是Redis 4.0版本后新增的策略）
3. 第三类 从设置了过期时间的key中挑选，进行淘汰——这种就是从设置了expires过期时间的结果集中选出一部分key淘汰，挑选的算法有：
   1. volatile-random 从设置了过期时间的结果集中随机挑选key删除。
   2. volatile-lru 从设置了过期时间的结果集中挑选上次使用时间距离现在最久的key开始删除
   3. volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除（也就是从那些快要过期的key中先删除）
   4. volatile-lfu 从过期时间的结果集中选择使用频率最低的key开始删除（这是Redis 4.0版本后新增的策略）

参考资料：
1. https://blog.csdn.net/qq1353424111/article/details/108659697
2. https://blog.csdn.net/Changxing_J/article/details/134586089