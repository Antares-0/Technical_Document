# Go特性

## 一、defer关键字
1. defer关键字的主要作用就是“延迟执行”，主要用于资源回收、链接关闭、异常处理、日志记录等常用场景
2. 使用方法：`defer func()`
   ```go
   file := open()
   defer file.close()
   ```
3. defer在压入栈的时候，对应的值就已经确定了，后面的代码不会影响
4. 原理：defer关键字描述的函数会在return语句执行前被执行，每个defer语句按照自然逻辑会被压入栈中，执行时从栈中依次取出函数进行调用
   - 执行顺序：按照代码顺序反向，发生panic的时候同理，跳出当前代码块之前，defer会被执行
     ```go
     func main() {
         i := test()
         fmt.Println(i)
         // 3 2 1 0
     }
     func test() int {
         defer fmt.Println("1")
         defer fmt.Println("2")
         fmt.Println("3")
         return 0
     }
     ```
   - defer中影响return
     - 第一种情况，命名返回值，会影响return最终的值
     - 第二种情况，无命名返回值，不会影响
       ```go
       func main() {
           fmt.Println("getAns")
           fmt.Println(getAns(1))
           fmt.Println("getAnsReturn")
           fmt.Println(getAnsReturn(1))
       }
  
       func getAns(a int) int {
           fmt.Println("getAns Inner", a)
           defer func(num int) {
               a = a * 2
               fmt.Println("getAns defer Inner", a)
           }(a)
           return a
       }
  
       func getAnsReturn(a int) (b int) {
           fmt.Println("getAnsReturn Inner", a)
           defer func(p int) {
               b = p * 2
               fmt.Println("getAnsReturn defer Inner", b)
           }(a)
           return
       }
       // getAns
       // getAns Inner 1
       // getAns defer Inner 2
       // 1
       // getAnsReturn
       // getAnsReturn Inner 1
       // getAnsReturn defer Inner 2
       // 2
       ```
     - defer函数的参数值确定是在<font color='yellow'>传入的时候就计算完毕</font>，而不是在执行时，相当于是把函数所需要的变量都压入栈中，所有的值都是在顺序执行时就确定好的
       ```go
       func main() {
           fmt.Println(test())
       }
       
       func test() int {
           i := 0
           defer func(a int) {
               fmt.Println("deferIn")
               fmt.Println(a)
               fmt.Println("deferOut")
           } (i) // 表示defer函数的入参
           i++
           return i
       }
       // deferIn
       // 0
       // deferOut
       // 1
       ```
5. defer实战：一个用于记录函数执行时间的小方法
   ```go
   func main() {
       process()
   }

   func process() {
       // 注意最后这个小括号非常重要
       // 代码解析：运行到这里的时候，编译器需要先执行 getFuncExecuteTime("myFunctionName") 方法获取对应的函数，也就是会开启now:=time.Now()
       // 代码解析：获取到最后一个函数的时候，将函数的所有参数压入defer堆栈
       defer getFuncExecuteTime("myFunctionName")()
       time.Sleep(3 * time.Second)
   }

   // 表示接受string输出func
   func getFuncExecuteTime(myFunctionName string) func() {
       now := time.Now()
       fmt.Println("Now: ", now)
       return func() {
           fmt.Println(myFunctionName, "execute time is", time.Since(now))
       }
   }
   ```

## 二、类型推断(常量推断为例)
1. 定义：类型推断是编程语言在变异时自动解释表达式中数据类型的能力；使用得当的话会提高代码的易读性。
2. 使用：使用`:=`触发go的类型推断，或者省略类型信息来实现
   ```go
   var a int = 10
   var a = 10
   a := 10
   ```
3. 编译原理：词法解析 -- 语法分析 -- 抽象语法树构建 -- 类型检查 -- 中间代码 -- 代码优化 -- 生成机器码
    - 词法解析与语法分析阶段
       - 赋值语句右边的常量解析为一个未定义的类型
       - 逐个读取该常量的UTF8编码格式的字符串，字符串的首字符是`"`，数字的首字符是`0-9`，小数包含`.`
       - 简单来说，类型推断的第一步就是判断赋值语句右边的常量是个什么类型
    - 抽象语法树生成与类型检查
       - AST(Abstract Syntax Tree)阶段，通过`math/big.Int`或者`math/big.Float`进行高精度存储
       - 类型检查阶段，高精度存储的部分没有改变，但是通过标志标识了该变量是`int`类型
       - SSA(Static Single Assignment)阶段，将`int`类型转换为`int64`
4. 一句话结论：常量的类型推断是根据等号右边值的格式确定的，<font color='yellow'>字符串的首字符是`"`，数字的首字符是`0-9`，小数包含`.`</font>

## 三、命名返回值
1. go支持在方法上声明变量，并获取返回值的写法，方法上的返回变量相当于声明局部变量
   ```go
   func sumReturn(a int, b int) sum int {
       // sum变量已经在返回值中声明了
       sum = a + b
       // 直接使用return
       return 
   }
   // 等价于
   func sumNormal(a int, b int) int {
       sum := a + b
       return sum
   }
   ```
2. 为什么会有命名返回值的做法？名义上是更直观，代码更优雅
   - 有命名返回值的执行原理：
     - 声明初始化：每一个命名的返回值会声明为一个局部变量，并根据变量类型初始化为响应的0值
     - 声明赋值：在执行完全部的代码逻辑之后<font color='yellow'>（包括defer）</font>，将该变量返回给外部方法
   - 命名返回值与无命名返回值的差异：命名返回值会被defer的逻辑影响，而无命名返回值不会
     ```go
     func main() {
         fmt.Println("getAns")
         fmt.Println(getAns(1))
         fmt.Println("getAnsReturn")
         fmt.Println(getAnsReturn(1))
     }
 
     func getAns(a int) int {
         fmt.Println("getAns Inner", a)
         defer func(num int) {
             a = a * 2
             fmt.Println("getAns defer Inner", a)
         }(a)
         return a
     }
 
     func getAnsReturn(a int) (b int) {
         fmt.Println("getAnsReturn Inner", a)
         defer func(p int) {
             b = p * 2
             fmt.Println("getAnsReturn defer Inner", b)
         }(a)
         return
     }
     // getAns
     // getAns Inner 1
     // getAns defer Inner 2
     // 1
     // getAnsReturn
     // getAnsReturn Inner 1
     // getAnsReturn defer Inner 2
     // 2
     ```
     
## 四、可见性问题
1. 变量可见性问题1：if中的变量对应着else中也可见
   ```go
   if f, err := os.Open(fname); err != nil {
       return err
   } else {
       // 注意，f和err在这里是可见的！！
       f.Stat()
   }
   ```
2. 变量可见性问题2：一个隐藏的bug
   - go语言环境下，这个问题是这样的：局部变量pwd没有被使用，全局变量也没有被赋值，因为init函数的pwd与全局的pwd是两个变量
     ```go
     var pwd string
     func init() {
         pwd, err := os.Getwd() // 编译错误，程序发现了没有使用的pwd变量
         if err != nil {
             log.Fatalf("... %v", err)
         }
         // 如果多了下面这行日志，问题就会非常隐蔽了，这时候编译不会报错，因为后面使用到了pwd
         // log.Printf("%s", pwd)
     }
     // 出现问题的原因在于，init函数内部定义了自己的pwd，当init方法内部需要检查pwd有没有用到的时候，编译器报错
     ```
   - go语言环境下，修复这个问题的简单办法：
     ```go
     var pwd string
     func init() {
         var err error
         // 注意到这里是赋值语句，不是声明语句，这样全局变量就被赋值了
         pwd, err = os.Getwd()
         if err != nil {
             log.Fatalf("%v", err)
         }
     }
     ```
   - Java语言环境下，这个问题是这样的
     ```java
     public class Student {
         private String name;
         public Student(String name) {
             // 错误
             name = name;
             // 应当是 this.name = name;
         }
     }
     ```

## 五、switch
1. 同一个case可以有多个值
2. 不需要使用break，default不是必须的，但是开发中建议有兜底逻辑
3. 【比较奇怪的用法，其他语言不支持】switch可以不使用表达式，相当于`if - else`来使用
   ```go
   var score int32 = 34
   swicth {
      case score > 1 :
         fmt.Println("1")
      case score > 10 && score < 70 :
         fmt.Println("2")
      default :
         fmt.Println("3")
   }
   ```
4. `switch`后可以直接声明一个变量，使用分号结束，但是不推荐
   ```go
   switch score := 90; { // 注意使用分号
      case score > 1 :
         fmt.Println("1")
      case score > 10 && score < 70 :
         fmt.Println("2")
      default :
         fmt.Println("3")
   }
   ```
5. switch的case中不能使用重复的值
   ```go
   var n2 int32 = 5
   switch n1 {
       case 5, 10 :
           fmt.Println("5")
       // case 5 : 错误，编译器不通过
       case n2 : // 可以骗过编译器
           fmt.Println("kk")
       default :
           fmt.Println("error")
   }
   ```
6. switch可以搭配fallthrough，实现穿透，但还是只能穿透一层，不推荐使用，推荐使用在case上直接写多个值
   ```go
   switch score := 90; { // 注意使用分号
      case score > 1 :
         fmt.Println("1")
         fallthrough // 只能穿透一层
      case score > 10 && score < 70 :
         fmt.Println("2")
      default :
         fmt.Println("3")
   }
   ```
7. switch用于类型判断
   ```go
   var x interface{}
   x = "10"
   switch t := x.(type) {
       case nil:
           fmt.Println("nil")
       case string:
           fmt.Println("string", t)
       default:
           fmt.Printf("%T\n", t)
   }
   ```

## 六、包名与文件夹名称
1. 包名应当与文件夹名称保持一致，如果不一致，import中应当是实体文件夹，代码中应该是包名
   ```go
   // | -- demo
   package tool
   func Do() {
   }
   
   // 文件夹名为demo
   // package声明为tool
   import "utils"
   func main(){
       tool.Do()
   }
   ```
2. 包的引入模式
   - Go Modules 模式（推荐，Go 1.11+）：从当前项目的 go.mod 文件定义的模块路径查找。若本地未缓存，会从 go.mod 中指定的仓库下载并缓存到 `$GOPATH/pkg/mod`。
   - GOPATH 模式（传统模式）：从 `$GOPATH/src/`包路径 下查找。若找不到，会尝试从网络拉取（需包路径是可访问的仓库地址）。
3. 包引入的方法
   - 绝对路径引入（推荐）
     ```go
     import "github.com/yourname/project/utils"
     ```
   - 相对路径引入（不推荐）：从当前文件出发，在大型项目中会混乱，不能跨模块使用
     ```go
     import "./tools"    // 导入同一目录下的 tools 包
     import "../common"  // 导入上级目录下的 common 包
     ```
4. 匿名导入：匿名导入会自动执行`init()`方法，哪怕不使用包中的内容，都会自动执行init方法
   ```go
   import _ "db"    // 匿名导入
   ```

## 七、特殊语法
1. go支持自增自减，但是只能独立使用，自增符号只能写在前面
   ```go
   var i int64 = 0
   // right
   i++
   // wrong
   if i++ > 1 {
   }
   ```
2. go语言是一行一行编译的，不能将语句在同一行写；但是如果你手动加了分号，也还是可以的
   ```go
   // 是ok的
   fmt.Println("aaa"); fmt.Println("aaa")
   ```
3. 没有使用的变量和没有使用的`import`会导致编译不通过，这一点与其他的语言存在明显差异

## 八、for循环与goto跳转
1. 基础for循环与增强for循环对字符串的遍历差异
   - 基础for循环，按照字节遍历，可以通过改成`rune[](str)`解决
   ```go
   // 基础for循环，按照字节遍历
   str := "hello, 世界"
   for i := 0; i < len(str); i++ {
       fmt.Printf("index = %d, val = %c \n", i, str[i])
   }
   // index = 0, val = h 
   // index = 1, val = e
   // index = 2, val = l
   // index = 3, val = l
   // index = 4, val = o
   // index = 5, val = ,
   // index = 6, val =   
   // index = 7, val = ä
   // index = 8, val = ¸
   // index = 9, val = 
   // index = 10, val = ç
   // index = 11, val = 
   // index = 12, val = 
   ```
   ```go
   str := "hello, 世界"
   str2 := []rune(str)
   for i := 0; i < len(str2); i++ {
       fmt.Printf("index = %d, val = %c \n", i, str2[i])
   }
   // index = 0, val = h 
   // index = 1, val = e
   // index = 2, val = l
   // index = 3, val = l
   // index = 4, val = o
   // index = 5, val = ,
   // index = 6, val =   
   // index = 7, val = 世
   // index = 8, val = 界
   ```
   - 增强for循环，按照字符遍历
   ```go
   
   // 增强for循环，按照字符遍历
   for index, char := range str {
       fmt.Printf("index = %d, val = %c \n", index, char)
   }
   // index = 0, val = h
   // index = 1, val = e
   // index = 2, val = l
   // index = 3, val = l
   // index = 4, val = o
   // index = 5, val = ,
   // index = 6, val =   
   // index = 7, val = 世
   // index = 10, val = 界
   ```
2. 实现while和do..while
   - while
   ```go
   for {
       if () {
           break
       }
       do()
   }
   ```
   - do..while
   ```go
   for {
       do()
       if () {
           break
       }
   }
   ```
3. 支持直接跳出最外层循环和继续最外层循环
   ```go
   out: for i := 0; i < 100 ; i++ {
       for j := 0; j < 10; j++ {
           if j > 8 {
               break out
               // continue out
		   }  
	   }
   }
   ```
4. `goto`语句，搭配标签使用，但是不建议用
   ```go
   	var p int = 32
	if p == 32 {
		goto label
	} else {
		fmt.Printf("else over")
	}
	fmt.Printf("before over")
    label: fmt.Printf("over")
   ```

## 九、函数
1. 函数可以作为参数进行传递
   ```go
   func main() {
       // 调用函数
       ans := do(getSum, 1, 2)
       fmt.Println(ans)
   }

   // 定义函数
   func getSum(a int, b int) int {
       return a + b
   }

   // 定义函数作为参数的函数
   func do(function func(int, int) int , a int , b int) int {
       return function(a, b)
   }
   ```
2. go支持可变参数
   ```go
   func getSumAll(args ...int) int {
	   sum := 0;
	   for i := 0; i < len(args); i++ {
		   sum += args[i]
	   }
	   return sum
   }
   ```
3. init函数，相当于java的静态代码块的static，java中的static代码块
   - init函数可以存在多个同名的函数，会按照定义顺序进行初始化
   - go的init函数属于包级别，当使用到了这个包的时候，下面所有的init函数会自动执行
   - java的static属于类级别，仅仅作用于当前类，如果这个类没有被加载，那就不会被使用
   - init函数执行的时机：全局变量初始化 -- init函数 -- main函数
   ```go
   import (
       _ "utils" // (里面有一个init函数打印语句)
   )
   var start = getStart()

   func getStart() int {
	   fmt.Println("getStart method")
	   return 10
   }

   func init() {
       fmt.Println("init method, start now is :", start)
   }

   func main() {
       fmt.Println("main method, start now is :", start)
   }
   // utils的init
   // getStart method
   // init method, start now is : 10
   // main method, start now is : 10
   ```
   - a.go引入了b.go，先执行b的全局变量初始化和init，然后是a的全局变量和初始化，import的是最先执行的
4. 匿名函数与闭包
   - 写法
   ```go
   func main() {
       a := func(a int, b int) int {
		   return a + b
	   }(1, 2)
	   fmt.Println(a)
       b := func(a int, b int) int {
		   return a + b
	   }
       res := b(10, 20)
       fmt.Println(res)
   }
   ```
   - 闭包：一个函数和与其相关的引用环境组合的一个整体
   ```go
   // 函数和n整体构成闭包，也就是说addUpper自己是个独立的单元，里面包含了n和func
   func AddUpper() func(int) int {
	   var n int = 10
	   return func (a int) int {
		   n = a + n
		   return n
       }
   }
   
   func main() {
       // n被初始化了一次
       f := AddUpper()
       fmt.Println(f(1)) // 11 = 10 + 1
       fmt.Println(f(2)) // 13 = 11 + 2
       fmt.Println(f(3)) // 16 = 13 + 3
   }
   ```

## 十、go的内置函数
1. len，用于计算长度
2. new，为任意类型T分配内存，返回指向T类型零值的指针（*T），只负责分配内存并设置零值，不进行额外初始化，所以一般来说是对基本数据类型使用的
   ```go
   num1 := 10
   fmt.Printf("num1的类型:%T, num1的值:%v, num1的地址:%v \n", num1, num1, &num1)
   
   num2 := new(int)
   fmt.Printf("num2的类型:%T, num2的值:%v, num2的地址:%v，num2指向的值是%v \n", num2, num2, &num2, *num2)
   // 修改num2的值，要使用*num2
   *num2 = 10
   fmt.Printf("num2的类型:%T, num2的值:%v, num2的地址:%v，num2指向的值是%v \n", num2, num2, &num2, *num2)
   
   // num1的类型:int, num1的值:10, num1的地址:0x1400000e0b8 
   // num2的类型:*int, num2的值:0x1400000e0d0, num2的地址:0x14000050040，num2指向的值是0
   // num2的类型:*int, num2的值:0x1400000e0d0, num2的地址:0x14000050040，num2指向的值是10
   ```
   - 使用new出的map进行操作，会报错
   ```go
   s := new(map[string]string)
   (*s)["1"] = "1" // 运行时panic，报错，new仅仅创建了一个指针，这个指针指向的类型被确定，但是map没有初始化，此时指向的值实际上是nil
   ```
   - 使用new出的结构体进行操作，正常
   ```go
   s := new(Student)
   fmt.Printf("类型:%T, 值:%v, 地址:%v，指向的值是%v \n", s, s, &s, *s)
   (*s).name = "ooo"
   fmt.Printf("类型:%T, 值:%v, 地址:%v，指向的值是%v \n", s, s, &s, *s)
   ```
   - 为什么？
   1. map的初始化比struct更复杂，struct是一种实质上的‘值类型’，struct对象通过new后就是可用状态了，而且复制struct和map是完全不同的
      ```go
      // 复制map
      m1 := make(map[int]string)
      m2 := m1 // 实际上仅仅是指针的复制，没有形成完全独立的副本，修改
      m1[1] = "1" // 会影响到m2
      
      // 复制struct
      s1 := Student{name: "Alice", age: 18}
      s2 := s1  // 发生值拷贝：s2 是 s1 的完整副本
      s1.name = "Tom" // 不影响s2
      ```
   2. new仅仅对map做了两件事情
      - 分配一块内存给 *map[string]string 类型的指针（s 本身）。
      - 将指针指向的内容设为map类型的零值（nil）。
   3. map不是简单的内存块，而是由多个部分组成的复杂系统，map的初始化需要以下内容：
      - 哈希表元数据：记录当前 map 大小、容量、哈希种子、负载因子等。
      - 桶数组（buckets）：真正存储键值对的数组，每个桶又包含多个槽位（slot）。
      - 溢出桶：当桶数组满了之后用于扩容的额外存储空间。
      - 指针关联：连接元数据、桶数组、溢出桶的内部指针。   
      这些组件必须正确关联和初始化，map 才能正常工作（比如插入、查询键值对），然而new操作不能实现这一切
3. make，仅用于创建slice、map和chan三种引用类型，返回的是类型本身（不是指针），不仅分配内存，还会初始化这些复杂类型的内部数据结构（如为 slice 分配底层数组并设置长度和容量）









参考资料：
1. defer简介：https://blog.csdn.net/weixin_45925028/article/details/134307405
2. 类型推断：《Go语言底层原理剖析》第三章
3. 