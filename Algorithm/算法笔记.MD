# 算法笔记

----

## 整数

1. 二进制的运算

    - 与运算（&）、或运算（|）、异或运算（^）
    - 右移运算符（>>）、左移运算符（<<）、无符号右移运算符（>>>）
    - 通常除以2可以使用`>>1`代表，位移计算通常更快

2. 计算`num`的二进制形式中`1`的个数，这是一个打表方法，快速统计位运算

   ```java
   // i & (i - 1) 
   public int[] countBits(int num){
       int [] result = new int[num + 1];
       for (int i = 1; i <= num; i++){
           result[i] = result[i & (i-1)] + 1;
       }
   }
   // i / 2
   public int[] countBits(int num){
       int [] result = new int[num + 1];
       for (int i = 1; i <= num; ++i){
           result[i] = result[i >> 1] + (i & 1);
         	// the same as
         	// result[i] = result[i >> 1] + i % 2;
       }
   }
   ```

3. 位运算，统计`num`的二进制写法中`1`的个数

   ```java
   for (int i = 31; i >= 0; i--){
   	ans += (num >> i) & 1;
   }
   ```

4. 特别的数字

   题目：一个数组中，所有的数字都出现了`n`次，只有一个数字出现了`m`次，请找出。

   ```java
   public int singleNumber(int[] nums, int n, int m){
       int [] bitSums = new int[32];
       for (int num : nums){
           for (int i = 0; i <= 31; i++){
               bitSums[i] += (num >> (31 - i)) & 1;
           }
       }
       int result = 0;
       for (int i = 0; i < 32; i++){
           result = (result << 1) + bitSums[i] % n;
       }
       return result / m;
   }
   ```

5. 快速幂算法

   ```java
   // 快速幂，基本想法
   // 写的比较冗余，但是比较好理解
   public static long fastGetRes(int num, int pow) {
       int tem = 1;
       int pow_remain = pow;
       while (pow_remain > 0) {
           // 寻找合适的指数次幂
           int pow_log = 1;
           int pow_res = num;
           while (pow_log < pow_remain) {
               pow_log *= 2;
               if (pow_log < pow_remain) {
                   pow_res *= pow_res;
               } else {
                   pow_log /= 2;
                   break;
               }
           }
           tem *= pow_res;
           pow_remain -= pow_log;
       }
       return tem;
   }
   ```

   ```java
   // 快速幂部分
   int getAns(int pow, int num) {
       int ans = 1;
       while (pow > 0) {
           if ((pow & 1) == 1){
               ans *= num;
           }
           num *= num;
           pow = pow >> 1;
       }
       return ans;
   }
   ```

6. 矩阵快速幂`LeetCode Q935`

    - 代码模版

      ```java
      // 快速幂部分
      void getRes(int pow, int[][] num) {
          int[][] ans;
          while (pow > 0) {
              if ((pow & 1) == 1) {
                  ans = getAns(new int[num.length][num[0].length], num);
              }
              num = getAns(num, num);
              pow = pow >> 1;
          }
          return ans;
      }
      ```

      ```java
      // 矩阵计算部分
      private int[][] getAns(int[][] a, int[][] b) {
          int[][] ans = new int[a.length][b[0].length];
          for (int i = 0; i < a.length; i++) {
              for (int j = 0; j < b[0].length; j++) {
                  for (int k = 0; k < b.length; k++) {
                      ans[i][j] += a[i][k] * b[k][j];
                  }
              }
          }
          return ans;
      }
      ```

    - 应用范围

      - 总纲

        - 分析问题定义`base`和`A`
        - 矩阵快速幂求解

      - 兔子数列快速计算（问题：求斐波那契额数列的第`n`项，要求对`1e9 + 7`取余，`n < 2^63`

        - 问题分析：首先不可能进行递归或者计算，`n`太大；将问题转换为矩阵的形式，构建一个初始矩阵`A`和一个转移矩阵`base`，使得`A * base = B`，`B`就是最终的计算结果，我们知道`f(n - 1) * 1 + f(n - 2) * 1 = f(n)`，`f(n - 1) * 1 + f(n - 2) * 0 = f(n - 1)`。于是有：
          $$
          A = 
          \begin{bmatrix}
              1 & 1  \\
          \end{bmatrix} \\
          
          base = 
          \begin{bmatrix}
              1 & 1  \\
              1 & 0  \\
          \end{bmatrix} \\
          
          B = A * {base}^{n - 2}
          $$
          
        - 代码
        
          ```java
          public static void main(String[] args) {
              // 1 1 2 3 5 8 13 21 34
              getRes(6);
          }
          
          // 快速幂部分
          public static void getRes(int n) {
              int[][] base = {{1, 1}, {1, 0}};
              int[][] ans = {{1, 1}, {1, 1}};
              int[][] a = {{1, 1}};
              while (n > 0) {
                  if ((n & 1) == 1) {
                      ans = getAns(base, ans);
                  }
                  n = n >> 1;
                  base = getAns(base, base);
              }
              System.out.println(getAns(a, ans)[0][0]);
          }
          
          // 矩阵计算部分
          public static int[][] getAns(int[][] a, int[][] b) {
              int[][] ans = new int[a.length][b[0].length];
              for (int i = 0; i < a.length; i++) {
                  for (int j = 0; j < b[0].length; j++) {
                      for (int k = 0; k < a[0].length; k++) {
                          ans[i][j] += a[i][k] * b[k][j];
                      }
                  }
              }
              return ans;
          }
          ```
    
7. 判断素数的方法及相关问题

    - 前两种不介绍，遍历到`n`和遍历到`sqrt(x)`不再重复，没有优化价值。

    - `ACM`范围内可代码实现的最优方法——埃氏筛法

      > 算法细节：埃氏筛法相当于一种预处理，提前计算好范围内的所有素数，这样无论数据量多大，出什么样的问题都可以轻松应对。
      >
      > 算法内容：首先将`n`个数写下来，其中2是最小的素数，将表中所有的2的倍数划去，表中剩下的最小的数字就是3，再将所有3的倍数划去，以此类推。每次都遍历得到表中当前最小的数，然后将所有该数的倍数划去......
      >
      > 应用场景：对许多素数进行检测、统计素数出现的次数
      >
      > 时间复杂度：$O(n * log(log n))$

      ```java
      // 预处理，预处理的优势就在于可以应对多次查询而只用O(1)的时间复杂度
      int n;
      boolean[] log = new boolean[n + 1];
      for (int i = 0; i <= n; i++){
          log[i] = true;
      }
      log[1] = false; // 代表1不是质数
      for (int i = 2; i <= n; i++){
          if (log[i]){
              for (int j = 2 * i; j <= n; j = j + i){
                  log[j] = false;
              }
          }
      }
      // 第一种问法：n以内素数的个数
      int count = 0;
      for (int i = 0; i <= n; i++){
          if (log[i]){
              count++;
          }
      }
      return count;
      // 第二种问法：给定区间[a,b]，求区间内的素数个数
      int count1 = 0;
      for (int i = 0; i <= a; i++){
          if (log[i]){
              count1++;
          }
      }
      int count2 = 0;
      for (int i = 0; i <= b; i++){
          if (log[i]){
              count2++;
          }
      }
      return count2 - count1;
      // 第三种问法：给定n，判断是不是素数
      return log[n];
      ```

    - 孪生素数方法（时间复杂度没有提升，只是会更快一点）

      > 孪生素数的方法基于一个规律：所有的素数要么是`6n + 1`要么是`6n - 1`，比较好证明，分别枚举`6n + 1` 、`6n + 2`、`6n + 3`、`6n + 4`、`6n + 5`就能够发现这个小规律。所以在筛查素数的时候只需要每6个迭代一次。
      >
      > `6n + 1`和`6n - 1`是一对孪生素数。

      ```java
      public boolean isPrime(int num) {
          if (num == 2 || num == 3) {
              return true;
          }
          // 不满足孪生素数规律的一定不是
          if (num % 6 != 1 && num % 6 != 5) {
              return false;
          }
          // 满足孪生素数规律的也不一定是
          int temp = Math.sqrt(num);
          for (int i = 5; i <= temp; i += 6) {
              if (num % i == 0 || num % (i + 2) == 0) {
                  return false;
              }
          }
          // 全部筛过，确定是素数
          return true;
      }
      ```

8. 最大公因数的求法

   最大公因数的求法包括三种算法，分别是更相减损法、辗转相除法、`stein`算法。

   三种算法的基本特点如下：

   | 算法        | 特点                                                       |
   | ----------- | ---------------------------------------------------------- |
   | 更相减损法  | 时间复杂度$$O(n)$$级别，在两个数差距比较大的时候效率尤其差 |
   | 辗转相除法  | 时间复杂度稳定在$$O(logn)$$级别                            |
   | `stein`算法 | 在大数范围内（至少超过`long`的级别）才需要                 |

    - 更相减损法

      > 以较大的数减去较小的数，接着将差与较小的数比较，并用大数减去小数，重复这个操作，直到所得到的减数和差相等为止。

      ```java
      public int gcd(int a, int b) {
          if (a == b){ // 两数相等则终止
              return a;
          } else {
              if (a > b) {
                  a = a - b;
                  return gcd(a,b);
              } else {
                  b = b - a;
                  return gcd(a,b);
              }
          }
      }
      ```

    - 辗转相除法

      > 也称作欧几里得算法，主要借助除法求最大公因数。
      >
      > 其中值得一提的是，求出了最大公因数就可以求出最小公倍数：
      >
      > $最小公倍数 = a * b / gcd(a,b)$

      ```java
      public int gcd(int a, int b){
          // 保证a >= b;
          if (a < b){
              int temp = b;
              b = a;
              a = temp;
          }
          int r = a % b;
          if (r == 0){ // 相除余数为0则终止
              return b;
          } else {
              a = b;
              b = r;
              return gcd(a,b);
          }
      }
      
      // 已经确保 a < b 的一行递归代码版本
      public int gcd(int a. int b){
          return b == 0 ? a : gcd(b, a % b);
      }
      // 已经确保 a < b 的循环版本
      public int gcd(int a, int b){
          while (b != 0){
              int r = b;
              b = a % b;
              a = r;
          }
          return a;
      }
      ```

    - `stein`算法（仅适用于数超大时，这里的示例是`int`）

      > 算法过程：
      >
      > 若`a`和`b`都是偶数，则记录下公约数`2`，然后两个数字都除以`2`
      >
      > 若其中一个数是偶数，则偶数除以`2`。（因为这时候的`2`不可能是公因数了）
      >
      > 如果这两个都是奇数，则$a=|a-b|$，$b=min(a,b)$，继续重复上述过程。

      ```java
      public int gcd_stein(int a, int b){
          int acc = 0;
          while ((a & 1) == 0 && (b & 1) == 0){
              acc++;
              a >>= 1;
              b >>= 1;
          }
          while ((a & 1) == 0) a >>= 1;
          while ((b & 1) == 0) b >>= 1;
          if (a < b) {
              int temp = a;
              int a = b;
              int b = temp;
          }
          while ((a = (a - b) >> 1) != 0){
              while ((a & 1) == 0) a >>= 1;
              if (a < b) {
                  int t = a;
                  a = b;
                  b = t;
              }
          }
      }
      ```

9. 常用的质数：131、131313

----

## 数组

1. 数组最大的好处就是访问元素直观而有效，可以在给定`index`的条件下使用`O(1)`的复杂度就得到元素中的值。

2. 双指针解题

   **反向双指针**：方向相反的双指针通常用来求**排序数组**中的两个数字之和，给定某个数组，先排序，指定一个起始指针和末尾指针，结果大于`target`就向左移动右指针，小于`target`就向右移动左指针。

   **同向双指针**：方向相同的双指针经常用来求**正数数组**中子数组的和或乘积，初始化的时候两个指针`P1`和`P2`都在最左边的同一个起点，如果两个指针之间的数组之和或乘积大于`target`，那么右移`P1`指针，反之移动`P2`指针。

3. 和或乘积为某一固定值的连续子数组问题

    - **正整数**组成的数组，解决连续子数组问题时，不论求和还是求乘积，都可以直接使用双指针的方法。
    - 包含了**负整数和零**的，要先求和或乘积预处理，然后使用`HashMap<Integer,Integer>`记录下这些和或乘积及出现的次数（注意初始的时候要`put(0,1)`）；每次遍历到新数字，先判断有没有满足条件的，再预处理这个数字。

4. 尺取法（数组与双指针的经典结合）

    - 尺取法的基本定义：顾名思义，像尺子一样取一段，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的时候，所以说尺取法是一种高效的枚举区间的方法，是一种技巧，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案，所以要先判断是否可以使用尺取法再进行计算。
    - 尺取法与二分查找

5. 约瑟夫环问题【本质上是找规律的思路，公式是次要的】

   > 问题定义：`m`个人围成一圈，指定一个数字`n`，从第一个人开始报数，每轮报到`n`的选手出局，由下一个人接着从头开始报，求最后剩下的人？
   >
   > $n > 2 且 m > 1$

    - 解法一：模拟法【时间复杂度为$O(m*n)$】

      使用链表或循环队列模拟。

    - 解法二：公式法（迭代循环）

      > 关键是理解推导公式的生成过程：
      >
      > $f(n, m):= $`n`个人报数，每报到`m`的时候杀掉那个人，最终胜利者的编号
      >
      > 递推公式：$f(n,m) = (f(n-1,m) + m) \% n$
      >
      > 推导原理：每杀掉一个人，其实就是把这个数组向前移动了M位。
      >
      > 模拟过程：【11个人杀掉喊3的】
      >
      > 1. 假设我们已经知道11个人时，胜利者的下标位置为6。那下一轮10个人时（也就是刚刚杀掉一个人），胜利者的下标位置为多少？
           >
           >    第一轮结束后胜利者相当于前移了3位，因为前面三个在第一轮遍历中存活下来了。
      >
      > 2. 假设我们已经知道10个人时，胜利者的下标位置为3。那下一轮11个人时，胜利者的下标位置为多少？ （1的逆过程）
           >
           >    $f(11,3) = (f(10,3) + 3) \% 11$
      >
      > 3. 现在改为人数改为N，报到M时，把那个人杀掉，那么数组是怎么移动的？
           >    答：每杀掉一个人，下一个人成为头，相当于把数组向前移动M位。若已知`N-1`个人时，胜利者的下标位置为$f(n−1,m)$，则`N`个人的时候，就是往后移动`M`位，(因为有可能数组越界，超过的部分会被接到头上，所以还要模`N`)。

      ```java
      public int findWinner(int n, int m){
          // n是人数，m是报数
          int p = 0;
          for (int i = 2; i <= n; i++){
              p = (p + m) % i;
          }
          return p; // 根据数组下标或人的编号决定是否 +1 
      }
      ```

      > 特别的，$f(2^n,2) = 1$，2个人、4个人、8个人、16个人杀掉喊2的，1号胜利

6. 蓄水池抽样算法（作用：用时间换空间的一种不常见的做法，起手复杂度就是$O(n)$，因为需要从头到尾遍历。

   - 算法应用：随机取出一个链表的元素（如果是定长数据流的话，可以用哈希，但是不定长的数据流，只能使用蓄水池抽样算法了）

     使用蓄水池抽样算法，就只因为不能全部存下我们需要的所有元素，选择用一个固定大小的蓄水池将元素记录下来。

     大数据流中的随机抽样问题：当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等。

   - 算法描述：从前往后处理每个样本，每个样本成为答案的概率为$1/i$，其中`i`为样本编号（编号从1开始），最终可以确保每个样本成为答案的概率均为`1/n`。简单来说，只要下标从1开始，我们可以使用数组的下标来代表

   - 算法证明：

     假设最终成为答案的样本编号为`k`，那么`k`成为答案的充要条件为在遍历到`k`时被选中并且遍历大于`k`的所有元素时，均没有被选择（不包括`k`）,`n`为数组长度。

   $$
   P(k_{被选择}) = \frac{1}{k} * (1 - \frac{1}{k + 1}) * (1 - \frac{1}{k + 2}) * ... * (1 - \frac{1}{n}) \\
   \frac{1}{k}: k被选择 \\
   (1 - \frac{1}{k + 1}): k + 1没被选择 \\ 
   (1 - \frac{1}{k + 2}): k + 2没被选择 \\ 
   ... \\ 
   (1 - \frac{1}{n}): n没被选择 \\
   $$

   ​		其中首项$1/k$为选中`k`的概率，后面每项分别为编号`[k + 1, n]`的样本不被选择的概率。

   ​	化简得到：
   $$
   P = \frac{1}{k} * \frac{k}{k + 1} *  \frac{k + 1}{k + 2} * ... * \frac{n - 1}{n} = \frac{1}{n}
   $$
   ​	因此，在每一次 `getRandom` 时，从前往后处理每个节点，同时记录当前节点的编号，当处理到节点`k`时，在$[0,k)$区间内进行随机，若随机到结果为`0`（发生概率为$1/k$），则将节点`k`的值存入答案，最后一次覆盖答案的节点即为本次抽样的结果。

    - 代码实现

      ```java
      // LeetCode Q398 
      class Solution {
          // 一个数组 nums = {1,2,2,2,3,3,3,3,3}
          int[] nums;
          Random random;
      
          public Solution(int[] nums) {
              this.nums = nums;
              random = new Random();
          }
          // 从数组中寻找 target = 3 的对象，等概率地返回其下标
          public int pick(int target) {
              // ans表示下标
              int ans = 0;
              for (int i = 0, cnt = 0; i < nums.length; ++i) {
                  if (nums[i] == target) {
                      ++cnt; // 第 cnt 次遇到 target
                      // nextInt(1) 只能输出0
                      // nextInt(2) 可以输出1或者0
                      if (random.nextInt(cnt) == 0) {
                          ans = i;
                      }
                  }
              }
              return ans;
          }
      }
      ```
      
      ```java
      // LeetCode Q382
      // 提供链表的头节点，使用O(1)空间和O(n)时间，随机返回一个下标
      class Solution {
      	ListNode myHead = null;
          Random random = null;
          // 使用列表的头节点初始化对象
          public Solution(ListNode head) {
      		myHead = head;
      		random = new Random();
      	}
      
          // 随机获取一个元素
      	public int getRandom() {
      		int ans = 0;
      		ListNode headNow = myHead;
      		for (int i = 1; headNow != null; headNow = headNow.next){
                  // 需要注意的是，nextInt开始的i需要是1
      			if (random.nextInt(i) == 0){
      				ans = headNow.val;
      			}
                  i++;
              }
      		return ans;
          }
      }
      ```

7. `Knuth`洗牌算法（基于蓄水池抽样算法）

   > 题目：给定一个数组，要求每次将数组中的元素完全打乱，返回的概率完全随机。

   > Knuth洗牌算法：
   >
   > 针对一个有5个元素的数组，`[4, 9, 2, 5, 7]`，从下标`i`开始，将其与`[i, n - 1)`区间内的数字进行随机交换，数学上保证了该算法的正确性
   >
   > > 下标为0的4，有0.2的概率不交换（也就是4与4本身交换），有0.8的概率与后面的数字交换
   > >
   > > 下标为1的9，有0.25的概率不交换，有0.75的概率与后面的数字交换
   > >
   > > ...

   ```java
   // LeetCode Q384 
   class Solution {
       int[] start = null;
       Random random = null;
       public Solution(int[] nums) {
           random = new Random();
           start = nums;
       }
       public int[] reset() {
           return start;
       }
       public int[] shuffle() {
           int[] newAns = start.clone();
           for (int i = 0; i < start.length; i++){
               // 注意，random的nextInt方法的边界是在[0, bound)的
               swap(newAns, i, i + random.nextInt(newAns.length - i));
           }
           return newAns;
       }
       public void swap(int[] nums, int a, int b){
           int n = nums[a];
           int m = nums[b];
           nums[a] = m;
           nums[b] = n;
       }
   }
   ```

8. 求数组中的`Top-K`数字问题

    - 方法一：排序，然后直接取出

      ```java
      // nums是数组，k代表下标
      public int findMid(int[] nums, int k){
          Arrays.sort(nums);
          return nums[k];
      }
      ```

    - 方法二：<font color='red'>**快速选择算法（快选）**</font>

      快速选择算法：从一个给定的集合中，选出第k个大小的数字，或者给出其所在下标。

      > 应用场景：
      >
      > 1. 寻找top-k最大或者最小的元素
      > 2. 中位数
      > 3. 原地排序
      
      快速选择算法的**平均时间复杂度是$O(n)$**，最差情况下的时间复杂度是$$O(n^2)$$
      
      > 快速选择算法的思想：换出去 -- 找 -- 找 -- 换 -- 换回来
      >
      > - 利用快速排序的分治思想，求得待搜索数组按照的主元S[q]（pivot）（主元的选定有好几种方法，这里不详细讨论，可参考快速排序），以主元为界分成左右两个区间
      >
      > - 通过比较主元的位置，判断第K个大小的数在主元左区间？在主元右区间？还是就是主元？（还要注意边界条件的判断，有可能在边界）
      >
      > - 进入子区间递归调用
      
      ```java
      // 快速选择模版[已验证] Q215
      public int findKthLargest(int[] nums, int k) {
          // 第k大的数字，排序后在nums.length - k的位置
          // 最大的数字，排序后在nums.length - 1的位置
          int target = nums.length - k;
          // 本次递归的头
          int start = 0;
          // 本次递归的尾
          int end = nums.length - 1;
          while (true) {
              int pos = quickSelect(nums, start, end);
              if (pos == target) {
                  return nums[target];
              } else if (pos < target) {
                  start = pos + 1;
              } else {
                  end = pos - 1;
              }
          }
      }
      
      // 快速选择算法
      public int quickSelect(int[] nums, int start, int end) {
          // 随机数，在start和end之间
          int flag = new Random().nextInt(end - start + 1) + start;
          // 将元素交换到前面
          swap(flag, start, nums);
          int mid = nums[start];
          int left = start + 1;
          int right = end;
          while (true) {
              // 从左边找第一个大于的
              while (left <= right && nums[left] < mid) {
                  left++;
              }
              // 从右边找第一个小于的
              while (left <= right && nums[right] > mid) {
                  right--;
              }
              // 超过了，结束
              if (left >= right) {
                  break;
              }
              // left和right交换
              swap(right, left, nums);
              left++;
              right--;
          }
          // 为什么是start与right交换？
          // start的位置现在是主元，right的含义是目前找到的小于主元的第一个元素
          // 因此将start与right交换，保证了主元左边的都是小于主元的，右边还是大于主元的
          swap(right, start, nums);
          return right;
      }
      
      // 交换函数
      public void swap(int a, int b, int[] nums) {
          int i = nums[a];
          nums[a] = nums[b];
          nums[b] = i;
      }
      ```

9. 数组中，元素差的平方和最小，该待求数是平均数；元素差的绝对值和最小，该待求数是中位数。

---

## 字符串

1. `Java`中常用的`String`函数

   | 函数                        | 函数功能                                         |
   | :-------------------------- | ------------------------------------------------ |
   | `charAt`                    | 返回指定下标处的字符                             |
   | `compareto`                 | 按照字典顺序比较两个字符串                       |
   | `equals`                    | 判断两个字符串的长度和内容是否相等，注意不是`==` |
   | `indexOf`                   | 返回字符串中某个字符或子字符串首次出现的下标     |
   | `lastIndexOf`               | 返回字符串中某个字符或子字符串最后出现的下标     |
   | `length`                    | 返回字符串的长度                                 |
   | `split`                     | 将字符串按照指定的分隔符进行分割，返回一个数组   |
   | `substring`                 | 按照下标截取子字符串                             |
   | `toLowerCase / toUpperCase` | 将字符串中的所有字母变为大写或小写               |

    - `java`中的`indexOf API`使用的是暴力匹配算法，能不用尽量别用。

      ```java
      public static int indexOfLatin1Unsafe(byte[] src, int srcCount, byte[] tgt, int tgtCount, int fromIndex) {
          assert fromIndex >= 0;
          assert tgtCount > 0;
          assert tgtCount <= tgt.length;
          assert srcCount >= tgtCount;
          char first = (char)(tgt[0] & 0xff);
          int max = (srcCount - tgtCount);
          for (int i = fromIndex; i <= max; i++) {
              // Look for first character.
              if (getChar(src, i) != first) {
                  while (++i <= max && getChar(src, i) != first);
              }
              // Found first character, now look at the rest of v2
              if (i <= max) {
                  int j = i + 1;
                  int end = j + tgtCount - 1;
                  for (int k = 1;
                       j < end && getChar(src, j) == (tgt[k] & 0xff);
                       j++, k++);
                  if (j == end) {
                      // Found whole string.
                      return i;
                  }
              }
          }
          return -1;
      }
      ```

2. 双指针与字符串：将字符串看作字符的数组，也可以同样使用双指针的思路解决一些问题。

    比如不含重复字符的最长子字符串、包含所有字符的最短字符串问题等等。

3. 对于变位词、重复字符、包含某些特定字符的问题，我们必须想到词频统计。

   词频统计一般有两种实现形式（固定大小的数组或者`HashMap`），如果题目中规定了只包含数字或字符，可以用有限大小的数组来实现词频统计；如果题目中没有规定，那么最好还是使用`HashMap`来实现词频统计。

   ```java
   // 词频统计实现形式——数组实现
   public int[] countChars(String word){
       char[] crr = word.toCharArray();
       int[] count = new int [26]; // 只统计小写字母
       for (int i = 0; i < crr.length; i++){
           count[crr[i] - 'a']++;
       }
       return count;
   }
   // 词频统计实现形式——哈希表实现
   public void countChars(String word){
       char[] crr = word.toCharArray();
       Map<Character, Integer> map = new HashMap<>(); 
       for (int i = 0; i < crr.length; i++){
           map.put(crr[i], map.getOrDefault(crr[i],0) + 1);
       }
   }
   ```

4. 回文字符串问题

    - 回文字符串通俗定义：如果一个字符串正着读或反着读都一样，那么称这个字符串为回文字符串。

    - 基础思路，基本上是$$O(n^2)～O(n^3)$$时间复杂度：

      - **反向双指针思路**：最常用的、最能直接想到的解法就是使用双指针求解，即使用双指针从字符串的两端向中央不断移动。如果枚举所有的字符串，再进行判断，将达到$$O(n^3)$$的时间复杂度。

      - **中心延伸双指针**：还可以从字符串中央开始，逐渐向两边延伸；但是考虑到字符串有奇数长度或偶数长度的，可以使用`i + 1`等价变成奇数长度。

    - `Manacher`算法

      > `Manacher`算法介绍
      >
      > - 预处理，为了避免奇数长度的回文字符串和偶数长度的回文字符串，选择一个在原来的字符串中没有出现的字符，填充在字符串的每个空隙，包括开头和结尾，一般选择`#`。
      >
      >   <font color='yellow'>经过预处理后，在新串中所有回文字符串的长度都将是奇数</font>
      >
      >   ```java
      >   // 原字符串
      >   String t = "txtxtxtxtxtx";
      >   // 更新后的字符串
      >   String T = "#t#x#t#x#t#x#t#x#t#x#t#x#";
      >   // 注意结尾和开头都要加上 #
      >   ```
      >
      > - 辅助指针`longestLocation`，代表之前计算中<font color='yellow'>**最长**</font>回文子串的右端点的最大值
      >
      > - 辅助指针`longestArrayLocation`，代表之前计算中最长回文子串的右端点的最大值对应的中心点下标位置
      >
      >   ```java
      >   // 遍历到 a 时，两个指针的情况
      >   String a = "-----a-----bbbbb"
      >   //               ^ longestArrayLocation = 5
      >   //                    ^ longestLocation = 10
      >   ```
      >
      > - 辅助数组`len[]`数组
      >
      >   `len[]`数组的定义：以字符`T[i]`为中心的最长回文字串的最右字符到`T[i]`的长度，比如以`T[i]`为中心的最长回文字串是`T[l,r]`,那么`Len[i] = r - i + 1`
      >
      >   ```java
      >   String T = "# t # x # t # x # t # x # t # x # t # x # t # x #";
      >   int[] len = 1 2 1 4 1 6 1 8 1 ... 
      >   ```
      >
      >   `len[]`数组的性质：`len[i] - 1`的值，就是原来字符串中，回文字符串的长度。
      >
      >   > 证明：首先在转换得到的字符串`T`中，所有的回文字串的长度都为奇数，那么对于以`T[i]`为中心的最长回文字串，其长度就为`2 * len[i] - 1`。经过观察可知，`T`中所有的回文子串，其中分隔符的数量一定比其他字符的数量多`1`，也就是有`len[i]`个分隔符，剩下`len[i] - 1`个字符来自原字符串，所以该回文串在原字符串中的长度就为`len[i] - 1`。
      >
      >   因此，现在的问题就转化为怎样求解这个数组。
      >
      > - 求解`len[]`
      >
      >   从左到右进行遍历，遍历到`i`的时候，已知目前`longestLocation`和`longestArrayLocation`的位置，
      >
      >   - 第一种情况：`i <= longestLocation`，目前的遍历指针还在最远的回文串覆盖范围之内。
      >
      >     ```java
      >     // --------------- ---------------
      >     //                ^ longestArrayLocation
      >     //                    ^ i        ^ longestLocation
      >     //          j ^   |   ^ i     
      >     //        --j--   | --i--   len[i] = len[j]
      >     ```
      >
      >     由于`longestArrayLocation`对应的字符串已经是回文的了，所以`i`和`j`关于`longestArrayLocation`对称，那么适用于`j`的`len[j]`，对于`len[i]`同样具有参考意义，`i`只需要从`i + len[j] - 1 `的位置开始，继续遍历就可以了，如果更巧合的`i + len[j] < longestLocation`，那就没有必要进行遍历了，`len[i] = len[j]`；如果是很巧合的`i + len[j] >= longestLocation`，那就需要从`longestLocation + 1`进行遍历，并记得更新`longestLocation`和`longestArrayLocation`。
      >
      >   - 第二种情况：`i >= longestLocation`，目前的遍历指针已经超出最远的回文串覆盖之外，这个时候没有办法，只能一个一个遍历，并记得更新`longestLocation`和`longestArrayLocation`
      >
      > - 总结
      >
      >   > 1. 填充字符
      >   > 2. 最长回文字符串最远位置指针 + 最远位置下标指针 + `len[]`
      >   > 3. 从左到右遍历
      >   >    1. `i <= longestLocation`
      >   >       - 如果`i + len[j = 2 * longestArrayLocation - i] < longestLocation`，`len[i] = len[j]`
      >   >       - 从`longestLocation`开始左右遍历，如果可能的话更新指针。
      >   >    2. `i > longestLocation`，只能进行遍历，可能的话更新指针
      >   > 4. 最后过一遍`len[]`，`len[i] - 1`的最大值就是答案。
    
      ```java
      // LeetCode Q5
      // Manacher算法完整实现
      // 求解str中回文串的最大长度
          public static void manacherGetAns(String str) {
              // 预处理
              char[] newStr = new char[str.length() * 2 + 1];
              newStr[0] = '#';
              for (int i = 0; i < str.length(); i++) {
                  newStr[i * 2 + 1] = str.charAt(i);
                  newStr[i * 2 + 2] = '#';
              }
              // 新建len数组
              int[] len = new int[newStr.length];
              // longestLocation & longestArrayLocation都是从-1开始
              int longestLocation = -1;
              int longestArrayLocation = -1;
              for (int i = 0; i < newStr.length; i++) {
                  // 如果 i 在longestlocation的覆盖之内
                  if (i <= longestLocation) {
                      // 如果很巧的，j的回文长度也在longestlocation之内，不需要更新太多
                      if (2 * longestArrayLocation - i >= 0 && len[2 * longestArrayLocation - i] + i < longestLocation) {
                          len[i] = len[2 * longestArrayLocation - i];
                      } else {
                          len[i] = 2 * longestArrayLocation - i >= 0 ? Math.max(len[2 * longestArrayLocation - i] + longestArrayLocation - longestLocation, 1) : 1;
                      }
                  }
      
                  // 中心扩张算法
                  while (i + len[i] < newStr.length && i - len[i] >= 0) {
                      if (newStr[i + len[i]] == newStr[i - len[i]]) {
                          len[i]++;
                      } else {
                          break;
                      }
                  }
      
                  if (len[i] > longestLocation - longestArrayLocation){
                      // 在本代码中，longestLocation是回文串对应的结束位置的下一个位点
                      longestLocation = i + len[i];
                      longestArrayLocation = i;
                  }
              }
              int max = Integer.MIN_VALUE;
              for (int i = 0; i < newStr.length; i++){
                  max = Math.max(len[i] - 1, max);
              }
              // 获取最大长度
              System.out.println(max);
              // 获取回文串
              char[] ans = new char[max * 2 + 1];
              // 由于longestLocation是回文串对应的结束位置的下一个位点，需要收缩位点
              for (int i = longestArrayLocation * 2 - longestLocation + 1; i < longestLocation; i++){
                  ans[i - (longestArrayLocation * 2 - longestLocation + 1)] = newStr[i];
              }
              String replace = new String(ans).replace("#", "");
              System.out.println(replace);
          }
      ```

5. 回文字符串与动态规划结合

6. 字符串匹配算法【需要掌握经典的`KMP`算法】

> 表：总时间复杂度
>
> | 算法         | 匹配时间                   |
   > | ------------ | -------------------------- |
> | 暴力匹配     | $O(n * m)$                 |
> | RK算法       | 最坏$O(n * m)$，最好$O()$  |
> | 有限自动机   | $O(n)$ + $O(m)$            |
> | KMP算法      | $O(n)$ + $O(m)$            |
> | BM算法       | 最坏$O(m*n)$，最好$O(n/m)$ |
> | Sunday算法   | 最坏$O(m*n)$，最好$O(n/m)$ |
> | Horspool算法 |                            |
>
> 表：`n`代表文本长度，`m`代表子串长度。$|\sum|$代表的是字符集的大小。
>
> | 算法                     | 预处理时间  | 匹配时间      |
   > | ------------------------ | ----------- | ------------- |
> | 暴力匹配算法             | $0$         | $O((n-m+1)m)$ |
> | `Rabin-Karp`算法         | $\Theta(m)$ | $O((n-m+1)m)$ |
> | 有限自动机算法           | $O(m *      | \sum          |
> | `Knuth-Morris-Pratt`算法 | $\Theta(m)$ | $\Theta(n)$   |

 - 暴力匹配算法（`Brute Force`）：

   思想：首先将原字符串和子串左端对齐，逐一比较；如果第一个字符不能匹配，则子串向后移动一位继续比较；如果第一个字符匹配，则继续比较后续字符，直至全部匹配。

   ```java
   // 没有什么用的暴力算法
   String text = "texttexttexttext";
   String subString = "tex";
   List<Integer> list = new ArrayList<Integer>();
   for (int i = 0; i <= text.length() - subString.length(); i++){
       if (subString.equals(text.substring(i,i + subString.length()))){
           list.add(i);
       }
   }
   return list;
   ```

 - `RK`算法：

   思想：根据字符串的内容简单计算出一个“哈希值”，比较哈希值来确定字符串是否有可能匹配，如果哈希值同，那么逐个检查；哈希值不同的一定不匹配。算法中比较重要的就是计算哈希值和哈希值的滚动。

   > 字符集大小$d$一般作为基数，或者对于小写字母字符集使用31这个数作为基数更强地避免哈希冲突
   >
   > 子串$P$长度$m$
   >
   > 文本$T$长度$n$
   >
   > 素数$q$——$q$取随机素数，满足$q * d < 2^{31} - 1$即可
   >
   > 子串“哈希值”计算：$p = d^{0} * P[m] + d^{1} * P[m-1] + d^{2} * P[m - 2] +...$
   >
   > > 注意，哈希值也有通过字符简单相加得到的，只不过这种非常容易产生`Hash`冲突，如`abc`、`bac`、`cba`的`Hash`一定相等，会产生无谓损失，使用这种乘法计算的后果就是数据太大，必须要取模运算。
   >
   > 文本“哈希值”计算：$t_{s + 1} = d * (t_{s} - d^(m-1) * T[s + 1]) + T[s + m + 1]$（相当于滑动窗口）

   ```java
   // 代码实现
   String subString = "text";
   String targetString = "texttexttexttext";
   public List<Integer> find(String subString, String targetString){
       int MOD = 524287; // 2^19 - 1，第七个梅森素数 int MOD = (int)Math.pow(2,19) - 1;
       int Character_Set_Size = 26; // 假定是小写字母字符集，共26个，作为基数
       int HashCode_SubString = 0; // 子串的哈希值
       int HashCode_Target = 0; // 文本的哈希值
       int h = (int)(Math.pow(Character_Set_Size, subString.length() - 1) % MOD); // h要提前计算
       for (int i = 0; i < subString.length(); i++){
           HashCode_SubString = (Character_Set_Size * HashCode_SubString + (subString.charAt(i) - 'a')) % MOD;
           HashCode_Target = (Character_Set_Size * HashCode_Target + (targetString.charAt(i) - 'a')) % MOD;
       }
       List<Integer> list = new ArrayList<>();
       for (int i = 0; i <= targetString.length() - subString.length(); i++){
           if (HashCode_Target == HashCode_SubString){
               if (subString.equals(targetString.substring(i,i + subString.length()))){
                   list.add(i);
               }
           }
           if (i < targetString.length() - subString.length()){
               // 要注意越界，如果不加MOD会出现负数
               HashCode_Target = ((Character_Set_Size * (HashCode_Target + MOD - ((targetString.charAt(i) - 'a') * h % MOD)) + 
                                  targetString.charAt(i + subString.length()) - 'a')) % MOD;
           }
       }
       return list;
   }
   ```

 - *有限自动机算法（不常见）：

   > 有限自动机算法先创建一个状态转移自动机，然后以主串作为输入逐次读入数据，不断进行状态转移

   ```mermaid
   graph LR
       A("初始化自动机")
       C("根据自动机进行状态转移")
       D("开始")
       E("结束")
       D-->A
       A-->C
       C-->E
   ```

   ```java
   public List<Integer> StringAutoMachine(String main, String pattern) {
       List<Integer> list = new ArrayList<>();
       HashMap<Integer, HashMap<Character, Integer>> jumpTable = new HashMap<>();
       int Set_size_of_character = 26;
       makeJumpTable(jumpTable,pattern, Set_size_of_character);
       Integer q = 0;
       for (int n = 0; n < main.length(); n++){
           HashMap<Character,Integer> map = jumpTable.get(q);
           int oldState = q;
           q = map.get(main.charAt(n));
           if (q == null){
               return null;
           }
           if (q == pattern.length()){
               list.add(n - pattern.length() + 1);
           }
       }
       return list;
   }
   
   public void makeJumpTable(HashMap<Integer, HashMap<Character, Integer>> jumpTable, String pattern, int Set_size_of_character) {
       for (int q = 0; q <= pattern.length(); q++) {
           for (int k = 0; k < Set_size_of_character; k++) {
               char c = (char) ('a' + k);
               String pq = pattern.substring(0, q) + c; // 在末尾添加一个字符c，表示当前接收到了一个新的字符c
               int nextState = findSuffix(pq, pattern);
               HashMap<Character, Integer> map = jumpTable.getOrDefault(q, new HashMap<>());
               map.put(c, nextState);
               jumpTable.put(q, map);
           }
       }
   }
   
   public int findSuffix(String pq, String pattern) {
       int suffixLen = 0;
       int k = 0;
       while (k < pq.length() && k < pattern.length()) {
           int i = 0;
           for (i = 0; i <= k; i++) {
               if (pq.charAt(pq.length() - 1 - k + i) != pattern.charAt(i)) {
                   break;
               }
           }
           if (i - 1 == k) {
               suffixLen = k + 1;
           }
           k++;
       }
       return suffixLen;
   }
   ```

 - <font color='yellow'>`KMP`算法</font>：

   > KMP算法的核心就是`next`数组的计算。与双指针的思路类似。
   >
   > - 

   ```mermaid
   graph LR
       A("初始化next数组")
       C("从前向后匹配，遇到不匹配根据next数组移动j")
       D("开始")
       E("结束")
       D-->A
       A-->C
       C-->E
   ```

   ```java
   public List<Integer> KMP(String main, String pattern){
       List<Integer> answer = new ArrayList<>();
       int[] next = computeTemporaryArray(pattern);
       int i = 0;
       int j = 0;
       // 注意不是移动i，而是移动j
       while (i < main.length() && j < pattern.length()){
           if (pattern.charAt(j) == main.charAt(i)){
               i++;
               j++;
           } else {
               if (j != 0){
                   j = next[j - 1];
               } else {
                   i++;
               }
           }
           if (j == pattern.length()){
               answer.add(i - j); // 使用i - j计算开始位置
               // 相当于重新开始KMP算法
               i = i - j + 1;
               j = 0;
           }
       }
       return answer;
   }
   // 计算next数组
   public int[] computeTemporaryArray(String pattern){
       int[] next = new int[pattern.length()];
       int i = 1;
       int j = 0;
       while (i < pattern.length()){
           if (pattern.charAt(i) == pattern.charAt(j)){
               next[i] = j + 1;  // 注意是j + 1，而不是next[i - 1] + 1
               i++;
               j++;
           } else {
               if (j != 0){
                   // 这个分支i不变
                   j = next[j - 1];
               } else {
                   next[i] = 0;
                   i++;
               }
           }
       }
       return next;
   }
   ```

 - `BM`算法：（最佳时间复杂度$O(n/m)$，相当于一直在跳跃前进；最差时间复杂度$O(m*n)$，与暴力解法一致，每次只能移动一步）

   > BM的实际运行要优于KMP算法。
   >
   > BM算法的核心是坏字符规则和好后缀规则。
   >
   > 坏字符规则：主串和模式串的匹配顺序是从后往前倒着匹配的，遇到不匹配的字符就标记为坏字符，在`index`数组中查找应当移动的步数。
   >
   > 好后缀规则：从后向前匹配，匹配的字符串标记为好后缀，根据`suffix`和`prefix`数组进行移动。
   >
   > 在两种规则中取最大的移动步数进行移动，直到遍历完成。

   ```mermaid
   graph LR
       A("初始化坏字符index数组")
       B("初始化好后缀suffix数组和prefix数组")
       C("在当前位置的基础上根据二者较大的值进行移动")
       D("开始")
       E("结束")
       D-->A
       D-->B
       A-->C
       B-->C
       C-->E
   ```

   ```java
   public static final int SIZE_OF_CHARACTER = 256; // 字符集的大小
   
   public List<Integer> Boyer_Moore(String main, String pattern) {
       List<Integer> list = new ArrayList<>();
       int[] index = new int[SIZE_OF_CHARACTER];
       int[] suffix = new int[pattern.length()];
       boolean[] prefix = new boolean[pattern.length()];
       // 两个预处理
       getSuffix_getPrefix(pattern, suffix, prefix);
       getLastIndexOfChar(pattern, index);
       int current_location = 0; // 代表模式串的头在主串的哪个位置
       while (current_location <= main.length() - pattern.length()) {
           // back_fit_location代表的是坏字符的位置，初始化的时候坏字符的位置肯定在最后一个，用一个for循环确定坏字符的位置
           int back_fit_location = pattern.length() - 1;
           for (; back_fit_location >= 0; back_fit_location--) {
               if (main.charAt(current_location + back_fit_location) != pattern.charAt(back_fit_location)) {
                   break;
               }
           }
           // back_fit_location == -1 就代表匹配成功
           if (back_fit_location < 0) {
               list.add(current_location);
               // 匹配成功只前进一步
               current_location++;
           } else {
               int bad_character_move_step = back_fit_location - index[main.charAt(back_fit_location + current_location)];
               int good_suffix_move_step = 0;
               if (back_fit_location < pattern.length() - 1) {
                   good_suffix_move_step = goodSuffixMove(back_fit_location, suffix, prefix);
               }
               current_location += Math.max(bad_character_move_step, good_suffix_move_step);
           }
       }
       return list;
   }
   
   // 预处理pattern字符串，将字符串中最后一个字母的位置存在index数组中
   public void getLastIndexOfChar(String pattern, int[] index) {
       int pattern_len = pattern.length();
       Arrays.fill(index, -1);
       for (int i = 0; i < pattern_len; i++) {
           index[pattern.charAt(i)] = i;
       }
   }
   
   // 好后缀规则计算移动比较费劲
   public int goodSuffixMove(int back_fit_location, int[] suffix, boolean[] prefix) {
       // 好后缀的长度
       int len_of_good_suffix = suffix.length - 1 - back_fit_location;
       // 如果该好后缀在模式串的前面出现过，那么移动距离就应当是back_fit_location - suffix[len_of_good_suffix] + 1
       if (suffix[len_of_good_suffix] != -1) return back_fit_location - suffix[len_of_good_suffix] + 1;
       for (int r = back_fit_location + 2; r < suffix.length - 1; r++) {
           if (prefix[suffix.length - r] == true) {
               return r;
           }
       }
       return suffix.length;
   }
   
   // 预处理pattern字符串，统计有关好后缀的内容，将信息存储在suffix数组和prefix数组中
   public void getSuffix_getPrefix(String pattern, int[] suffix, boolean[] prefix) {
       Arrays.fill(suffix, -1);
       for (int i = 0; i < pattern.length() - 1; i++) {
           int fit_location = i;
           int count = 0;
           while (fit_location >= 0 && pattern.charAt(fit_location) == pattern.charAt(pattern.length() - 1 - count)) {
               fit_location--;
               count++;
               suffix[count] = fit_location + 1; // fit_location + 1表示公共后缀子串在main[0,i]中的起始下标
               // 长度为count的后缀在pattern前面重复的起始位点是 fit_location + 1
           }
           if (fit_location == -1) {
               prefix[count] = true;
           }
       }
   }
   ```

 - `Sunday`算法：

   > Sunday算法与BM算法基本类似，非常不同地是，Sunday算法的字符串匹配是正向的，坏字符的定义是当前匹配区间的下一个。
   >
   > Sunday算法的实际运行要优于BM算法和KMP算法。

   ```mermaid
   graph LR
       A("初始化坏字符index数组")
       C("从前向后匹配，不匹配时查看当前区间的下一个字符")
       B("在模式串中寻找该字符并根据index数组移动")
       D("开始")
       E("结束")
       D-->A
       A-->C
       C-->B
       B-->E
   ```

   ```java
   public List<Integer> Sunday(String main, String pattern) {
       List<Integer> answer = new ArrayList<>();
       int[] index = new int[26]; // 默认小写字符集
       Arrays.fill(index, -1);
       for (int i = 0; i < pattern.length(); i++) {
           index[pattern.charAt(i) - 'a'] = i;
       }
       int currentLocation = 0;
       while (currentLocation <= main.length() - pattern.length()) {
           int fit_location = 0;
           for (; fit_location < pattern.length() && main.charAt(currentLocation + fit_location) == pattern.charAt(fit_location); fit_location++);
           // 说明匹配成功
           if (fit_location == pattern.length()){
               answer.add(currentLocation);
               currentLocation++;
           } else {
               if (currentLocation + pattern.length() >= main.length()){
                   break;
               }
               // 匹配失败
               char flag = main.charAt(currentLocation + pattern.length());
               currentLocation += pattern.length() - index[flag - 'a'];
           }
       }
       return answer;
   }
   ```

 - `Horspool`算法

   > `Horspool`算法与BM算法类似，但是是BM算法的简化版。

   ```mermaid
   graph LR
       A("初始化坏index数组")
       C("从后向前匹配，不匹配时查看当前区间的z字符")
       B("在模式串中寻找该字符并根据index数组移动")
       D("开始")
       E("结束")
       D-->A
       A-->C
       C-->B
       B-->E
   ```
   
   ```java
   public List<Integer> Horspool(String main, String pattern){
       if (main.length() < pattern.length() || main.length() == 0 || pattern.length() == 0){
           return null;
       }
       List<Integer> list = new ArrayList<>();
       int[] index = new int[26];
       Arrays.fill(index, pattern.length());
       for (int i = 0; i < pattern.length() - 1; i++){
           index[pattern.charAt(i) - 'a'] = pattern.length() - i - 1;
       }
       int backFitLocation = pattern.length() - 1;
       while (backFitLocation <= main.length() - 1){
           int k = 0;
           while (k <= pattern.length() - 1 && 
                  pattern.charAt(pattern.length() - 1 - k) == main.charAt(backFitLocation - k)){
               k++;
           }
           if (k == pattern.length()){
               list.add(backFitLocation - pattern.length() + 1);
               backFitLocation++;
           } else {
               backFitLocation += index[main.charAt(backFitLocation) - 'a'];
           }
       }
       return list;
   }
   ```


7. 括号匹配问题





----

## 链表

1. 链表节点的内存分配不是在创建表时就一次性地完成，而是每添加一个节点分配一次内存。

    - 链表经常涉及的代码包括：创建节点、删除节点、插入节点，要熟练掌握。
    - 创建哨兵节点可以省去很多不必要的麻烦。

2. 双指针与链表：双指针思路与链表的结合可以解决非常多的链表问题；主要有两种形式，**快慢双指针**和**前后双指针**。

    - **前后双指针**：【经典案例】删除倒数第`k`个节点

      前指针先走`k + 1`步，当前指针到达末尾时，后指针正好移动到倒数第`k + 1`个节点。

    - **快慢双指针**：【经典案例】判断一个链表中是否包含环，以及环的入口，以及环的长度

      **判环**：快指针每次移动2个节点，慢指针每次移动1个节点，如果有环最后会在环中相遇

      **环的大小**：判断是否存在环后，如果存在环，那么两个指针一定在环中相遇，所以记录下这个环的位置，持续地`.next`，再次遇到这个环时走过的步数就是环的大小。

      **环的入口**：使用双指针一前一后，先移动环的大小个节点，相遇处就是入口节点；或者在判断是否有环以后，可以根据相遇节点作为前指针，后指针在`head`处，相遇处即为环的入口。

3. 双向链表和循环链表，是特殊一些的单向链表，需要注意的是在处理他们的前序节点和后续节点时，必须严格采用删除、新建的模板。

    ```java
    ```

4. 关于反转链表

    - 反转链表

    ```java
    // 最简洁的写法
    public ListNode reverseList(ListNode head){
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode log = cur.next;
            cur.next = pre;
            pre = cur;
            cur = log;
        }
        return pre;
    }
    ```

    

5. 

----

## 哈希表

1. 哈希表的基本知识

   哈希表中插入、删除或查找一个元素只需要`O(1)`的时间复杂度。

   在`java`中，哈希表有两个对应的类型，分别是`HashSet`和`HashMap`

   `HashSet`实际上是`HashMap`实现的，`HashSet`的`value`都是同一个值，一般会是`null`

    - `HashSet`的基本函数

   | 函数         | 函数功能                        |
      | ------------ | ------------------------------- |
   | `add()`      | 在`HashSet`中添加一个元素       |
   | `contains()` | 判断`HashSet`中是否包含一个元素 |
   | `remove()`   | 从`HashSet`中删除一个元素       |
   | `size()`     | 返回`HashSet`中的元素           |

    - `HashMap`的基本函数

   | 函数                                       | 函数功能                                                 |
   | ------------------------------------------ | -------------------------------------------------------- |
   | `containsKey`                              | 判断`HashMap`中是否包含某个键                            |
   | `get`                                      | 如果键存在，返回对应的值，否则返回`null`                 |
   | <font color='yellow'>`getOrDefault`</font> | 如果键存在，返回对应的值，否则返回输入的默认值           |
   | `put`                                      | 如果键不存在，则添加一组键到值的映射，否则修改键对应的值 |
   | <font color='yellow'>`putIfAbsent`</font>  | 当键不存在时添加一组键到值得映射                         |
   | `remove`                                   | 删除某个键                                               |
   | `replace`                                  | 修改某个键对应的值                                       |
   | `size`                                     | 返回`HashMap`中键到值的映射数目                          |

2. 一个[小细节](https://leetcode.cn/problems/repeated-dna-sequences/solutions/1035708/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/)：

   因为`Java`中的`String`的`hashCode`实现是会对字符串进行遍历的，这样哈希计数过程仍与长度有关，而`Integer`的`hashCode`就是该值本身，这是与长度无关的。

   `Java`知识：调用一个字符串的哈希方法`HashCode`的时候，会遍历该字符串。

   ```java
   // Java.String类的HashCode默认方法
   public int hashCode() {
       // 不使用String(String str)这种构造方法时，h = 0
       // 使用String(String str)这种构造方法时，h会被初始化为str的hashCode()
       int h = hash;
       if (h == 0 && value.length > 0) {
           // value是字符串的char数组
           char val[] = value;
           // 这部分就是java的hashCode的实现是需要遍历字符串的
           for (int i = 0; i < value.length; i++) {
               // val[i]表示的就是第i个字符的ascii码
               // 31是随机选择的一个质数
               h = 31 * h + val[i];
           }
           hash = h;
       }
       return h;
   }
   ```

   <font color='yellow'>换句话说，在字符串非常长的时候，如果能用数字替换`String`作为`Hash`表的`key`，为了获得更低的时间复杂度，就不要用`String`本身，相当于提前对字符串做处理，降低复杂度</font>

   如果必要的话，可以参考下面的方式自己实现字符串的哈希函数。

   由字符串预处理得到这样的哈希数组和次方数组复杂度为`O(n)`。当我们需要计算子串`s[i...j]`的哈希值，只需要利用前缀和思想`h[j]−h[i−1]∗p[j−i+1]`即可在 `O(1)` 时间内得出哈希值（与子串长度无关）。

   ```java
   // 此代码已运行检测过
   // s是一个长串，现在需要快速计算s的子串[i,j]对应的hash值是多少
   // 对于简单的字符串，可以直接以string为key
   // 但是这种很长的字符串，需要使用Integer作为key，以保证访问
   // 预处理
   public static void prepareHashCode(String s){
       // 选择一个足够大的质数，来降低哈希碰撞的概率，以保证通过
       // 事实上，精心设计case一定会导致哈希碰撞并导致算法失败
       // 由于case是有限的，而可供选择的质数是无限的，因此可以靠这种方式来保证通过
       // 可供选择的seed序列：13 -- 31 -- 131 -- 13131 -- 131313
       int seed = 13;
       int[] h = new int[s.length() + 5];
       int[] p = new int[s.length() + 5];
       p[0] = 1;
       for (int i = 1; i <= s.length(); i++){
           // 不必担心溢出，溢出后可以循环
           h[i] = h[i - 1] * seed + s.charAt(i - 1);
           p[i] = p[i - 1] * seed;
       }
       for (int i = 1; i <= s.length(); i++){
           for (int j = i + 1; j <= s.length(); j++){
               System.out.println(getHashCode(i, j, h, p) + "----" + i + "----" + j);
           }
       }
   }
   
   // 所谓的HashCode就是尽量避免重复，针对不同的字符串作区分
   // 但是针对相同序列的字符串，hashCode必须获得同样的值
   public static int getHashCode(int i, int j,int[] h, int[] p){
       return h[j] - h[i - 1] * p[j - i + 1];
   }
   ```

3. 哈希表的扩容机制

   - Java8开始，HashMap哈希冲突的解决采用链表 + 红黑树的方案。

   - 当某个槽位的链表长度达到8，这个槽位的链表会转化为红黑树。

   - 如果某个槽位已经是红黑树了，那么这个槽位的元素个数减少为6个时，又会重新转化为链表。

   - 注意，如果某个槽位的链表长度达到8，但整个哈希表的长度小于64，那么并不会转化红黑树，而是直接扩容哈希表，来降低哈希碰撞的几率。

   - 源码

     ```java
     /**
      * HashMap的槽位中超过这个值，就会从列表转换为红黑树。
      * 这个值必须大于2，而且如果考虑元素删除时，
      * 红黑树槽位在收缩过程中变为普通槽位的假定，该值最小为8。
      * 到8就触发变成红黑树
      */
     static final int TREEIFY_THRESHOLD = 8;
     
     /**
      * 当槽位中的元素小于这个值的时候，就会触发红黑树转变为列表的转变。
      * 这个值必须小于 TREEIFY_THRESHOLD ，而且考虑到收缩过程，该值最大是6
      * 到6就触发恢复链表
      */
     static final int UNTREEIFY_THRESHOLD = 6;
     
     /**
      * HashTable能够执行红黑树转变为列表操作的最小容量。
      * 换句话说，当哈希表的容量小于这个值的时候，哪怕出现了一个槽位中有8个元素，
      * 也不会执行列表到红黑树的转换，HashTable会先触发扩容机制。
      * 应当最小是 4 * TREEIFY_THRESHOLD 来避免扩容和红黑树化的冲突。
      */
     static final int MIN_TREEIFY_CAPACITY = 64;
     ```

4. `HashMap`导致循环依赖的问题

   

5. `HashMap`具有很多优秀的特质，在算法题中会经常出现。由于哈希表的增删改查都只需要`O(1)`的时间复杂度，因此可以用来设计某些更高级的”数据结构“。

---

## 栈

1. 栈的基础知识

   `java`中栈的基本操作包括如下三种，他们的时间复杂度都是`O(1)`

   ```java
   // java中的栈有两种写法
   Stack<TreeNode> stack = new Stack<>();
   // 推荐使用，性能好一点
   Deque<TreeNode> stack = new LinkedList<>();
   ```

   | 函数   | 函数功能                         |
   | ------ | -------------------------------- |
   | `push` | 元素入栈                         |
   | `pop`  | 位于栈顶的元素出栈，并返回该元素 |
   | `peek` | 返回位于栈顶的元素，该元素不出栈 |

2. 根据栈的主要特点——先进后出，在解决多括号匹配问题、后缀表达式（逆波兰式）中，栈这种数据结构非常有用，最有用的部分大概还是在深度优先遍历的时候使用栈。

3. <font color='yellow'>**单调栈算法**</font>

   单调栈主要可以解决"需要动态查找两端最近的较大值"之类的问题，比如接雨水等习题。

   单调栈伪代码：

   ```java
   Stack<Integer> stack = new Stack<>();
   for (int i = 0; i < nums.length; i++){
   	if (stack.isEmpty() || nums[stack.peek()] < nums[i]){ // 比较的是nums[stack.peek()]和nums[i]
   		stack.push(i); // 入栈的是下标
   	} else {
   		while (!stack.isEmpty() && nums[stack.peek()] > nums[i]){
               int log = stack.pop();
               // 相关逻辑
           }
           stack.pop(i); // 下标出栈
   	}
   }
   ```

---

## 队列

1. 队列的基本知识

   `java`中`Queue`的基本操作

   | 操作             | 抛异常的  | 不抛异常的 |
      | ---------------- | --------- | ---------- |
   | 插入元素         | `add`     | `offer`    |
   | 删除元素         | `remove`  | `poll`     |
   | 返回最前面的元素 | `element` | `peek`     |

   注意，`java`写代码时想使用队列，要用下面的代码，使用`LinkedList<>`。

   ```java
   Queue<Integer> queue = new LinkedList<>();
   ```

2. 队列的特点主要是先进先出，因此队列在解决滑动窗口问题、广度优先搜索的时候，具有非常广泛的用途，包括图论中的`SPFA`算法使用的也是队列，保证每轮的节点更新完毕才会更新下一轮的。

3. 双端队列`Deque`【`double ended queue`】

   ```java
   // 双端队列的实现A，基于数组的线性双端队列，通常作为栈或队列使用，但是栈的效率不如LinkedList
   Deque<Integer> deque = new ArrayDeque<>(); // 队列写法
   // 双端队列的实现B，基于链表的链式双端队列，通常作为栈或队列使用，但是队列的效率不如ArrayDeque
   Deque<Integer> deque = new LisnkedList<>(); // 栈写法
   ```

   | 复杂操作          | 含义                                                         |
      | ----------------- | ------------------------------------------------------------ |
   | `addFirst(<E> e)` | 从双端队列的头部加入元素                                     |
   | `addLast(<E> e)`  | 从双端队列的尾部加入元素                                     |
   | `contains(<E> e)` | 双端队列是否包含元素`e`                                      |
   | `getFirst()`      | 检索双端队列的第一个元素                                     |
   | `getLast()`       | 检索双端队列的尾部元素                                       |
   | `offerFirst()`    | 在此双端队列的头部插入指定的元素                             |
   | `offerLast()`     | 在此双端队列的尾部插入指定的元素                             |
   | `peekFirst()`     | 检索但不删除此双端队列的头部元素，如果双端队列为空，返回`null` |
   | `peekLast()`      | 检索但不删除此双端队列的尾部元素，如果双端队列为空，返回`null` |
   | `pollFirst()`     | 检索并删除双端队列的第一个元素，如果双端队列为空，返回`null` |
   | `pollLast()`      | 检索并删除双端队列的尾部元素，如果双端队列为空，返回`null`   |
   | `pop()`           | 弹出尾部元素，等价于`removeFirst()`，双端队列为空会报异常    |
   | `push()`          | 向队头加入元素，等价于`addFirst()`，双端队列为空会报异常     |
   | `removeFirst()`   | 返回并移除队头元素，双端队列为空会报异常                     |
   | `removeLast()`    | 返回并移除队尾元素，双端队列为空会报异常                     |
   | `size()`          | 返回双端队列大小                                             |







----

## 树

1. 树的基本知识

    - 一个非空二叉树只有一个父节点
    - 二叉树的叶节点没有子节点
    - 二叉树具有典型的递归性质，用递归的方法可以解决很多问题

   ```java
   // 二叉树的基本代码
   public class TreeNode{
       int val;
       TreeNode left;
       TreeNode right;
       // 构造函数
       TreeNode(int x) {
           val = x;
       }
   }
   ```

2. 二叉树的遍历

    - 深度优先遍历

        1. 中序遍历

           中序遍历是先遍历左子树，再添加根节点，最后遍历右子树；主要有两种写法，分别是递归版本和循环版本。

           ```java
           // 递归版本
           public List<Integer> inorderTraversal(TreeNode root){
               List<Integer> nodes = new ArrayList<>();
               dfs(root, nodes);
               return nodes;
           }
           // 辅助函数dfs
           private void dfs(TreeNode root, List<Integer> nodes){
               if (root != null){
                   dfs(root.left, nodes);
                   nodes.add(root.val);
                   dfs(root.right, nodes);
               }
           }
           ```

           由于递归的时间复杂度往往很高，所以有必要掌握下面的循环版本：

           ```java
           // 循环版本
           public List<Integer> inorderTraversal(TreeNode root){
               List<Integer> nodes = new ArrayList<>();
               Stack<TreeNode> stack = new Stack<>();
               TreeNode cur = root;
               while (cur != null || !stack.isEmpty()){
                   while (cur!=null) {
                       stack.push(cur);
                       cur = cur.left;
                   }
                   TreeNode log = stack.pop();
                   nodes.add(log.val);
                   cur = log.right;
               }
           }
           ```

        2. 前序遍历

           前序遍历是先遍历根节点，再遍历左子树，最后遍历右子树，模板照比中序遍历大同小异，也是呈现如下的两种模式。

           ```java
           // 递归版本
           public List<Integet> preorderTraversal(TreeNode root){
               List<Integer> list = new ArrayList<>();
               dfs(root, list);
               return list;    
           }
           
           private void dfs(TreeNode root, List<Integer> list){
               if (root == null){
                   return;
               }
               list.add(root.val);
               dfs(root.left, list);
               dfs(root.rigth, list);
           }
           ```

           同样地，递归版本容易超时，所以也提供如下的递归版本

           ```java
           // 循环版本
           public List<Integer> preorderTreversal(TreeNode root){
               List<Integer> list = new ArrayList<>();
               Stack<TreeNode> stack = new Stack<>();
               TreeNode cur = root;
               wihle (cur != null || !stack.isEmpty()){
                   while (cur != null){
                       list.add(cur.val);
                       stack.push(cur);
                       cur = cur.left;
                   }
                   TreeNode log = stack.pop();
                   cur = log.right;        
               }
               return list;
           }
           ```

        3. 后序遍历

           后续遍历是先遍历左子树，再遍历右子树，最后访问根节点，后序遍历的递归代码大同小异：

           ```java
           // 递归版本
           public List<Integer> postorderTraversal(TreeNode root){
               List<Integer> nodes = new ArrayList<>();
               dfs(root, node);
               return nodes;
           }
           // 辅助函数
           private void dfs(TreeNode root, List<Integer> list){
               if (root != null){
                   dfs(root.left, list);
                   dfs(root.right, list);
                   list.add(root.val);
               }
           }
           ```

           后续遍历的循环代码略显笨重，要重点记忆`LeetCode Q145`

           > 与中序的不同之处在于：
           >
           > - 中序遍历中，从栈中弹出的节点，其左子树是访问完了，可以直接访问该节点，然后接下来访问右子树。
           > - 后序遍历中，从栈中弹出的节点，我们只能确定其左子树肯定访问完了，但是无法确定右子树是否访问过。
           >
           > 因此，我们在后序遍历中，引入了一个`prev`来记录历史访问记录。
           >
           > - 当访问完一棵子树的时候，我们用`prev`指向该节点。
           > - 这样，在回溯到父节点的时候，我们可以依据`prev`是指向左子节点，还是右子节点，来判断父节点的访问情况。
           
           ```java
           // 循环版本
           public List<Integer> postorderTraversal(TreeNode root) {
               Stack<TreeNode> stack = new Stack<>();
               List<Integer> ans = new ArrayList<>();
               TreeNode cur = root;
               TreeNode pre = null;
               while (cur != null || !stack.isEmpty()){
                   while (cur != null){
                       stack.push(cur);
                       cur = cur.left;
                   }
                   TreeNode log = stack.peek();
                   if (log.right != null && log.right != pre){
                       // 说明这个节点的右边还没访问
                       // 那现在就去访问这个节点
                       cur = log.right;
                   } else {
                       // 这个节点的右子树已经访问完毕
                       stack.pop();
                       pre = log;
                       ans.add(log.val);
                       // 直接访问栈，从栈中找这个节点上面的根节点
                       // 言外之意就是，左子树右子树都访问完毕了，去访问中间吧
                       cur = null;
                   }
               }
               return ans;
           }
           ```

    - 广度优先遍历

      广度优先遍历使用队列，与深度优先遍历使用栈是不同的；在解决具体问题的时候可以使用两个队列交互入队出队。

      ```java
      public List<Integer> bfs(TreeNode root){
          Queue<TreeNode> queue = new LinkedList<>();
          queue.offer(root);
          List<Integer> list = new ArrayList<>();
          while(!queue.isEmpty()){
              TreeNode log = queue.pop();
              list.add(list.val);
              if (log.left != null){
                  queue.offer(log.left);
              }
              if (log.right != null){
                  queue.offer(log.right);
              }
          }
          return list;
      }
      ```
      
    - `Morris`遍历（待补充，空间复杂度降低为参数，时间复杂度没有改变）

3. 二叉搜索树（**BST**，`Binary Sort Tree`）

    - 二叉树特点介绍：二叉搜索树是能够高效地进行如下操作的数据结构：

      插入一个数值

      查询是否包含某个数值

      删除某个数值

      二叉搜索树的每一项操作时间复杂度都是$O(log n)$

    - 二叉搜索树的基本特点：

      > 若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。
      >
      > 若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。
      >
      > 任意结点的左、右子树也分别为二叉搜索树。

    - 二叉搜索树的实现

      >

4. 平衡二叉搜索树（**AVL**）

    - 定义：

      > 左子树与右子树高度之差的绝对值不超过1
      >
      > 树的每个左子树和右子树都是AVL树
      >
      > 每一个节点都有一个平衡因子（balance factor），任一节点的平衡因子是-1、0、1（每一个节点的平衡因子 = 右子树高度 - 左子树高度)

    - 平衡二叉搜索树的节点插入

5. 红黑树

    - 【面试题】红黑树的红色节点和黑色节点的意义

      红色节点：红节点其实就是2-3树中3节点的表示

      黑色节点：黑节点其实就是2-3树中2节点的表示

    - 红黑树的基本性质

   一棵红黑树是满足下面红黑性质的二叉搜索树：

   > 性质一：每个节点是红色的或是黑色的；
   >
   > 性质二：根节点是黑色的；
   >
   > 性质三：每个叶子节点（`NULL`）是黑色的；
   >
   > 性质四：如果一个节点是红色的，则它的两个子节点都是黑色的；
   >
   > 性质五：对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。

   红黑树的每个节点包含5个属性，分别是：`color`、`key`、`left`、`right`、`p`。

   从某个节点`x`出发到达一个叶节点的任意一条简单路径上的黑色节点个数称为该节点的黑高，记作$bh(x)$。根据性质`5`，黑高的概念是明确的，因为从该节点出发的所有下降到其叶节点的简单路径的黑色节点个数都相同。于是定义红黑树的黑高为其根节点的黑高。

    - 红黑树为什么是一种比较优秀的搜索树？

   引理：一棵有`n`个内部节点的红黑树，高度至多为$2*log_2^{(n+1)}$。

   证明：首先证明以任意节点`x`为根的子树中至少包含$2^{bh(x)} - 1$个内部节点。如果节点`x`的高度为0，则`x`必为叶节点`NULL`，且以`x`为根节点的子树至少包含$2^{bh(x)} - 1 = 0$个内部节点。接下来考虑一个高度为正值且有两个子节点的内部节点`x`，每个子节点有黑高$bh(x)$或$bh(x) - 1$，这主要取决于自身的颜色是红还是黑。由于`x`子节点的高度比`x`本身的高度要低，可以利用归纳假设得出每个子节点至少有$2^{bh(x) - 1} - 1$个内部结点的结论。于是，以`x`为根的子树至少包含$(2^{bh(x) - 1} - 1) + (2^{bh(x) - 1} - 1) + 1 = 2^{bh(x)} - 1$个内部结点，因此得证。

   为证明引理的内容，设`h`为树的高度。根据性质4，从根节点到叶节点的任何一个简单路径上都至少有一半的节点为黑色，所以，根的黑高至少为$h/2$；于是有$n >= 2^{h/2} - 1$，整理得到$lg(n+1) >= h / 2$，或者$h <= 2 * log(n + 1)$。

   这就说明红黑树的高度基本维持在$log$级别，因此是一种比较优秀的搜索树。

    - 旋转操作

   二叉搜索树上的旋转操作保证了树在变化前后的搜索树性质不受影响。二叉搜索树的旋转操作分为两种，分别是左旋和右旋：

   ```java
   // 左旋操作伪代码
   y = x.right;        
   x.right = y.left;   // 图中的β
   if (y.left != null){
       y.left.p = x;   // 更改图中β的父节点
   }
   y.p = x.p;          // 更改y
   if (x.p == null){
       T.root = y;
   }
   else if (x == x.p.left){
       x.p.left = y;
   }
   else {
       x.p.right = y;
   }
   y.left = x;
   x.p = y;
   ```
   
    - 插入和删除操作

   插入和删除操作的时间复杂度均在$log_2^{n}$级别。

   具体的插入和删除操作主要依照分类讨论的思想，按照不同情况对红黑树进行简单调整以保证红黑树在进行完插入和删除操作后依然是红黑树。具体细节太过繁杂。

6. 

7. `Java`中`TreeSet`和`TreeMap`的使用

   > 如果题目的数据集合是动态的，并且随着集合的变化需要根据数据大小动态地查找，那么可能会用`TreeSet`和`TreeMap`。

   `Java`根据红黑树这种平衡的二叉搜索树实现了`TreeSet`和`TreeMap`两种数据结构，具体实现需要看源代码

   ```java
   // java的TreeSet源码
   // java的TreeMap源码
   ```

    - `TreeSet`的常用函数

      | 序号 | 函数      | 函数功能                                         |
           | ---- | --------- | ------------------------------------------------ |
      | 1    | `ceiling` | 返回键大于或等于给定值的最小键；没有就返回`null` |
      | 2    | `floor`   | 返回键小于或等于给定值的最小键；没有就返回`null` |
      | 3    | `higher`  | 返回键大于给定值的最小键；没有就返回`null`       |
      | 4    | `lower`   | 返回键小于给定值的最小键；没有就返回`null`       |

    - `TreeMap`的常用函数

      | 序号 | 函数                        | 函数功能                                              |
           | ---- | --------------------------- | ----------------------------------------------------- |
      | 1    | `ceilingEntry / ceilingKey` | 返回键大于或等于给定值的最小映射/键；没有则返回`null` |
      | 2    | `floorEntry / floorKey`     | 返回键小于或等于给定值的最小映射/键；没有则返回`null` |
      | 3    | `higherEntry / higherKey`   | 返回键大于给定值的最小映射/键；没有则返回`null`       |
      | 4    | `lowerEntry / lowerKey`     | 返回键小于给定值的最小映射/键；没有则返回`null`       |

   `TreeMap`和`TreeSet`也都含有`contains`方法，但这个方法的时间复杂度在$O(logn)$级别，尽量不要直接使用；如果复杂度不允许，可以在创建`TreeMap`和`TreeSet`的同时维护一个`Set`，必要时直接使用`Set`中的`contains`方法。







----

## 堆

1. 堆（Heap）的基本知识

    - 堆的定义：堆是一种特殊的数据结构，堆通常使用完全二叉树实现；而完全二叉树是可以使用数组实现的。

    - 堆与`AVL`及红黑树的区别：堆是建立在二叉树上的；而`AVL`及红黑树建立在二叉搜索树上。

    - 堆的分类：堆从类型上主要分为最大堆和最小堆，区别在于顶端元素的值是大于其他元素还是小于其他元素。

    - <font color='yellow'>堆中的元素可以重复</font>。

    - 堆的实现

      ```java
      // 手动实现堆
      // 手动实现就可以借助数组实现
      public class PriorityQueue<E extends Comparable>{
          // 全局变量ArrayList
          public ArrayList<E> list;
          // 构造方法
          public PriorityQueue() {
              list = new ArrayList<>();
          }
          // 构造方法
          public PriorityQueue(int capacity) {
              list = new ArrayList<>(capacity);
          }
          // 构造方法
          public PriorityQueue(E[] objects){
              for (E x : objects){
                  list.add(x);
              }
          }
          // 添加元素
          public void add(E newObject){
              list.add(newObject);
              int currentIndex = list.size() - 1;
              while(currentIndex > 0){
                  int parentIndex = (currentIndex - 1) >> 1;
                  if (list.get(currentIndex).compareTo(list.get(parentIndex)) > 0){
                      E temp = list.get(currentIndex);
                      list.set(currentIndex,list.get(parentIndex));
                      list.set(parentIndex,temp);
                  } else {
                      break;
                  }
                  currentIndex = parentIndex;
              }
          }
          // 移除元素
          public E remove() {
              if (list.size() == 0) {
                  return null;
              }
              E removeObject = list.get(0);
              list.set(0, list.get(list.size() - 1));
              list.remove(list.size() - 1);
              int currentIndex = 0;
              while (currentIndex < list.size()){
                  int leftChildIndex = 2 * currentIndex + 1;
                  int rightChildIndex = 2 * currentIndex + 2;
                  if (leftChildIndex >= list.size()){
                      break;
                  }
                  // 先将maxIndex设置为不超过范围的leftChildIndex
                  int maxIndex = leftChildIndex;
                  if (rightChildIndex < list.size()){
                      maxIndex = list.get(leftChildIndex).compareTo(list.get(rightChildIndex)) < 0 ? rightChildIndex : leftChildIndex;
                  }
                  if (list.get(currentIndex).compareTo(list.get(maxIndex)) < 0){
                      E temp = list.get(maxIndex);
                      list.set(maxIndex,list.get(currentIndex));
                      list.set(currentIndex,temp);
                      currentIndex = maxIndex;
                  } else {
                      break;
                  }
              }
              return removeObject;
          }
          // 返回堆顶元素
          public E peek(){
              if (list.size() == 0){
                  return null;
              } else {
                  return list.get(0);
              }
          }
          // 获取大小
          public int getSize(){
              return list.size();
          }
      }
      ```

    - `Java`中通过`PriorityQueue`（优先队列）实现了堆，默认情况下是最小堆，如果想使用最大堆的话要借助`Comparator`接口

      创建小顶堆：`PriorityQueue<Integer> heap = new PriorityQueue<>();`（默认情况即最小堆）

      创建大顶堆：`PriorityQueue<Integer> heap = new PriorityQueue<>((o1,o2) -> o2 - o1);`

      `PriorityQueue`常用的函数列表：

      | 操作         | 抛异常版本 | 不抛异常版本 |
           | ------------ | ---------- | ------------ |
      | 插入新的元素 | `add`      | `offer`      |
      | 删除堆顶元素 | `remove`   | `poll`       |
      | 返回堆顶元素 | `element`  | `peek`       |

    - 堆的时间复杂度

      使用堆求最大值或最小值：$O(1)$

      添加或删除元素：$O(logn)$

2. 堆能够解决的典型问题：

   包括求出现频率最高的`k`个数字、避免排序的第`k`大数字、和最小的`k`个数对等等，基本上题干中有第`k`个满足什么条件的元素，基本都可以借助堆实现，只要让堆顶弹`k`次就能够得到我们想要的答案。





---

## 前缀树

1. 前缀树（**Trie**）的基本知识

   前缀树又叫字典树，它用一个“树状”的树结构存储一个字典中的所有单词，前缀树的每个节点是一个数组，通常数组的长度是26，用来表示26个小写英文字母，如果两个单词的前缀是一样的，那么这两个单词在前缀树中对应的路径的前面的节点是重叠的；前缀树的每个节点中需要包含两个内容，第一个是26个节点组成的数组，另外是一个标记（可以是`boolean`，也可以是`int`），用来标识字符串的末尾。

   ```java
   // 前缀树的实现
   class Trie{
       static class TrieNode{
           Trie[] children;
           boolean isword;
           // 构造方法
           public TrieNode(){
               children = new TrieNode[26];
           }
       }
   }
   ```

2. 前缀树可以用来解决的问题，不止限于字符串，对于数字可以用`0`和`1`表示，其实也可以使用类似的想法。



---

## 并查集

1. 并查集的定义：并查集是一种树型的数据结构，用来表示不相交集合的数据。并查集中的每个子集都是一棵树，每个元素是某棵树中的一个节点。数中的每个节点有一个指向父节点的指针，数的根节点的指针指向它们自己。

2. 并查集经常用来解决图的**动态连接**问题，比如在添加了`m`条边之后，这个图中的子图数量是多少？最大的子图有多少个节点？这类问题都可以用并查集解决。

   另外，<font color='yellow'>并查集主要适用于无向图的相通性的检测，有向图的依赖性主要是靠深度优先遍历和广度优先遍历还有拓扑排序实现的</font>。

3. 并查集的复杂度：

   并查集的复杂度是$O(α(n))$，其中$α(n)$是阿克曼函数的反函数。反正总之是比$O(log(n))$还要快的一种复杂度。

   不过这是一种均摊复杂度，也就是说不能保证每一次的操作都满足这个复杂度，而是多次操作之后平均每一次操作的复杂度是$O(α(n))$的意思。

4. 【何海涛并查集模板】并查集的主要功能在于两个函数，分别是合并操作`Union()`和查找操作`findFather()`

   并查集基础形态：`int[] nums` + `Union()` + `findFather()`

   并查集高级形态：`HashMap` + `Union()` + `findFather()`

   > 例题：给定一个二维数组`M`，如果`M[i][j] = 1`，代表`i`与`j`之间同属一个小组，否则`M[i][j] = 0`，小组成员之间具有传递性，问给定的二维数组中有多少个小组？

   ```java
   // 基本模板
   public int findGroup(int[][] M){
       int[] fathers = new int[M.length];
       for(int i = 0; i < fathers.length; i++){
           fathers[i] = i;
       }
       // 小组数量，一开始每个节点自己独立，都是一个小组
       int count = M.length;
       for (int i = 0; i < M.length; i++){
           for (int j = i + 1; j < M.length; j++){
               if (M[i][j] == 1 & union(fathers, i, j)){
                   count--;
               }
           }
       }
       return count;
   }
   
   private int findFather(int[] fathers, int i){
       if(fathers[i] != i){
           fathers[i] = findFather(fathers, fathers[i]);
       }
       // 必须是fathers[i],不能是i,因为fathers[i]被改写了
       return fathers[i];
   }
   
   // 该函数的作用在于，将两个元素相连，或者是检测两个元素是否已经相连
   private boolean union(int[] fathers, int i, int j){
       int fatherOfI = findFather(fathers, i);
       int fatherOfJ = findFather(fathers, j);
       if (fatherOfI != fatherOfJ){
           fathers[fatherOfI] = fatherOfJ;
           // true表示原来没有相连，但是现在已经相连了
           return true;
       }
       // false表示已经相连了，不用再相连或检查遍历了
       return false;
   }
   ```


5. ACM并查集模板

   - 朴素并查集

   ```java
   // 初始化并查集
   int[] fathers = new int[N];
   for(int i = 0; i < N; i++){
       fathers[i] = i;
   }
   // 找父节点的find操作
   public int find(int x){
       if (fathers[x] != x){
           fathers[x] = find(fathers[x]);
   	}
       return fathers[x];
   }
   // 合并的Union操作，将a和b集合合并
   fathers[find(a)] = find(b);
   ```

    - 防退化并查集

      ```java
      
      ```



- 维护`size()`的并查集

  ```java
  // 初始化并查集，只有祖宗节点的size值才有意义，表示祖宗节点所在的集合中点的数量
  int[] fathers = new int[N];
  int[] size = new int[N];
  for (int i = 0; i < N; i++){
      fathers[i] = i;
      size[i] = 1;
  }
  // find函数可以轻松找到父节点
  public int find(int x){
      if (fathers[x] != x){
          fathers[x] = find(fathers[x]);
      }
      return fathers[x];
  }
  // 合并a和b所在的两个集合
  size[find(b)] += size[find(a)];
  fathers[find(a)] = find(b);
  // 查询某个点所在集合内元素的个数
  public int getNumbers(int a){
      return size[find(a)];
  }
  ```

- 维护到祖宗节点距离的并查集

  ```java
  // 初始化并查集
  int[] fathers = new int[N];
  int[] distance = new int[N];
  for (int i = 0; i < N; i++){
      fathers[i] = i;
      distance[i] = 0;
  }
  
  // 合并a和b所在的两个集合
  fathers[find(a)] = find(b);
  distance[find(a)] = distance; // 根据具体问题初始化find(a)的偏移量
  ```



6. 高级并查集模板



----

## 线段树

| 条件                   | 方法                         |
| ---------------------- | ---------------------------- |
| 数组不变，区间查询     | **前缀和**、树状数组、线段树 |
| 数组单点修改，区间查询 | **树状数组**、线段树         |
| 数组区间修改，单点查询 | **差分**、线段树             |
| 数组区间修改，区间查询 | **线段树**                   |

1. 前缀和

   一维前缀和：依次累加，欲求出某一区间的和只需要相减。

   ```java
   // 一维前缀和
   int[] nums;
   int[] sum = new int[nums.length + 1];
   for (int i = 0; i < nums.length; i++){
       sum[i + 1] = sum[i] + nums[i];
   }
   // 某一区间内的数字和
   int sum_a_b = sum[b + 1] - sum[a];
   ```

   二位前缀和：以左上角为起点，其余每个点内的数值都是以左上角和当前点所构成的矩形中全部的元素和。

   ```java
   // 二维前缀和
   int[][] nums;
   int[][] sum = new int[nums.length + 1][nums[0].length + 1];
   for (int i = 0; i < nums.length; i++){
       for (int j = 0; j < nums[0].length; j++){
           sum[i+1][j+1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + nums[i][j];
       }
   }
   // 求某一特定区域内的数字和
   int sum_x1_y1_x2_y2 = sum[x2 + 1][y2 + 1] - sum[x1][y1];
   ```

2. 树状数组

    - 复杂度：树状数组是一个查询和修改复杂度都是$log(n)$的数据结构，主要用于数组的单点修改和区间求和。
    - 简单来说：

   > `tree_array[1] = nums[1]`
   >
   > `tree_array[2] = nums[1] + nums[2] = nums[1] + tree_array[1]`
   >
   > `tree_array[3] = nums[3]`
   >
   > `tree_array[4] = nums[1] + nums[2] + nums[3] + nums[4] = tree_array[2] + nums[3] + nums[4]`
   >
   > ...
   
    - 创建树状数组的过程（包括更新）
   
      首先要考虑到，原数组中的元素`nums[i]`究竟会在树状数组中哪些元素中出现？需要更新的树状数组元素首先是`tree_array[i]`本身，其次是在上图中依次相连的节点，比如更新原数组中的元素$6$——`nums[i] = 6`，需要一次向上找到红色节点6，然后是8，这个更新过程可以用下面的`update()`函数本身替代。通过这种沿着边依次向上查找的方案，就能够更新全部涉及到6号的元素。
   
    - 区间求和的过程

      ⚠：目前尚未找到可以直接从0开始的方法，目前采用0位搁置，从1位开始的算法。

      如果想求从1-7号元素的和，我们需要按照次序分别找到上述的4号节点和6号节点和7号节点，翻译过来就是使用$2^k$表示$7$。沿途的所有数字求和即可，在下面的代码中体现为`getSum()`函数。

   ```java
   // 树状数组模板
   int[] nums; // [0, nums.length - 1]是真实数据
   // 树状数组建立
   int[] tree_array = new int[nums.length + 1]; // 转化到树状数组，存储信息的节点为[1, nums.length]
   // lowbit函数，用于求x的二进制表示中最低位的1
   public int lowbit(x){
       return x & (-x);
   }
   // add函数，用于创建树状数组和更新调用，所有的index都是对树状数组成立的index
   public void add(int index, int val){
       for (int i = index; i <= nums.length; i += lowBit(i)){
           tree_array[i] += val;
       }
   }
   // update函数，用于动态修改数组
   public void update(int index, int val){
       add(index, val - nums[index - 1]);
       nums[index - 1] = val;
   }
   // query函数，用于动态查询
   public int query(int location){
       int ans = 0;
       for (int i = loaction; i > 0; i -= lowBit(i)){
           ans += tree_array[i];
       }
       return ans;
   }
   // 初始化数组
   for (int i = 0; i < n; i++){
       add(i + 1, nums[i]);
   }
   ```

- 二维树状数组



3. 差分数组

   差分数组通过计算数组中相邻元素的差值作为辅助数组，帮助我们在区间修改和单点查询中起到很大的作用。

   思路比较简单，直接上模板。

   ```java
   // 原数组
   int[] nums;
   // 创建差分数组
   int[] diff = new int[nums.length + 1];
   diff[0] = nums[0] - 0;
   for (int i = 1; i < nums.length; i++){
       diff[i] = nums[i] - nums[i - 1];
   }
   diff[nums.length] = 0 - nums[nums.length - 1];
   // 更新区间，为区间[left, right]中所有的元素都加上val，left和right是数组中的下标，也就是0、1、2、3...
   public void update(int left, int right, int val){
       diff[left] += val;
       diff[right + 1] -= val;
   }
   // 单点查询
   int[] ans = new int[nums.length];
   ans[0] = 0 + diff[0];
   for (int i = 1; i < nums.length; i++){
       ans[i] = ans[i - 1] + diff[i];
   }
   ```

   ⚠注意事项

   关于边界控制，见下图

   ![image-20220402144321727](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220402144321727.png)

   更新策略：$dif[start] = dif[start] + val$、$dif[end + 1] = dif[end + 1] - val$

4. 线段树

    - 复杂度：对编号连续的一些点进行修改或者统计操作，修改和操作的复杂度都是$O(log_2^n)$。

    - 基本要求：使用线段树进行统计的必须符合区间加法，否则不可能通过分成的子区间来得到$[L,R]$的统计结果。

      区间加法性质：仅当对于区间$[L,R]$的问题的答案可以由$[L,M]$和$[M+1,R]$的答案和并得到。

      | 符合区间加法的例子                                 | 不符合区间加法的例子   |
           | -------------------------------------------------- | ---------------------- |
      | 数字之和——总数字之和=左区间数字之和+右区间数字之和 | 01序列的最长连续0      |
      | 最大公因数——总GCD = GCD（左区间GCD，右区间GCD）    | 区间的众数             |
      | 最大值——最大值 = Max（左区间最大值，右区间最大值） | 区间的最长不下降子序列 |

    - 关于用数组模拟树的操作

      树的左子节点可以表示为：$index << 1$

      树的右子节点可以表示为：$index << 1 | 1$

      ![image-20220403132444623](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220403132444623.png)

    - 线段树基本原理说明

        - 数据结构层面



     - 区间更新：
    
     线段树比树状数组高级的一点就在于可以实现区间修改，而树状数组仅支持点修改，因此有必要引入惰性标记概念。
    
     懒惰标记：本区间已经被更新了，但是子区间却没有被更新过；具体来说分为两个标记：相对标记和绝对标记。
    
     > 相对标记：指的是可以共存的标记，且打标记的顺序与答案无关，即标记可以叠加。例如为区间所有元素加上`a`这类操作。
     >
     > 绝对标记：指不可以共存的标记，每一次都要把标记下传，再给当前节点打上新的标记。例如将某个区间内的元素变为`a`这种操作，标记必须下推。
    
     - 线段树的关键函数说明（以求和问题为案例）
    
       > 线段树关键`6`函数
       >
       > 极简版本：`pushUp()`、`build()`
       >
       > 查询：`query()`
       >
       > 需要点更新：`update(5 args)`
       >
       > 区间更新套件：`pushDown()`、`update(6 args)`
    
       ```java
       // pushUp(), 由于底层新元素的变动，必须更改所有包含该节点的区段和
       public void pushUp(int index)
       // pushDown(), 配合懒惰标记使用, 由于逐个更新区间中所有的元素太耗时，使用pushDown()的递归来替代逐个更新的过程
       public void pushDown(int index, int left_node, int right_node)
       // 构建初始的线段树，只需要使用到pushUp()函数
       public void bulid(int left, int right, int index)
       // 点更新操作，先从[1,n]区间向下递归找到点[m,m]，再利用pushUp()由该点[m,m]向上合并更新沿途的所有区段，最终回到顶层区段[1,n]
       public void update(int left, int right, int location, int val, int index)
       // 区间更新操作，区间更新操作是先向下使用尽可能少的区段覆盖掉当前待更新的区段[L,R]，为上述区段集合打上懒惰标记来模拟该区域已经被更新
       public void update(int left, int right, int L, int R, int val, int index)
       // 区间查询操作，区间查询与区间更新类似，需要注意的是沿途的所有懒惰标记此时必须利用pushDown()函数更新，也就是在函数入口处直接设置pushDown()
       public int query(int left, int right, int L, int R, int index)
       ```

- 第一层——线段树实现**【点更新模板】**【与树状数组同功能】【数组实现线段树】【递归函数】

  ```java
  // 创建基本线段树，使用数组实现
  int[] nums;                             // 原数组
  int[] sum = new int[nums.length << 2];  // 线段树核心数组，一般开4倍n的大小
  // pushUp函数，index是当前节点在sum中的位置
  public void pushUp(int index){
      sum[index] = sum[index << 1] + sum[index << 1 | 1];
  }
  // Bulid函数建立线段树
  public void bulid(int left, int right, int index){
      if (left == right){
          sum[index] = nums[left];
          return;
      }
      int mid = (left + right) >> 1;
      build(left, mid, index << 1);
      build(mid + 1, right, index << 1 | 1);
      pushUp(index);
  }
  // 点修改 nums[location] += val (五参数update)
  public void update(int left, int right, int location, int val, int index){
      if (left == right){
          sum[index] += val;
          return;
      }
      int mid = (left + right) >> 1;
      if (location <= mid){
          update(left, mid, location, val, index << 1);
      } else {
          update(mid + 1, right, location, val, index << 1 | 1);
      }
      pushUp(index);
  }
  // 区间查询，区间查询A[L,R]
  public int query(int left, int right, int L, int R, int index){
      if (L <= left && right <= R){
          return sum[index];
      }
      int mid = (left + right) >> 1;
      int ans = 0;
      if (L <= mid){
          ans += query(left, mid, L, R, index << 1);
      } 
      if (R > mid){
          ans += Query(mid + 1, right, L, R, index << 1 | 1);
      }
      return ans;
  }
  ```

- 第二层——线段树实现**【区间更新模板】**【相对标记】【数组实现线段树】【递归函数】

  ```java
  // 创建基本线段树，使用数组实现
  int[] nums;                             // 原数组
  int[] sum = new int[nums.length << 2];  // 线段树核心数组
  int[] flag = new int[nums.length << 2]; // 懒惰标记数组，与核心数组一样，一般开4倍n的大小
  // pushUp函数，index是当前节点在sum中的位置
  public void pushUp(int index){
      sum[index] = sum[index << 1] + sum[index << 1 | 1];
  }
  // pushDown函数，index是当前节点在sum中的位置，left_node是左边节点的数量，right_node是右边节点的数量
  public void pushDown(int index, int left_node, int right_node){
      if (flag[index] != 0){
          flag[index << 1] += flag[index];
          flag[index << 1 | 1] += flag[index];
          sum[index << 1] += flag[index] * left_node;
          sum[index << 1 | 1] += flag[index] * right_node;
          flag[index] = 0;
      }
  }
  // Bulid函数建立线段树
  public void bulid(int left, int right, int index){
      if (left == right){
          sum[index] = nums[left];
          return;
      }
      int mid = (left + right) >> 1;
      build(left, mid, index << 1);
      build(mid + 1, right, index << 1 | 1);
      pushUp(index);
  }
  // 区间修改 nums[L,R] += val (六参数update)
  public void update(int left, int right, int L, int R, int val, int index){
      if (L <= left && right <= R){
          sum[index] += val * (right - left + 1); // 区间内所有元素加val，相当于sum加val * (right - left + 1)
          flag[index] += val;                     // 表示该区间的sum正确，但是具体值仍需要根据flag调整
          return;
      }
      int mid = (left + right) >> 1;
      pushDown(index, mid - left + 1, right - mid);
      if (L <= mid){
          update(left, mid, L, R, val, index << 1);
      }
      if (R > mid){
          update(mid + 1, right, L, R, val, index << 1 | 1);
      }
      pushUp(index);
  }
  // 区间查询，区间查询A[L,R]
  public int query(int left, int right, int L, int R, int index){
      if (L <= left && right <= R){
          return sum[index];
      }
      int mid = (left + right) >> 1;
      pushDown(index, mid - left + 1, right - mid);
      int ans = 0;
      if (L <= mid){
          ans += query(left, mid, L, R, index << 1);
      } 
      if (R > mid){
          ans += Query(mid + 1, right, L, R, index << 1 | 1);
      }
      return ans;
  }
  ```

- 函数调用

  | 函数                                                         | 实际写法                                       |
       | ------------------------------------------------------------ | ---------------------------------------------- |
  | `pushUp(int index)`                                          | 一般是从`1`开始                                |
  | `build(int left, int right, int index)`                      | `build(1, n, 1)`                               |
  | `update(int left, int right, int location, int val, int index)` | `update(1, n, INPUT_LOC, INPUT_VAL, 1)`        |
  | `query(int left, int right, int L, int R, int index)`        | `query(1, n, INPUT_L, INPUT_R, 1)`             |
  | `update(int left, int right, int L, int R, int val, int index)` | `update(1, n, INPUT_L, INPUT_R, INPUT_VAL, 1)` |

  不难发现，前两层级的线段树使用可以简单概括为如下步骤

  > 前两层线段树的使用方式
  >
  > 1. `pushUp`函数实现
  > 2. 依赖`pushUp`的`build`函数实现，此时已经创建了基本的线段树
  > 3. 依赖`pushUp`的`update`函数实现
  > 4. 根据修改规则使用`update`动态修改
  > 5. 依赖递归的`query`函数实现
  > 6. 根据要求使用`query`进行动态查询

- 非递归实现原理

    - 从旧线段树出发，区分三个下标：

      原数组下标：需要维护统计信息的数组的下标，这里都默认下标从1开始。

      线段树下标：加入线段树中某个位置的下标。

      存储下标：该元素所在叶节点的编号，即实际存储的位置。

  ![image-20220403214659106](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220403214659106.png)

    - 改进的非递归线段树和点修改下的区间查询

      查询想法是：用蓝色的两条线将线段树查询区间框住，这就间接导致我们必须引入图中两个橘色的节点来保证框住的可行性。

      对左边的蓝色线而言，若该节点是其父节点的左子节点，那么就要将该节点的右子节点计入结果；

      对右边的蓝色线而言，若该节点是其父节点的右子节点，那么就要将该节点的左子节点计入结果；

      简单来说，就是左侧的右边和右侧的左边包围的才是查询区间。

      将沿途的红色对勾节点对应的数值加和，就得到了查询答案。

  ![image-20220404124826650](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220404124826650.png)

    - 改进的非递归线段树下标对应：

      根据非递归线段树的要求，我们不能在$[1,n]$的范围内存元素，而是要在$[2,n+1]$的范围内存元素，保证所有对应真实数据的叶子节点两边必须有其他元素，总共需要开辟$n + 2$大小的空间。现在我们有：
      $$
      原数组下标 + 1 = 线段树下标 \newline
      线段树下标 + N - 1 = 存储下标 \newline
      原数组下标 + N = 存储下标
      $$
      $N$如何确定？$N$的含义是这棵树可以存放$N$个元素，也就是说，$N$是大于等于$n + 2$的$2$的某个次方，这是可以计算出来的。

      ![image-20220404123732051](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220404123732051.png)

    - 区间修改下的区间查询

      方法之一：如果题目是最终下推一次所有标记就可以的类型，我们可以直接打上标记不更新，靠最终一次的遍历得到全部结果。

      方法之二：如果题目查询跟修改混在一起，那么采用标记永久化的思想，也就是不下推标记。

      递归线段树是在查询区间时逐个下推标记，这样到达子区间的时候答案已经是正确的了；非递归线段树做不到，因为它是从下至上进行的，遇到标记就更新答案。

      左边的蓝色节点$H$从下往上走，在蓝色节点到达$4$时，注意到，左边蓝色节点之前计算过的所有节点$G、H、8、9、I、J$都是目前蓝色节点的子节点，也就是说，当前蓝色节点$4$的懒惰标记是要影响这个节点已经计算过的所有数。多用一个变量来记录这个蓝色节点已经计算过多少个数， 根据个数以及当前蓝色节点的懒惰标记，来更新最终答案。
      更新完答案之后，再加上$5$号节点的答案，同时当前蓝色节点计算过的个数要+4（因为$5$号节点代表4个数的和）。然后当这个节点到达$1$节点时，可以更新$1$号节点的懒惰标记。
      这里，本来左右蓝色节点相遇之后就不再需要计算了（正常情况下分别到达$2$和$3$号节点就可以结束了）但是由于有了懒惰标记，左右蓝色节点的公共祖先上的懒惰标记会影响目前的所有数，所以还需要一路向上查询到根，沿途更新答案。

      ![image-20220404125158567](C:\Users\10727\AppData\Roaming\Typora\typora-user-images\image-20220404125158567.png)

    - 区间修改

      修改的时候，给某个区间的懒惰标记加上了$val$，这个区间的子区间向上查询时，会经过这个节点，也就是会计算这个懒惰标记，但是如果路径经过这个区间的父节点，就不会计算这个节点的懒惰标记，也就会出错。这里其实跟递归线段树一样，改了某个区间的懒惰标记仍需要向上更新所有包含这个区间的$sum$，来保持上面所有节点的正确性。

- 第三层——线段树实现【点修改】【区间修改】【数组实现线段树】【非递归函数】

  【用的还是少一些，限制条件较高】【低掌握程度】

  限制要求：

    1. 非递归线段树只能维护相对标记，绝对标记问题不可以使用非递归线段树。
    2. 非递归线段树对点修改和区间查询非常友好，但是对于区间更新略显疲态；有一种例外是，在所有操作结束后一次性下推所有标记然后求结果，这种区间查询非递归线段树也比较友好。

  简单来说：使用到动态实时区间修改并查询尽量不要使用非递归版本，点更新+区间查询适合使用非递归版本或者树状数组。

  ```java
  // 定义
  int[] nums;
  int[] sum = new int[nums.length << 2];
  int[] flag = new int[nums.length << 2];
  // 建树
  public void build(int index){
      int N = 1;
      while (N < n + 2){
          N <<= 1;
      }
      for (int i = 0; i <= n; i++){
          sum[N + i] = nums[i]; // 原数组下标 + N = 存储下标
      }
      for (int i = N - 1; i > 0; --i){
          sum[i] = sum[i << 1] + sum[i << 1 | 1];
          flag[i] = 0;
      }
  }
  // 点修改
  public void update(int location, int val){
      for (int s = N + location; s > 0 ; s >>= 1){
          sum[s] += val;
      }
  }
  // 点修改下的区间查询
  public int query(int L, int R){
      int ans = 0;
      for (int s = N + L - 1, t = N + R + 1; s ^ t ^ 1 > 0; s >> 1, t >> 1){
          if (~s & 1 > 0) ans += sum[s ^ 1];
          if ( t & 1 > 0) ans += sum[t ^ 1];
      }
  }
  // 区间修改
  public void Update(int L,int R,int C){
      int s,t,Ln=0,Rn=0,x=1;
      //Ln:  s一路走来已经包含了几个数
      //Rn:  t一路走来已经包含了几个数
      //x:   本层每个节点包含几个数
      for(s=N+L-1,t=N+R+1;s^t^1;s>>=1,t>>=1,x<<=1){
          //更新Sum
          Sum[s]+=C*Ln;
          Sum[t]+=C*Rn;
          //处理Add
          if(~s&1) Add[s^1]+=C,Sum[s^1]+=C*x,Ln+=x;
          if( t&1) Add[t^1]+=C,Sum[t^1]+=C*x,Rn+=x;
      }
      //更新上层Sum
      for(;s;s>>=1,t>>=1){
          Sum[s]+=C*Ln;
          Sum[t]+=C*Rn;
      } 
  }
  // 区间修改下的区间查询
  public int Query(int L,int R){
      int s,t,Ln=0,Rn=0,x=1;
      int ANS=0;
      for(s=N+L-1,t=N+R+1;s^t^1;s>>=1,t>>=1,x<<=1){
          //根据标记更新 
          if(Add[s]) ANS+=Add[s]*Ln;
          if(Add[t]) ANS+=Add[t]*Rn;
          //常规求和 
          if(~s&1) ANS+=Sum[s^1],Ln+=x;
          if( t&1) ANS+=Sum[t^1],Rn+=x; 
      }
      //处理上层标记
      for(;s;s>>=1,t>>=1){
          ANS+=Add[s]*Ln;
          ANS+=Add[t]*Rn;
      }
      return ANS;
  }
  ```


- 第四层——线段树实现【`class`模式】【点修改、区间修改】

  ```java
  
  ```







---

## 二分查找

1. 二分查找是一种优化的暴力查找，优化基于一个假设：数组或序列已经被排好了顺序，这个顺序<font color='yellow'>是单调递增的，不要求严格单调递增，也就是对于`i < j`，必然存在`nums[i] <= nums[j]`</font>

2. 二分查找的基本模板

   ```java
   // 模板一，默认数组是递增排序的
   public int BinarySearch(int[] nums, int target){
       int left = 0;
       int right = nums.length - 1;
       while (left <= right){
           int mid = left + (right - left) / 2;
           if (nums[mid] == target){
               return mid;
           } else if (nums[mid] < target){
               left = mid + 1;
           } else if (nums[mid] < target){
               right = mid - 1;
           }
       }
       return -1;
   }
   // 模板二 （明显更优秀一些）
   public int BinarySearch(int[] nums, int target){
       int left = 0;
       int right = nums.length;
       while (left < right){
           int mid = left + (right - left) / 2;
           if (nums[mid] == target){
               return mid;
           } else if (nums[mid] < target){
               left = mid + 1;
           } else if (nums[mid] < target){
               right = mid;
           }
       }
       return -1;
   }
   ```

3. 二分查找的细节

    - 为什么`while`循环的条件中是`left <= right`或`left < right`?

      > 因为初始化`right`的赋值是`nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`，前者相当于两端都闭区间`[left, right]`，后者相当于左闭右开区间`[left, right)`，因为索引大小为`nums.length`是越界的。

    - `left <= right`与`left < right`的区别

      > `left <= right`的循环终止条件是`left == right + 1`，写成区间的形式就是`[right + 1, right]`，在这种情况下没有数被漏掉，循环可以直接结束，这正是模板一的思路想法，从一开始设置的`right`就可以看出，区间内的任何一个元素都有可能是答案所在，必须精准地遍历每一个元素。

      > `left < right`的循环终止条件是`left == right`，写成区间的形式就是`[right, right]`，不难发现这个时候`right`还没有被检查，这样的循环终止条件就与模板二十分匹配，因为`right`这个位置始终不是答案所在的位置，从一开始它就是越界的下标，随着后面的逐渐遍历，它如果被更新了也只是“必定不满足题意的`mid`”所在的位置。

4. **高级版本** 数组中存在重复元素时，如何寻找最右边的元素和最左边的元素？

    - 寻找最左边的元素（也可以理解为小于`target`的元素有多少个）

      ```java
      // 二分查找之寻找最左边的元素
      // [1,2,2,2,2,3] target = 2;
      public int left_bound(int[] nums, int target) {
          int left = 0;
          int right = nums.length; 
          while (left < right) {
              int mid = (left + right) / 2;
              if (nums[mid] == target) {
                  right = mid;
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else if (nums[mid] > target) {
                  right = mid;
              }
          }
          return left;
      }
      ```

      为什么这个版本可以查找到最左边的元素？或者可以定位到数组中刚好小于`target的`位置？

      > 关键在于`nums[mid] == target`这句代码，当前值等于`target`是，我们不是急着返回，而是要求继续缩减右边的空间到`mid`，这样就保证了退出循环时一定是`left == right`且所在位置是刚好小于等于`target`的第一个位置。

      如果没找到可不可以返回`-1`？当然可以，去掉`return left;`这句话，换成下面的代码：

      ```java
      // 整个数组的元素都小于target，有nums.length个元素都小于target，这时候返回 -1 表示没找到
      if (left == nums.length) return -1;
      // 否则就是数组中没有找到target，但是有left个元素小于target，这时候看看left所在的位置等不等于target，等于就返回left，不等就说明没找到
      return nums[left] == target ? left : -1; // 因为终止条件是left == right，所以实际上返回right也是一样的
      ```

    - 寻找最右边的元素（也可以理解为小于等于`target`的元素有多少个）

      ```java
      public int right_bound(int[] nums, int target) {
          int left = 0, right = nums.length;
          while (left < right) {
              int mid = (left + right) / 2;
              if (nums[mid] == target) {
                  left = mid + 1; 
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else if (nums[mid] > target) {
                  right = mid;
              }
          }
          // 回忆起这种写法的终止条件是left = right，也就是[right, right]
          // 因此right是没有被检查的位置，-1 才是正确答案
          return left - 1; // right - 1是一样的
      }
      ```

      为什么这个代码可以找到最右边的元素？
      
      > 关键在于`nums[mid] == target`这行代码，当前值是`target`的时候，我们不是急着返回而是要求继续缩减左侧空间到`mid`，这样就保证了退出循环时一定是`left == right`。

5. 总结：

    - 模板一全家桶（思考相对麻烦一点，但好写）

      ```java
      // 基础模板
      public int BinarySearch(int[] nums, int target){
          int left = 0;
          int right = nums.length - 1;
          while (left <= right){
              int mid = left + (right - left) / 2;
              if (nums[mid] == target){
                  return mid;
              } else if (nums[mid] < target){
                  left = mid + 1;
              } else if (nums[mid] < target){
                  right = mid - 1;
              }
          }
          return -1;
      }
      // 寻找左侧边界
      private int BinarySearch(int[] numbers, int target){
          int start = 0;
          int end = numbers.length - 1;
          while (start <= end){
              int mid = (start + end) / 2;
              if (numbers[mid] == target){
                  end = mid - 1;
              } else if (numbers[mid] > target){
                  end = mid - 1;
              } else if (numbers[mid] < target){
                  start = mid + 1;
              }
          }
          return end + 1;
          // return start; 也是可以的
      }
      // 寻找右侧边界
      private int BinarySearch(int[] numbers, int target){
          int start = 0;
          int end = numbers.length - 1;
          while (start <= end){
              int mid = (start + end) / 2;
              if (numbers[mid] == target){
                  start = mid + 1;
              } else if (numbers[mid] > target){
                  end = mid - 1;
              } else if (numbers[mid] < target){
                  start = mid + 1;
              }
          }
          return end;
          // return start - 1; 也是可以的
      }
      ```

    - 模板二全家桶（相对不好写，但是好想，因为终止条件总是 `left == right`）

      ```java
      // 基础模板
      public int BinarySearch(int[] nums, int target){
          int left = 0;
          int right = nums.length;
          while (left < right){
              int mid = left + (right - left) / 2;
              if (nums[mid] == target){
                  return mid;
              } else if (nums[mid] < target){
                  left = mid + 1;
              } else if (nums[mid] < target){
                  right = mid;
              }
          }
          return -1;
      }
      // 寻找左侧边界
      public int left_bound(int[] nums, int target) {
          int left = 0;
          int right = nums.length; 
          while (left < right) {
              int mid = (left + right) / 2;
              if (nums[mid] == target) {
                  right = mid;
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else if (nums[mid] > target) {
                  right = mid;
              }
          }
          return left; // return right也是可以的
      }
      // 寻找右侧边界
      public int right_bound(int[] nums, int target) {
          int left = 0;
          int right = nums.length; 
          while (left < right) {
              int mid = (left + right) / 2;
              if (nums[mid] == target) {
                  left = mid + 1;
              } else if (nums[mid] < target) {
                  left = mid + 1;
              } else if (nums[mid] > target) {
                  right = mid;
              }
          }
          return left - 1; // return right - 1也是可以的，因为上述过程中找到的是刚好大于target的第一个元素，所以要减一
      }
      ```

        - 关键点：

          基础情况（没有重复元素）需要注意的是搜索区间的开闭问题

          寻找左右边界的情况主要是要注意，当`numbers[mid] == target`的时候的更新策略。

6. 二分搜索的应用类型

   - 从有序数组中查找某个值

     最基础的用法，参考上述两个模版

   - 假定一个解并测试是否可行

     当答案的结果难以通过算法直接求出且其结果具有二分性（小于某一临界值的答案均不可行而大于某一临界值的答案均可行或反之）时，可以采用枚举答案并测试答案是否满足题意来求解问题。

   - 最大化最小值、最小化最大值

     > 题目：N个房屋在一条直线上，他们的位置在`int[] location`数组中存储，为了保证不互相打扰，想尽可能地安排M个人，保证彼此间的距离尽可能的大，求距离最大是多少？
     >
     > ```java
     > // POJ 2456
     > public static void main(String[] args) {
     >     Scanner sc = new Scanner(System.in);
     >     int N = sc.nextInt();
     >     int M = sc.nextInt();
     >     int[] location = new int[N];
     >     for (int i = 0; i < N; i++){
     >         location[i] = sc.nextInt();
     >     }
     >     int distance = getDistance(location, N, M);
     >     System.out.println(distance);
     > }
     > 
     > // 本质上还是用二分试验答案
     > public static int getDistance(int[] location, int N, int M) {
     >     Arrays.sort(location);
     >     int from_dis = 0;
     >     int to_dis = (int) 1e10;
     >     while (from_dis < to_dis) {
     >         int mid = (from_dis + to_dis) / 2;
     >         if (test(location, M, mid)) {
     >             from_dis = mid + 1;
     >         } else {
     >             to_dis = mid;
     >         }
     >     }
     >     return from_dis - 1;
     > }
     > 
     > public static boolean test(int[] location, int M, int distance) {
     >     int flag = 0;
     >     int count = 1;
     >     while (flag < location.length) {
     >         // 要从flag + 1开始找
     >         int findLocation = findLocation(location, location[flag] + distance, flag + 1);
     >         if (findLocation == location.length) {
     >             return M <= count;
     >         } else {
     >             count++;
     >             flag = findLocation;
     >         }
     >     }
     >     return M <= count;
     > }
     > 
     > // 二分找下标
     > public static int findLocation(int[] location, int locationFinding, int from) {
     >     // 找大于等于location的第一个下标
     >     int start = from;
     >     int end = location.length;
     >     while (start < end) {
     >         int mid = (start + end) / 2;
     >         if (location[mid] == locationFinding) {
     >             return mid;
     >         } else if (location[mid] < locationFinding) {
     >             start = mid + 1;
     >         } else {
     >             end = mid;
     >         }
     >     }
     >     return end;
     > }
     > ```

   - 最大化平均值

     > *题目：有n个物品的重量和价值分别是$$w_{i}$$和$$v_i$$，从中选出k个物品使得单位重量的价值最大，求这个单位重量的价值，保留两位小数。
     >
     > - 分析：最容易想到的答案就是按照单位价值进行排序，然后取前面的就可以了。但实际上是不可以的。最终转化为选择一个平均价值，来检测这个价值可不可行。
     > - 案例：`(w,n) = {(2,2), (5,3), (2,1)}`，选择0和2号物品，答案是0.75；选择0和1号物品，答案是0.714
     >
     > ```java
     > // 每次判断的复杂度是O(n * log(n))，但是由于小数只有两位
     > // 因此相当于从0-100中判断，实际的复杂度还是O(n * log(n))
     > public void solve(){
     >     double lb = 0;
     >     double ub = INF;
     >     // 只求解100次（第一次见这种解法，在100次之内保证解决）
     >     for (int i = 0; i < 100; i++){
     >         double mid = (lb + ub) / 2;
     >         if (test(mid)){
     >             lb = mid;
     >         } else {
     >             ub = mid;
     >         }
     >     }
     >     System.out.println(ub);
     > }
     > 
     > public boolean test(double x){
     >     for (int i = 0; i < n; i++){
     >         y[i] = wv[i][1] - x * wv[i][0];
     >     }
     >     // 从小到大
     >     Array.sort(y);
     >     double sum = 0;
     >     for (int i = 0; i < k; i++){
     >         // 从后面最大的取
     >         sum += y[n - i - 1];
     >     }
     >     return sum >= 0;
     > }
     > ```

7. 关于精度比较的二分查找`LeetCode Q786`

   > 所谓的精度比较二分，就是在`while`循环中更改终止条件，不是单纯的`start < end`，而是`start - end < EPS`，这种二分的时间复杂度取决于精度的大小，例如$$C = 10^{-8}$$，二分复杂度为 $$O(logC)$$。
   
   > 不过值得说的是，小数是有最低的精度的，比到一定程度也就比不出差异了，因此指定精度可以理解为一种指定的优化。
   
   ```java
   // 基本模版
   double eps = 1e-8;
   while (start - end < eps){
       double mid = (start + end) / 2;
       if (...){
           ...
       }
   }
   ```
   
8. 特殊的二分查找`LeetCode Q793`

----

## 排序

1. 排序算法汇总

   这里的空间复杂度主要是考虑**额外**再需要申请的空间数量级。

   | 排序算法 | 基本思想 | 时间复杂度(平均)  | 时间复杂度(最坏)  | 时间复杂度(最好)  | 空间复杂度(待考) | 稳定性 |
   | -------- | -------- | ----------------- | ----------------- | ----------------- | ---------------- | ------ |
   | 插入排序 |          | $O(n^2)$          | $O(n^2)$          | $O(n)$            | $O(1)$           | 稳定   |
   | 希尔排序 |          | $O(n^{1.3})$      | $O(n^2)$          | $O(n)$            | $O(1)$           | 不稳定 |
   | 选择排序 |          | $O(n^2)$          | $O(n^2)$          | $O(n^2)$          | $O(1)$           | 不稳定 |
   | 堆排序   | 堆       | $O(n*log_{2}{n})$ | $O(n*log_{2}{n})$ | $O(n*log_{2}{n})$ | $O({n})$         | 不稳定 |
   | 冒泡排序 |          | $O(n^2)$          | $O(n^2)$          | $O(n)$            | $O(1)$           | 稳定   |
   | 快速排序 | 分区     | $O(n*log_{2}{n})$ | $O(n^2)$          | $O(n*log_{2}{n})$ | $O(log_{2}{n})$  | 不稳定 |
   | 归并排序 | 归并     | $O(n*log_{2}{n})$ | $O(n*log_{2}{n})$ | $O(n*log_{2}{n})$ | $O(n)$           | 稳定   |
   | 计数排序 | 计数     | $O(n+k)$          | $O(n+k)$          | $O(n+k)$          | $O(n+k)$         | 稳定   |
   | 桶排序   |          | $O(n+k)$          | $O(n^2)$          | $O(n)$            | $O(n+k)$         | 稳定   |
   | 基数排序 |          | $O(n*k)$          | $O(n*k)$          | $O(n*k)$          | $O(n+k)$         | 稳定   |

   ⚠️：快速排序的空间复杂度主要取决于递归调用栈的大小，因此严格来说，空间复杂度介于$$O(log_{2}n)$$和$O(n)$之间。

2. 插入排序



3. 希尔排序



4. 选择排序



5. 堆排序

    - 基本定义：堆排序是一种借助“堆”这种数据结构进行排序的算法，主要借助堆能够自动比较大小来实现排序。

    - 适用场景：主要是堆的适用场景，比如找到第`k`大的元素

    - 基本思想：建立堆，将元素全部添加进入堆，然后逐个弹出。

      ```mermaid
      graph LR
          A("建立大顶堆或小顶堆")
          B("遍历元素并添加到堆中")
          C("将堆中的元素逐个弹出来")
          D("开始")
          E("结束")
          D-->A
          A-->B
          B-->C
          C-->E
      ```

    - 时空复杂度分析

      时间复杂度： $O(n*log_{2}{n})$

      空间复杂度：$O({n})$

    - 代码实现：（忽略了堆的具体实现）

      ```java
      public void heapSort(int nums){
          PriorityQueue<Integer> heap = new PriorityQueue<>();
          for(int num : nums){
              heap.offer(num);
          }
          int[] answer = new int[nums.length];
          for (int i = 0; i < nums.length; i++){
              answer[i] = heap.poll();
          }
      }
      ```

6. 冒泡排序

    - 基本定义：冒泡排序是一种简单直观的排序算法，它重复第走访要排序的数列，一次比较两个元素，如果它们的顺序错误就交换；重复地进行直到没有再需要交换的。算法名称的又来主要是因为最小的元素会像冒泡一样浮到最上面。

    - 适用场景：非常需要稳定性的场景（也不一定），基本上没有场景使用

    - 基本思想：外层循环表示通过这一轮排序要保证最少有多少个数找到自己的位置，然后内层的遍历要减去这个固定数值，随后在流程中逐渐交换位置。

      ```mermaid
      graph LR
          A("外层循环设定本轮要确定的位置数量")
          B("内层循环次数减去该固定值")
          C("比较内层循环相邻两个数的大小，逆序则交换")
          D("开始")
          E("结束")
          D-->A
          A-->B
          B-->C
          C-->E
      ```

    - 时空复杂度分析

      时间复杂度：$O(n^2)$

      空间复杂度：$O(1)$

    - 代码实现

      ```java
      public void BubbleSort(int[] nums){
          for (int i = 1; i < nums.length; i++){
              // 加一个标志，表示如果这轮排序没有逆序的，证明已经排好了，直接跳出循环就可以了
              boolean flag = true;
              for (int j = 0; j < nums.length - i; j++){
                  if (nums[j] < nums[j + 1]){
                      // 为flag加上标志
                      flag = false;
                      int temp = nums[j];
                      nums[j] = nums[j + 1];
                      nums[j + 1] = temp;
                  }
              }
              if (!flag){
                  break;
              }
          }
      }
      ```

7. 快速排序

    - 基本定义：快速排序是一种非常高效的排序算法，`Java`的`Arrays.sort()`函数实现的就是快速排序，在需要优先排序的场景中往往都直接使用该函数，表现良好的情况下要比其他对手快2-3倍。

    - 适用场景：需要快速排序且不考虑稳定性的时候。

    - 基本思想：在输入数组中随机选择一个元素作为中间值，然后对数组进行分区，比中间值大的数移动到右边，比中间值小的数移动到左边，接下来对两边的数组做同样的步骤，直到数组的长度为1就终止该分支的排序。

      ```mermaid
      graph LR
          S("开始")
          A("在数组中随机选取一个中间值MID")
          B("大于中间值MID的移动到中间值左边")
          C("小于中间值MID的移动到中间值右边")
          D("对左半边和右半边继续排序")
          E("结束")
          S-->A
          A-->B
          A-->C
          B-->D
          C-->D
          D-->E
      ```

    - 时空复杂度分析

      时间复杂度：$O(n*log_{2}{n})$

      空间复杂度：$O(1)$

    - 代码实现

      ```java
      // 快速排序主函数
      public void quickSort(int[] nums, int left, int right){
          if (left < right){
              int pivot = partition(nums, left, right);
              quickSort(nums, left, pivot - 1);
              quickSort(nums, pivot + 1, right);
          }
      }
      // 快速排序分区函数
      public int partition(int[] nums, int left, int right){
          int random_int_location = new Random().nextInt(right - left + 1) + left;
          int random_int = nums[random_int_location];
          // 要先将随机位置和最后一个数交换
          swap(nums, random_int_location, right);
          // 初始化时small在left - 1的位置
          int small = left - 1;
          for(int i = left; i < right; i++){
              if (nums[i] < nums[right]){
                  small++;
                  swap(nums, small, i);
              }
          }
          small++;
          // 将随机数交换到它应该待的位置上
          swap(nums, small, right);
          // 现在唯一确定的就是随机数所在的位置是正确的
          return small;
      }
      // 快速排序交换函数
      public void swap(int[] nums, int a, int b){
          int temp = nums[a];
          nums[a] = nums[b];
          nums[b] = temp;
      }
      ```

8. 归并排序

    - 基本定义：归并排序是一种基于分治法的排序算法，主要利用递归的思路，先将数组分割成两个部分分别排序，再将两个已经排好序的数组拼接起来。

    - 适用场景：链表的排序比较类似这种想法，通常是将链表与归并排序结合起来考察。

    - 基本思想：先将数组分割成两个部分分别排序，再将两个已经排好序的数组拼接起来。

      ```mermaid
      graph LR
          S("开始")
          A("将数组平均分割为两个数组")
          B("分别排序两个子数组")
          C("两个子数组都已经完成排序")
          D("将两个子数组按照大小拼接")
          E("结束")
          S-->A
          A-->B
          B-->C
          C-->D
          D-->E
      ```

    - 时空复杂度分析

      时间复杂度：  $O(n*log_{2}{n})$

      空间复杂度：  $O(n)$

    - 代码实现：

      ```java
      public int[] mergeSort(int nums[]) {
          int[] ans = Arrays.copyOf(nums,nums.length);
          // end位置的值是ans.length，而不是ans.length - 1
          merge(nums, ans, 0, ans.length);
          return ans;
      }
      
      private void merge(int src[], int dis[], int start, int end) {
          if (end - start <= 1) {
              return;
          }
          int mid = (start + end) / 2;
          // 在交换过程中
          merge(dis, src, start, mid);
          merge(dis, src, mid, end);
          // i是第一个数组的起始
          int i = start;
          // j是第二个数组的起始
          int j = mid;
          // k是目标数组的起始
          int k = start;
          while (i < mid || j < end) {
              if (j == end || (i < mid && src[i] < src[j])) {
                  dis[k++] = src[i++];
              } else {
                  dis[k++] = src[j++];
              }
          }
      }
      ```

9. 计数排序

    - 基本定义：计数排序是一种线性时间的整数排序算法，如果数组的长度为`n`，整数范围（数组中最大整数与最小整数的差值）为`k`，对于`k`远小于`n`的场景，那么计数排序要非常优秀。

    - 适用场景：整数范围远远小于数据量的时候

    - 基本思想：对每个出现的数计数，然后在输出过程中按照计数顺序和数字出现次数输出

      ```mermaid
      graph LR
          A("遍历数组找到最大值与最小值")
          B("再次遍历数组并计数")
          C("按照顺序和次数输出")
          A-->B
          B-->C
      ```

    - 时空复杂度分析

      时间复杂度：  $O(n+k)$

      空间复杂度：  $O(n+k)$

    - 代码实现：

      ```java
      public int[] countSort(int[] nums){
          // 遍历找最大值最小值
          int max = Integer.MIN_VALUE;
          int min = Integer.MAX_VALUE;
          for (int num : nums){
              max = Math.max(max,num);
              min = Math.min(min,num);
          }
          int[] count = new int[max - min + 1];
          // 计数
          for (int num : nums){
              count[num - min]++;
          }
          int[] answer = new int[nums.length];
          int j = 0;
          for (int index = 0; index < count.length;index++) {
              while (count[index] != 0) {
                  answer[j++] = index + min;
                  count[index]--;
              }
          }
          return answer;
      }
      ```

10. 桶排序

    - 基本定义：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。首先将各个元素放到对应的桶中，然后在每个桶中再排序。
    - 适用场景：不常用。
    - 基本思想：
    - 时空复杂度分析：
    - 代码实现：



---

## 代码实现细节

1. `Array.sort()`是排序数组的
   `Collection.sort()`是排序`List<Integer>`的，包装类的排序要使用`Collection`

   ```java
   // n
   Integer[] nums = {1,2,3,4,5};
   Arrays.sort(a, Collections.reverseOrder());
   int[] res = new int[nums.length];
   for (int i = 0; i < nums.length; i++){
       res = Integer.valueOf(a[i]);
   }
   ```

2. 关于字符串的那些事

    - `String`可以通过`char[]`直接构造：

      ```java
      char[] crr = {'q','u','i','c','k'};
      String s = new String(crr);
      ```

    - 但是`toString`方法主要转化为字符串，而不是将`char`数组中的字符拼接起来转化为字符串。

      ```java
      public static void main(String[] args) {
          String k = "qucsoa";
          char [] chars = k.toCharArray();
          String m = chars.toString();
          System.out.println(m); // [C@3786659d
      }
      ```

    - `String`可以通过`join`将某一个字符串插入`List`中

      ```java
      List<String> list = new ArrayList<>();
      list.add("1");
      list.add("2");
      list.add("3");
      String.join(" ", wordList);
      // 得到的是"1 2 3"
      ```

    - `trim()`快速取出字符串的前导空格和尾部空格【注意底层实现原理上，`trim()`实质上是双指针实现的。】

      ```java
      String test = "  hello  ";
      String s = test.trim();
      ```

3. `List<String>`互相转换`String[]`的方法

   ```java
   // List<String> 转 String[]
   String[] srr = list.toArray(new String[list.size()]);
   // String[] 转 List<String>
   List<String> list = Arrays.asList(srr);
   ```

4. 将`List<List<String>>`转为`String[][]`的方法，主要用来改变输出，使用动态`ArrayList`能够方便处理，但是如果输出要求是数组形式就有必要转化了。

   ```java
   List<List<String>> list_list_String = new ArrayList<>();
   String [][] array_of_String = new String [list_list_String.size()][];
   int i = 0;
   for (List<String> list_String : list_list_String){
   	array_of_String[i] = list_String.toArray(new String[list_String.size()]);
       // 上面那句话可以写成 list_String.toArray(0) 
   	i++;
   }
   字符串是可以的，但是int的数组不行，只能用包装类Integer
   String[] str = new String[list.size()];
   list.toArray(str);
   String[] str = (String[])list.toArray(new String[list.size()]);
   ```

5. 关于`Arrays.fill()`和`Arrays.binarySearch()`

- 使用`Arrays.fill(new int [],1)`将数组中填满数字1，仅建议在一维数组的情况下使用，二维数组会出错的：

  ```java
      public static void main(String[] args) {
          int [] [] test = new int[3][3];
          int [] fi = new int[3];
          Arrays.fill(fi,43);
  //        执行完这条代码以后的二维数组
  //        [43,43,43]
  //        [43,43,43]
  //        [43,43,43]
          Arrays.fill(test,fi);
          test[1][1] = 89;
  //        执行完这条代码以后的二维数组
  //        [43,89,43]
  //        [43,89,43]
  //        [43,89,43]
  //        因为使用同一行代码进行填充，改变了这一行的某个元素，在数组中就相当于改变了整列的元素
      }
  ```

- `Arrays.binarySearch()`

  ```java
  // 源码
  public static int binarySearch(int[] a, int fromIndex, int toIndex, int key) {
          rangeCheck(a.length, fromIndex, toIndex);
          return binarySearch0(a, fromIndex, toIndex, key);
  }
  // 源码
  private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) {
      int low = fromIndex;
      int high = toIndex - 1;
      while (low <= high) {
          int mid = (low + high) >>> 1;
          int midVal = a[mid];
  
          if (midVal < key)
              low = mid + 1;
          else if (midVal > key)
              high = mid - 1;
          else
              return mid; // key found
      }
      return -(low + 1);  // key not found.
  }
  ```

6. 两层`for`循环时如果想跳到外面的循环。可以借用外循环的名称直接`continue`

```java
out:for (int i = 0; i < n; i++){
    for (int j = 0; j < m; j++){
        if (...){
            continue out;
        }
    }
}
```

7. 获得数组最大值

```java
int max = Arrays.stream(nums).max().getAsInt();
```

8. `List`和`Array`互相转化（针对元素是整数的情况）

- 使用`list.stream().mapToInt(i -> i).toArray()`可以将`List<Integer>`快速转换成数组。

```java
// int
int[] array = list.stream().mapToInt(i -> i).toArray();
// String
String [] strArray = list.toArray(new String[list.size()]);
```

 - 使用`Arrays.asList`可以将数组快速转化成`List`

```java
List<String> list = Arrays.asList(s.split());
```

 - 使用`Arrays.asList`可以将数和数快速转化成`List`

```java
int a = 0;
int b = 0;
List<Integer> list = new ArrayList<>(Arrays.asList(a, b); // 直接创建了一个有a和b的list
```

9. 复制数组：

```java
System.arrayCopy
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
// 代码解释:
	// Object src : 原数组
	// int srcPos : 从元数据的起始位置开始
	// Object dest : 目标数组
	// int destPos : 目标数组的开始起始位置
	// int length  : 要copy的数组的长度
Arrays.copyOf();
```

10. `Arrays.toString()`方法可以产生一维数组（是一维数组，而不是一维整数数组）可打印版本，再想查看数组就可以使用这样的语句：

```java
int[] a = {1,2,3,4,5,6};
System.out.println(Arrays.toString(a));
// 输出：
// [1, 2, 3, 4, 5, 6]
```

11. 代码命名规范

- `java`类名的首字母要大写，并且采用驼峰式的方法

- `java`方法、字段、对象引用名称，首字母小写并采用驼峰式

- `java`的包名，全部采用小写格式，不采用驼峰

- `java`中的`static`和`final`共同修饰的域往往全部采用大写，并用下划线分割单词。

  ```java
  // 包名全部小写
  package com.note; 
  // 包名全部小写
  import java.util.Scanner;    
  // 方法的首字母大写 + 驼峰
  public class StudentClass{     
      // 字段小写 + 驼峰
      int studentAge;
      // 编译时常量（即用final和static共同修饰）必须采用全部大写的格式
      static final int VALUE_ONE = 1;
      String studentName;
      // 方法小写 + 驼峰
      public getName(){
          System.out.println(this.name);
      }
  }
  ```

- 封装的时候要将`public`、`protected`、`void`、`private`依次分别写下来，这样代码的可读性更高。

12. 非常重要的`java`在`ACM`中的操作

- 读入数据可以接收的方式——使用`BufferedReader`

  ```java
  BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));
  ```

- 读入数据最快的方式——使用`java.io`包下的`StreamTokenizer`进行处理

  需要着重记忆的就是该方法读到末尾的时候，标识是`StreamTokenizer.TT_EOF`

  ```java
  StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
  in.nextToken();
  int n = (int)in.nval;
  in.nextToken();
  long p = (long)in.nval;
  in.nextToken();
  double q = in.nval;
  ```

- 写出数据最快的方式——使用`java.io`包下的`PrintWriter`进行处理

  记得使用`flush()`刷新

  ```java
  PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
  int n = 47;
  out.print(n);
  out.flush();
  ```


- 读入数字后再想读入一行字符串的数据，必须使用`nextline()`作为中转和暂停。

  ```java
  // 首先读入数字
  Scanner sc = new Scanner(System.in);
  int num = sc.nextInt();
  // 中转
  sc.nextLine();
  String s = sc.nextLine();
  ```

- 注意某些评测平台的`JDK`版本，很多是没有自动拆箱和装箱机制的，需要自己手动添加。

---

## 代码质量优化

1. 算法优化框架

   理论上讲算法优化分为全局优化和局部优化两个层次。全局优化也叫做结构优化，主要是从基本控制结构和算法、数据结构的选择上考虑；局部优化即为代码优化，包括使用尽量小的数据类型、优化表达式、优化赋值语句、优化函数参数、全局变量等。

    - 全局优化

        - 优化算法设计

          典型的算法优化（基本算法优化）

          | 问题描述     | 原算法           | 新算法                        |
          | ------------ | ---------------- | ----------------------------- |
          | 排序         | 冒泡排序$O(n^2)$ | 归并排序、快速排序$O(n*logn)$ |
          | 递增数组查找 | 遍历$O(n)$       | 二分查找$O(log n)$            |
          |              |                  | 排序 + 二分查找$O(n*log n)$   |
          | 数组遍历     | 双指针$O(n^2)$   | 枚举左维护右$O(n)$            |
          | 斐波那契数列 | 动态规划$O(n)$   | 矩阵快速幂$O(log n)$          |
        
        - 优化数据结构
        
          一个容易被人看懂的程序也同样容易被编译器读懂。
        
        - 优化选择结构
        
          > > 当`if`结构中要判断的并列条件比较多的时候，将它们拆分成多层嵌套的形式，可以减少不必要的判断：
          >
          > ```java
          > int x = 5;
          > // 并列条件比较多的场景
          > if (x > 0 && x <= 2){
          >  ...
          > }
          > if (x > 2 && x <= 4){
          >  ...
          > }
          > if (x > 4 && x <= 6){
          > 
          > }
          > if (x > 6 && x <= 8){
          > 
          > }
          > // 多层嵌套的形式
          > if (x > 0 && x <= 4){
          >  if (x > 0 && x <= 2){
          >      ...
          >  }
          >  if (x > 2 && x <= 4){
          >      ...
          >  }
          > }
          > if (x > 4 && x <= 8){
          >  if (x > 4 && x <= 6){
          >      ...
          >  }
          >  if (x > 6 && x <= 8){
          >      ...
          >  }
          
           > > 嵌套`switch`语句的使用。与上面嵌套`if`差不多
           > 
           > > 为`switch`中的`case`排序，将出现频率多的排在前面
          
        - 优化循环结构（复杂度主要是根据循环而来，所以优化循环结构非常重要）
          
           常用的循环优化技术如下：
          
          > 1. 降阶策略
          >
          >    >部分题目可以通过多个二重循环记录答案来代替三重循环。例如四数之和。
          >
          > 2. 加速原理
          >
          >    >将循环体内的选择结构去掉，提高循环结构的运行效率。
          >
          > 3. 代码外提
          >
          >    >将循环体中与循环变量无关的运算提出，并将其放到循环外，来避免每次循环中的重复操作。
          >
          > 4. 变换循环控制条件
          >
          >    >当某循环变量在循环体中除自身引用之外，已不再控制循环过程时，可以将其从循环中删除。
          >
          > 5. 合并循环
          >
          >    >用一次遍历可以同时求和和最大值最小值，能用一次遍历解决的就用一次。
        
    - 局部优化
   
        - 尽可能使用小的数据类型
   
          > 能用`char`就不要使用`int`，能使用`int`就不要使用`long`...
   
        - 优化表达式
   
          使用圆括号将运算可能不明晰的地方指明
   
        - 自增、自减和三目运算符
   
          对于自增自减运算符在编译底层需要的代码量非常少，例如汇编中就可以只用一句话来代替。
   
        - 减少运算强度
   
          用乘法运算代替平方
   
        - 避免浮点运算
   
          浮点运算非常慢
   
        - 优化赋值语句
   
          减少无效引用，也就是尽可能多地嵌套、调用。
   
          ```java
          List<Integer> list = new ArrayList<>();
          int[] answer = list.stream().mapToInt(i -> i).toArray();
          return answer;
          // 简单地替换为
          return list.stream().mapToInt(i -> i).toArray();
          ```
   
        - 优化函数参数
   
          参数要尽可能的精简
   
2. 细节优化（一些实战注意技巧）：

    - 直接将数字使用“+”进行拼接的效率要低于使用`StringBuilder`。

    - 访问字符串的某个字符，最好先将字符串使用`toCharArray`转化为字符数组，然后再访问；而不是使用`charAt`方法每次调用。

    - 位运算的运行时间非常优秀。能用位运算就不要用除法。





----

## 算法分析 & 数学原理

1. **数据规模与算法选择的关系**（大致关系，不精确）：

- $ 10 ^ 1$，必然的暴力搜索、递归、回溯算法，例如N皇后问题。

- $ 10 ^ 2$ ~ $10 ^ 4$，带有一定递归性质或者是暴力解法，算法复杂度基本都在$ O(n^2)$ 以上

- $10 ^ 4$，算法对应的最差时间复杂度为$O(n^2)$

- $ 10 ^ 4 $ ~ $ 10 ^ 7 $ ，对应为$ O(n * log n )$

- $ 10 ^ 7$ ~ $ 10 ^ 8$ ，对应为$ O(n)$

- $10^8$ 及以上，对应为$ O(log n )$ 甚至是 $O(1)$

- 对$ O(log n )$的直观理解（不要小看了$O(log_{2}{n})$的时间复杂度）

  | $n$             | 1    | 10   | 100  | 1000 | $10 ^ 6$ | $10 ^ 9$ |
    | --------------- | ---- | ---- | ---- | ---- | -------- | -------- |
  | $O(log_{2}{n})$ | 0    | 3    | 7    | 10   | 20       | 30       |

- 计算机一秒内大概可以执行的基本操作次数是$ 10 ^ 8$，基本操作是指赋值、运算、比较，而加减乘除等虽然不是严格的“一次”，但是可以近似看作一次运算。

| 数据量          | $ 10 ^ 1$ | $ 10 ^ 2$ | $10 ^ 3$ | $10 ^ 4$ | $10 ^ 5$ | $ 10 ^ 6 $ | $ 10 ^ 7 $ | $ 10 ^ 8$ |
| --------------- | --------- | --------- | -------- | -------- | -------- | ---------- | ---------- | --------- |
| $O(1)$          | √         | √         | √        | √        | √        | √          | √          | √         |
| $O(logn)$       | √         | √         | √        | √        | √        | √          | √ / ×      |           |
| $O(n)$          | √         | √         | √        | √        | √        | √          |            |           |
| $O(n*logn)$     | √         | √         | √        | √        | √        |            |            |           |
| $O(n^2)$        | √         | √         | √        | √ / ×    |          |            |            |           |
| $O(logn * n^2)$ | √         | √         | √ / ×    |          |          |            |            |           |

| 时间复杂度      | 对应的算法                                                   |
| --------------- | ------------------------------------------------------------ |
| $O(1)$          | 哈希表，公式计算                                             |
| $O(logn)$       | 二分查找，二叉搜索树，堆，`TreeMap`和`TreeSet`中的增删改查，<font color='yellow'>调和级数</font>，快速搜索，<font color='yellow'>贪心</font> |
| $O(n)$          | 普通遍历，<font color='yellow'>贪心</font>                   |
| $O(n*logn)$     | 快速排序                                                     |
| $O(n^2)$        | 冒泡排序，`Bellman-Ford`算法                                 |
| $O(logn * n^2)$ | 暴力求解，递归，回溯                                         |

2. 假设运行时间限制在1秒之内的话：

   | $(数据量) ^ {复杂度}$ | 运行结果                       |
      | --------------------- | ------------------------------ |
   | $10^6$                | 游刃有余地通过                 |
   | $10^7$                | 勉勉强强                       |
   | $10^8$                | 很悬，仅限循环体非常简单的情况 |

3. 递归`dfs()`和迭代`while(...)`的主要区别：

   能使用迭代就不要使用递归，递归好写但是效率低，不论是空间还是时间上。

4. <font color='yellow'>调和级数</font>`LeetCode Q3164`
   $$
   H_{n} = \sum_{i = 1}^{n}{\frac{1}{n}} =  1 + \frac{1}{2} + \frac{1}{3} + ... ≈ ln(n)
   $$
   这道题启示我们，如果外层循环的复杂度是$$m$$，但是内层复杂度依赖于$$1/m$$，那么说明这个双层循环的实际复杂度是$O(n * log(n))$。

5. <font color='yellow'>容斥原理</font>：$$A+B=A∪B+A∩B$$，表示两个集合的并集和交集的关系。







# 算法思想篇

----

其实所有的算法题，在不考虑时间和空间的要求下，都可以按照暴力求解法进行组织安排，或者我们可以叫它“模拟法”。但是暴力求解并不受欢迎，因为不能体现算法深度。

```txt
暴力求解（穷竭搜索）
贪心
回溯（需要记录路径的动态规划）
动态规划（仅需要输出大小和可能性的回溯）
```







-----





## 穷竭搜索（暴力求解）

1. 递归

2. 深度优先搜索（复杂度 —— $O(a ^ n)$）

   > - 深度优先搜索类型——选 or 不选，该类DFS的写法由于选择的空间有限，可以直接枚举，不用循环，dfs(选) + dfs(不选) 就可以了
   >
   > ```java
   > // 给定整数列表nums = [1,2,3,4]，判断是否有组合能够被选出，其和为 target = 7
   > public boolean getAns(int index, int sum){
   > 	if (index == nums.length()){
   > 		return sum == target;
   > 	}
   >     // 加上当前的数
   >     if (getAns(index + 1, sum + nums[i])){
   >         return true;
   >     }
   >     // 不加当前的数
   >     if (getAns(index + 1, sum)){
   >         return true;
   >     }
   >     return false;
   > }
   > ```
   >
   > - 深度优先搜索类型——图遍历，这类DFS问题与上一种也类似，图的方向因题目需要不同，普遍是4方向或者8方向，因此针对所有方向进行for循环即可。
   >
   > ```java
   > // 找最大的水池面积，水池是8连通的
   > // * * *
   > // * W *
   > // * * *
   > // char field[M][N]，其中W代表水，*代表陆地
   > // int ans = 0;
   > public void dfs(boolean[][] arrived, int x, int y, int sum) {
   >     arrived[x][y] = true;
   >     ans = Math.max(ans, sum);
   >     // 枚举所有的方向
   >     int[][] dirs = {{1, 1}, {-1, 1}, {-1, -1}, {1, -1}, {0, 1}, {1, 0}, {-1, 0}, {0, -1}};
   >     for (int[] dir : dirs){
   >         int new_x = x + dir[0];
   >         int new_y = y + dir[1];
   >         if (new_x >= 0 && new_x < arrived.length && new_y >= 0 && new_y < arrived.length && field[new_x][new_y] == 'W' && !arrived[new_x][new_y]){
   >             dfs(arrived, new_x, new_y, sum + 1);
   >         }
   >     }
   > }
   > ```
   >
   > - 深度优先搜索类型——列表遍历，是图遍历和选不选遍历的升级版本，本次要用for循环来取代当初的方向和选不选

3. 广度优先搜索（复杂度——$O(状态数 * 转移的方式)$）

   > - 复杂度计算
   >
   >   ```txt
   >   迷宫问题，可以上下左右四个方向进行探索
   >   一个 M * N 的迷宫，该迷宫的复杂度计算为：
   >   状态数 = 迷宫大小 = M * N
   >   转移方式 = 上下左右 = 4
   >   复杂度 = 4 * M * N = O(M * N)
   >   ```
   >
   > - 广度优先搜索伪代码
   >
   >   ```java
   >   public void bfs(){
   >       while(queue.size() > 0){
   >           queue.pop();
   >           if (condition){
   >               break;
   >           }
   >           // 循环
   >           for (int i = 0; i < n; i++){
   >               if (condition) {
   >                   queue.offer();
   >               }
   >           }
   >       }
   >   }
   >   ```

4. 广度优先与深度优先

   1. 深度优先的实现更简单，能用深度就用深度
   2. 广度优先需要将所有的状态放在队列中挨个排查，需要的空间是与状态数成正比的；但是深度优先的递归深度一般不会太大，因此一般可以认为，深度优先相比之下更节省内存。

5. IDA 和 A剪枝 IDDFS

6. 广度优先搜索的优化（双向广度优先搜索等优化算法）









## 贪心（有策略的暴力求解）

1. 贪心法：贪心法是指在对问题求解时，总做出在当前看来是最好的选择。也就是是说不从整体上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但是对范围相当广的许多问题都能产生整体最优解或者是整体最优解的近似解。如果问题能够用贪心算法来求解的话，往往是非常高效的。

   困难的点在于，你要选的策略是什么？它有没有例外情况？

2. 贪心算法的典型例题：

    ```bash
    1. 背包问题
    	最优装载问题
    	部分背包问题
    	乘船问题
    2. 区间相关问题
    	选择不相交区间
    	区间选点
    	区间覆盖
    3. 霍夫曼算法
    ```

    - 背包问题


> 有1元、5元、10元、50元的硬币各$C_1$、$C_5$、$C_{10}$、$C_{50}$、$C_{100}$、$C_{500}$枚。现在要用这些硬币来支付`A`元，最少需要多少枚钱币？假定本题至少存在一种支付方案。
>
> 限制条件：
>
> - 0 <= $C_1$、$C_5$、$C_{10}$、$C_{50}$、$C_{100}$、$C_{500}$ <= $10^9$
> - 0 <= A <= $10^9$
>
> ```java
   > // ACM模式
   > import java.util.*;
   > public class Main {
   >     public static void main(String[] args) {
   >         Scanner sc = new Scanner(System.in);
   >         int[] coins = new int[6];
   >         int[] value = {1,5,10,50,100,500};
   >         for (int i = 0; i < 6; i ++){
   >             coins[i] = sc.nextInt();
   >         }
   >         int target = sc.nextInt();
   >         int answer = 0;
   >         int coin = 5;
   >         while (target > 0 && coin >= 0){
   >             if (target >= value[coin] && coins[coin] > 0){
   >                 target -= value[coin];
   >                 coins[coin]--;
   >                 answer++;
   >             }
   >             if (target < value[coin] || coins[coin] == 0){
   >                 coin--;
   >             }
   >         }
   >         System.out.println(answer);
   >     }
   > }
   > ```

- 区间贪心

>1. 工作区间调度问题（核心思想：在可选的工作中，每次都选取结束时间最早的任务）
>
>> 有`n`项工作，每项工作分别在$s_i$时间内开始并在$t_i$时间内结束。对于每项工作，你都可以选择参与与否，并且明显地你不能同时参加两个任务，而且参与工作的时间段不能重叠，即使是开始的瞬间和结束的瞬间的重叠也是不允许的，在这种情况下，返回你能参加的最多的工作数。
>>
>> 限制条件：1 <= `N` <= 100000、1 <= $s_i$ <= $t_i$ <= $10^9$
>
>```java
>// 实现方式，按照结束时间排序，然后
>public static void main(String[] args) {
>    Scanner sc = new Scanner(System.in);
>    int length = sc.nextInt();
>    int[] start = new int[length];
   >    int[] end = new int[length];
   >    for (int i = 0; i < length; i++) {
   >        start[i] = sc.nextInt();
   >    }
   >    for (int j = 0; j < length; j++) {
   >        end[j] = sc.nextInt();
   >    }
   >    int[][] task = new int[length][2];
   >    for (int i = 0; i < length; i++) {
   >        task[i][0] = start[i];
   >         task[i][1] = end[i];
   >    }
   >    Arrays.sort(task, (o1, o2) -> o1[1] - o2[1]);
   >     int ans = 0;
   >    int time = 0;
   >    for (int i = 0; i < length; i++) {
   >        if (time < task[i][0]) {
   >             ans++;
   >             time = task[i][1];
   >        }
   >    }
   >    System.out.println(ans);
   >}
   >```
   > 
   > 2. 工作区间覆盖问题（核心思想：先排序，注意按照第一优先级起始时间的升序和第二优先级结束时间的降序实现；最重要的：起始时间在当前搜索区间内的所有区间的最晚结束时间是多久？并产生新的搜索区间，如此循环）
   > 
   > >有`N`头牛，它们每个都有自己的工作区间`[start_time, end_time]`，给定一个总的工作时间`T`，问最少需要多少头牛才能覆盖从1到`T`的工作时间
   >
   >```java
   >public static void main(String[] args) {
   >    Scanner sc = new Scanner(System.in);
>    String s = sc.nextLine();
>    int n = Integer.parseInt(s.split(" ")[0]);
>    int len = Integer.parseInt(s.split(" ")[1]);
>    int[][] table = new int[n][2];
>    for (int i = 0; i < n; i++) {
>        String[] split = sc.nextLine().split(" ");
>        table[i][0] = Integer.parseInt(split[0]);
>        table[i][1] = Integer.parseInt(split[1]);
   >    }
   >
   >     // 按照开始时间排序，如果开始时间相同，就按照结束时间最晚的选择
   >     Arrays.sort(table, (o1, o2) -> o1[0] - o2[0] == 0 ? o2[1] - o1[1] : o1[0] - o2[0]);
   >     // 默认开局选一个
   >     int ans = 1;
   >     // 代表当前需要覆盖的位置
   >     int currentStart = 1;
   >     // 代表当前选择轮次下，能够达到的最远右侧
   >     int currentEnd = 1;
   >     for (int i = 0; i < n; i++) {
   >         int[] workTime = table[i];
   >         // 如果开始时间大于 1，禁止
   >         if (i == 0 && workTime[0] > 1) {
   >             break;
   >         }
   >         if (currentStart >= workTime[0]) {
   >             // 代表当前已经选择了，这个不算
   >             currentEnd = Math.max(currentEnd, workTime[1]);
   >         } else {
   >             ans++;
   >             currentStart = currentEnd + 1;
   >             // 代表可以覆盖
   >             if (currentStart >= workTime[0]){
   >                 currentEnd = Math.max(currentEnd, workTime[1]);
   >             } else {
   >                 // 代表两个区间是断的，需要覆盖的节点不在工作时间内
   >                 // ----          ------
   >                 //    ｜              |
   >                 //    currentStart   ｜
   >                 //                    workTime[0]
   >                 break;
   >             }
   >         }
   >         // 代表已经覆盖完毕，结束
   >         if (currentEnd >= len) {
   >             break;
   >         }
   >     }
   >     if (currentEnd >= len) {
   >         System.out.println(ans);
   >     } else {
   >         System.out.println(-1);
   >     }
   > }
   > ```
   > 



---

## 回溯（带剪枝的暴力求解——需要路径）

1. 回溯与动态规划

   两种算法的底层本质是一样的，都是尽可能地遍历全部的情况得出最后的答案。但是二者的区别也十分明显——作为动态规划问题，我们只需要给出可行性和最大最小值，而回溯法往往是要求给出具体的解集。根据这个特点，动态规划在遍历的过程中就可以根据比大小进行剪枝，不需要用函数递归依次记录路径，可以采用固定的数组记录答案，简单的循环就基本可以解决；回溯法虽然也可以进行剪枝判断，但是受制于必须记录路径，因此大部分情况我们都要采用递归。

   <font color = 'yellow'>简单来说，**需要记录路径或者具体返回解集的问题，基本上是回溯问题**；而求解可行性、最大值、最小值的问题，使用动态规划就可以解决。</font>

2. 回溯法的特点

    - 回溯法可以看作是暴力解法的升级版，在每一步的过程中代码都尝试所有的选项，如果可以就记录下来并逐步回溯到上一个分支，如果不可以就直接回溯到上一个分支，本质上就是暴力解法，但是在具体问题迭代递归的过程中，我们可以实行剪枝的操作，这样就给代码的实现带来了很强的灵活性。

    - 回溯法往往要使用深度优先遍历，深度优先遍历往往借助于递归实现。

      递归函数的模板如下：

      ```java
      // 回溯法递归函数模板
      /**
       * @param nums   供我们递归检索的数组，通常是题中提供的
       * @param index  记录当前走的步数，已经移动到了哪里
       * @param path   记录这一条路上经过的节点
       * @param ans    记录答案，有时候可以用大小为1的数组实现求和等操作
       */
      private void dfs(int[] nums, int index, List<Integer> path, List<List<Integer>> ans){
          // 先写退出递归的条件
          if (index == nums.length){
              ans.add(new ArrayList<>(path)); // 要使用new ArrayList<>()才可
          } else {
              // else内容中要适当调整，根据题意剪枝
              // 回溯的分支一
              dfs(nums, index + 1, path, ans);
              // 回溯的分支二
              path.add(nums[index]);   // 先添加
              dfs(nums, index + 1, path, ans);  // 再递归
              path.remove(path.size() - 1);  // 移除
          }
      }
      ```
      
    - 递归的时候还可以借用栈存储状态，合适的时候将内容从栈中弹出去，递归之前将内容压入栈。
    
3. 回溯法常用的剪枝方法（比较关键，需要积累和实践）

    - 使用`HashSet`剪枝：回溯过的情况存到`Set`中，如果`Set`中不存在下一次要递归的内容，那么在递归，可以节省非常多的时间。
    
4. 





---

## 动态规划（记忆化暴力求解——不需要路径）

1. 动态规划与记忆化搜索

   动态规划的转移方程有两种实现方式，一种是普通的循环，例如背包问题；另一种就是记忆化搜索了。

   动态规划的本质是记忆化搜索，然而记忆化搜索的思想与动态规划的思想并不太一致：

   动态规划：这个阶段的问题遇上一个阶段有明显关联，直接使用动态转移方程查找就可以，查找的对象就是记录在数组中的结果。（<font color=yellow>动态转移方程明确，从这个状态直接可以跳转到另一个状态</font>）

   记忆化搜索：这个阶段的问题与上一个阶段的问题不知道有没有关联，本质上是递归，如果该层递归已经做过了，那么直接从数组中取出就可以，如果没有做过，那么递归。（<font color=yellow>动态转移方程不明确，递归记录答案</font>）

   > 如果对记忆化搜索还不是很熟练的情况下，很可能会将各种参数都写在递归函数上，在需要剪枝的情况下这种写法非常有效，但是这种方式对实现记忆化搜索是非常困难的。
   >
   > 针对这种情况，可以适当采取将某些参数放在方法外面的方式，并将这些参数以数组或者静态变量的方式实现。

2. 动态规划小技巧

    - 动态规划的核心思想

        - 首先是大问题划分为小问题的思维。

        - S其次是用空间换时间的思维。需要计算当前情况下的结果，我们需要什么样的输入参数呢？这样的输入参数可不可以通过记录在数组中的形式来避免重复计算？

    - 动态规划一般不会涉及到三维数组，尤其对于面试测试题而言

    - 有两种变化，可以创建两个`DP`数组来回转化，同时也可以采用向前找更远的位置，这部分要根据题意想

        ```java
        // 例如打家劫舍 Q198，不允许偷相邻的
        // 方案一：int[] rob ---- int[] notRob, i - 1 与 i 相互更新
        // 方案二：int[] ans = Math.max(ans[i - 1], ans[i - 2])
        ```

    - 有三种粉刷方式，可以创建三个`DP`数组互相更新

    - 动态规划的转移方程可以列表显示，而且在列表规划的过程中，每一步都必须符合基本题意，不能凑数，一旦凑数开始，就很难再找到规律

3. 动态规划的解题思路

   > - $\color{yellow}问题定义$（问题定义的好坏直接影响时间复杂度）
   > - $\color{yellow}由问题的拆分转变为递归方法，递归方法进一步简化成为记忆化搜索，最后转变为动态规划$
   > - $\color{yellow}得到动态转移方程$
   > - $\color{yellow}解决初始化问题$
   > - $\color{yellow}选择合适的遍历方向$

4. 动态规划问题分类（参考[链接](https://leetcode.cn/circle/discuss/tXLS3i/)）

    1. 入门DP

        > 

    2. 网格图DP

    3. 背包DP

    4. 线性DP

    5. 状态机DP

    6. 划分型DP

    7. 线性DP

    8. 区间DP

    9. 状态压缩DP

    10. 数位DP

    11. 数据结构优化DP

    12. 树形DP

    13. 图DP

    14. 博弈DP

    15. 其他专题

5. 第一类动态规划问题——背包问题

    - 什么是背包问题

      给定一组物品，每种物品都有自己的重量和价格，要在限定的总质量内，我们如何选择，才能使得物品的总价格最高。

    - 背包问题分类

      背包问题主要分为零一背包问题、完全背包问题、多重背包问题。

    - 零一背包问题（最基础的问题，涉及了一部分记忆化搜索的内容）

      题目描述：一共有N件物品，每件物品都只有一件，第`i`件物品的重量为`w[i]`，价值是`v[i]`，在总质量不超过背包上限`W`的情况下，能够装入背包的最大价值是多少？

      > 第一种解法

      ```java
      // 空间优化版本
      int [] weights; // 要提前排序
      int [] values;   
      int [] dp = new int [W + 1]; 
      int W; // 背包容量上限
      dp[0] = 0; 
      for (int i = 0; i < weights.length; i++){ 
          for (int j = W; j >= weights[i]; j--){ // 逆向枚举 
              dp[j] = Math.max(dp[j],dp[j - weights[i]] + values[i]);
          }
      }
      ```

      > 第二种解法（挑战程序设计竞赛——基础递归解法）

      ```java
      // 从最复杂的递归开始
      int[] weights;
      int[] values;
      public int dfs(int i, int j){ // i代表第几个物品，j代表容量
          int res = 0;
          if (i == n){
              // 退出条件
              res = 0;
          } else if (j < weights[i]) {
              // 代表装不下这个物品
              res = dfs(i + 1, j);
          } else {
              res = Math.max(dfs(i + 1, j), dfs(i + 1, j - weights[i]) + values[i]); // 代表递归的两种分支，装和不装
          }
          return res;
      }
      ```

      > 第三种解法（挑战程序设计竞赛——记忆化搜索）

      ```java
      // 创建记忆化数组
      int n; // 代表物品的数量
      int W; // 代表背包的大小
      int[] w; 
      int[] v;
      int[][] dp = new int [n + 1][W + 1]; // 初始化为-1
      public int dfs(int i, int j){
          if (dp[i][j] >= 0){
              return dp[i][j]; // 这就是记忆化搜索，做过了就不再做了
          }
          int res;
          if (i == n){
              res = 0;
          } else if (j < w[i]){
              res = dfs(i + 1, j);
          } else {
              res = Math.max(dfs(i + 1, j), dfs(i + 1, j - w[i]) + v[i]);
          }
          dp[i][j] = res;
          return res;
      }
      ```

      > 第四种解法（挑战程序设计竞赛——动态规划）
      >
      > 这种解法的关键在于定义：**`dp[i][j]`代表的是从第`i`个物品开始挑选总重小于`j`时，总价值的最大值。**
      >
      > 这个定义与上面的记忆化搜索如出一辙，这就暗示我们，实际上可以通过记忆化搜索推导动态规划的状态转移方程
      > $$
      > \begin{align}
      > & dp[n][j] = 0 \\
      > & dp[i][j]=\begin{cases}dp[i + 1][j] &j<w[i]\\ max(dp[i+1][j], dp[[i + 1][j - w[i]] + v[i])& others\end{cases}
      > \end{align}
      > $$

      ```java
      int n; // 代表物品的数量
      int W; // 代表背包的大小
      int[] w; 
      int[] v;
      int[][] dp = new int [n + 1][W + 1];
      public int solve(){
          for (int i = n - 1; i >= 0; i--){ // 逆向遍历
              for (int j = 0; j <= W; j++){
                  if (j < w[i]){
                      dp[i][j] = dp[i + 1][j];
                  } else {
                      dp[i][j] = Math.max(dp[i + 1][j], dp[i+1][j - w[i]] + v[i]);
                  }
              }
          }
          return dp[0][W]; // 注意返回值
      }
      ```

      > 第五种解法（挑战程序设计竞赛——动态规划）
      >
      > 这种解法的关键在于定义：**`dp[i][j]`代表的是从`0`到`i`这`i + 1`物品中挑选出总重量不超过`j`时，总价值的最大值。**
      >
      > 这个定义与上面的记忆化搜索如出一辙，这就暗示我们，实际上可以通过记忆化搜索推导动态规划的状态转移方程
      > $$
      > \begin{align}
      > & dp[0][j] = 0 \\
      > & dp[i + 1][j]=\begin{cases}dp[i][j] &j<w[i]\\ max(dp[i][j], dp[[i][j - w[i]] + v[i])& others\end{cases}
      > \end{align}
      > $$

      ```java
      int n; // 代表物品的数量
      int W; // 代表背包的大小
      int[] w; // 物品重量
      int[] v; // 物品价值
      int[][] dp = new int [n + 1][W + 1];
      public int solve(){
          for (int i = 0; i < n; i++){
              for (int j = 0; j <= W; j++){
                  if (j >= w[i]){
                      dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - w[i]] + v[i]);
                  } else {
                      dp[i + 1][j] = dp[i][j];
                  }
              }
          }
      }
      ```

      > 第六种解法——

    - 完全背包问题

      题目描述：一共有N件物品，每件物品有无数件，第`i`件物品的重量为`w[i]`，价值为`v[i]`，在总质量不超过背包上限W的情况下，能够装入背包的最大价值是多少？

      ```java
      // 正常版本
      int MAX_N;
      int MAX_W;
      int[] w;
      int[] v;
      int[][] dp = new int[MAX_N + 1][MAX_W + 1];
      for (int i = 0; i < MAX_N; i++){
          for (int j = 0; j < MAX_W; j++){
              for (int count = 0; count * w[i] <= j; count++){
                  dp[i + 1][j] = Math.max(dp[i][j - count * w[i]] + v[i] * count, dp[i + 1][j + 1]);
              }
          }
      }
      ```

      ```java
      // 空间优化版本
      int [] wieghts; // 要提前排序
      int [] values;
      int [] dp = new int [W + 1];
      dp[0] = 0;
      for (int i = 0; i < weight.length; i++){
          for (int j = weights[i]; j <= W; j++){ // 正向枚举
              dp[j] = Math.max(dp[j],dp[j - weight[i]] + values[i]);
          }
      }
      ```

    - 多重背包问题

      > 题目描述：一共有N种物品，现在第`i`种物品的数量的上限是`n[i]`，重量是`w[i]`，价值为`v[i]`。在重量不超过W的情况下，能够装入背包的最大价值是多少？

      标准解法：三重循环遍历

      ```java
      // 空间优化版本
      int [] numbers;
      int [] weights; // 要提前排序
      int [] values;
      int [] dp = new int [W + 1];
      dp[0] = 0;
      for (int i = 0; i < weight.length; i++){
          for (int j = W; j >= weights[i]; j--){ // 逆向枚举
              for (int k = 0; k <= numbers[i]; k++){
                  dp[j] = Math.max(dp[j], dp[j - k * weights[i]] + k * values[i]);
              }
          }
      }
      ```

      多重背包问题的另一种解（注意这个环境下的数据，价值被限定在较小的区间以内，而重量被无限扩大，所以这种情况下遍历价值）

      > 重新定义`dp[i + 1][j]`为前`i`个物品中挑选出价值总和为`j`时总重量的最小值（不存在时就是一个充分大的数值）

      当价值较小的解法：

      ```java
      // values的和较小的遍历
      int n; // 物品的种类数
      int max_value; // 所有价值的最大值
      int[][] dp = new int[n + 1][n * max_value + 1];
      // 初始化
      dp[0][0] = 0;
      for (int i = 0; i < n * max_value + 1; i++){
          dp[0][i] = Integer.MAX_VALUE;
      }
      // 遍历开始
      for (int i = 0; i < n; i++){
          for (int j = 0; j <= max_value * n; j++){
              if (j < v[i]){
                  dp[i + 1][j] = dp[i][j];
              } else {
                  dp[i + 1][j] = Math.min(dp[i][j], dp[i][j - v[i]] + w[i]);
              }
          }
      }
      int res = 0;
      // 遍历一遍，找到令 dp[n][j] <= W 最大的j
      for (int i = 0; i <= max_value * n; i++){
          if (dp[n][i] <= W){
              res = i;
          }
      }
      return res;
      ```

    - 关于多重背包的代码书写谬误

        - 注意零一背包问题，是逆向枚举，因为需要访问上一行记录的数据；多重背包问题，是顺向枚举，因为需要访问这一行的数据；多重背包问题，是逆向枚举，原因要部分地访问上一行的数据。

- 注意背包问题的遍历，外层必须是`N`，内层必须是需求`W`，换句话说外层必须遍历待选物品的个数，内层必须遍历背包容量，每次外层遍历都是以更新背包容量内的内容为目标。

    - 初始化的数组不够长，数组的访问特别容易越界。

- 背包问题的迭代是要涉及到容量为`0`的情况的，所以不能认为容量为`0`没有实际意义就不遍历。

- 总结：

  如果使用二维的`dp`数组，是不用考虑正向枚举或逆向枚举的。

  在内部的遍历过程中，直接使用`j >= weights[s] `消除`if `语句。

6. 第二类动态规划问题——序列DP问题

    - **LIS**（最长上升子序列，`Longest Increasing Subsequence`）

      > 注意这里的序列是不可变的，所以保证了答案的顺序性，即前面遍历的内容一定会成为后面的子答案

        - $O(n^2)$时间复杂度的解法

          ```java
          // ACM模式
          public static void main(String[] args) {
              Scanner sc = new Scanner(System.in);
              int n = sc.nextInt();
              int[] nums = new int[n];
              for (int i = 0; i < n; i++) {
                  nums[i] = sc.nextInt();
              }
              int[] dp = new int[n + 1];
              Arrays.fill(dp, 1);
              for (int i = 0; i <= n; i++) {
                  for (int j = 0; j < i; j++) {
                      if (dp[i] > dp[j]) {
                          dp[i] = Math.max(dp[i], dp[j] + 1);
                      }
                  }
              }
              int answer = 1;
              for (int i = 0; i <= n; i++) {
                  answer = Math.max(answer, dp[i]);
              }
              System.out.println(answer);
          }
          ```

        - $O(n*log{n})$时间复杂度的解法（本质是贪心 + 二分）

          ```java
          // ACM模式
          public static void main(String[] args) {
              Scanner sc = new Scanner(System.in);
              int n = sc.nextInt();
              int[] nums = new int[n];
              for (int i = 0; i < n; i++) {
                  nums[i] = sc.nextInt();
              }
              int[] dp = new int[n];
              int answer = 0;
              Arrays.fill(dp, Integer.MAX_VALUE);
              for (int i = 0; i < n; i++){
                  int start = 0;
                  int end = answer;
                  while (start < end){ // 二分查找
                      int mid = (start + end) >> 1;
                      if (dp[mid] < nums[i]){
                          start = mid + 1;
                      } else if (dp[mid] > nums[i]){
                          end = mid;
                      } else {
                          end = mid;
                      }
                  }
                  dp[start] = nums[i];
                  if (end == answer){
                      answer++;
                  }
              }
              System.out.println(answer);
          }
          ```

    - **LCS**（最长公共子序列，`Longest Common Subsequences`）

      > 递推关系式
      > $$
      > \begin{align}
      > dp[i + 1][j + 1]=\begin{cases}max(dp[i][j] + 1, dp[i][j + 1], dp[i + 1][j]) & s_{i + 1} = t_{j + 1}\\ max(dp[i][j + 1], dp[[i + 1][j])& others\end{cases}
      > \end{align}
      > $$

      ```java
      public int lengthOfLCS(String s, String t) {
          int m = s.length();
          int n = t.length();
          int[][] dp = new int[m + 1][n + 1];
          for (int i = 0; i < m; i++){
              for (int j = 0; j <= n; j++){
                  if (s.charAt(i) == t.charAt(j)){
                      dp[i + 1][j + 1] = Math.max(dp[i][j] + 1, Math.max(dp[i][j + 1],dp[i + 1][j]));
                  } else {
                      dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);
                  }
              }
          }
          System.out.println(dp[m][n]);
      }
      ```

7. 第三类动态规划问题——矩阵中的DP



8. 第四类动态规划问题——滚动数组

   滚动数组动态规划（`Kadane`算法）

   Q53 Q1014

   ```java
   public int maxSubArray(int[] nums) {
       int answer = nums[0];
       int pre = 0;
       for (int num : nums){
           // 带上前面和不带上前面，哪一个更好？
           pre = Math.max(pre + num ,num);
           // 记录答案用
           answer = Math.max(pre,answer);
       }
       return answer;
   }
   
   public int maxScoreSightseeingPair(int[] values) {
       int answer = Integer.MIN_VALUE;
       int log = values[0] + 0;
       for(int i = 1;i<values.length;i++){
           answer = Math.max(answer,log + values[i] - i);
           log = Math.max(log,values[i] + i);
       }
       return answer;
   }
   ```



9. 第五类动态规划问题——多序列多变量同时规划1567

   股票问题

10. 第六类动态规划问题——回文字符串系列

    Q516

11. 第七类动态规划问题——计数动态规划

    - 问题A：

      > 有`n`个完全相同的物品，将他们划分不超过`m`组，求划分方法总数模`M`的余数

      >  主要要考虑到`1 + 1 + 2`和`1 + 2 + 1`本质上是不同的两种划分方式

      ```java
      // ACM
      public static void main(String[] args) {
          Scanner sc = new Scanner(System.in);
          int n = sc.nextInt(); // n obj
          int m = sc.nextInt(); // m group
          int mod = sc.nextInt();
          int[][] dp = new int[m + 1][n + 1];
          dp[0][0] = 1;
          for (int i = 1; i <= m; i++){
              for (int j = 0; j <= n; j++){
                  if (j - i > 0) {
                      dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;
                  } else if (i == j){ 
                      dp[i][j] = 1;
                  } else {
                      dp[i][j] = dp[i - 1][j];
                  }
              }
          }
          System.out.println(dp[m][n]);
      }
      ```

    - 问题B：

      > 有`n`种物品，第`i`种物品有$a_i$个。不同种类的物品可以互相区分但是相同种类的无法区分，从这些物品种取出`m`个的话有多少种取法？

      > 关键是要知道什么时候会出现重复，以及重复的情况出现在哪里。

      ```java
      // ACM
      public static void main(String[] args) {
          Scanner sc = new Scanner(System.in);
          int n = sc.nextInt(); // obj
          int m = sc.nextInt(); // group
          int[] nums = new int[n];
          for (int i = 0; i < n; i++) {
              nums[i] = sc.nextInt();
          }
          int mod = sc.nextInt();
          int[][] dp = new int[n + 1][m + 1];
          // get 0 obj is 1 case 
          for (int i = 0; i <= n; i++){
              dp[i][0] = 1;
          }
          for (int i = 0; i < n; i++){
              for (int j = 1; j <= m; j++){
                  if (j - 1 - nums[i] >= 0){
                      dp[i + 1][j] = (dp[i + 1][j - 1] + dp[i][j] - dp[i][j - 1- nums[i]] + mod) % mod;
                  } else {
                      dp[i + 1][j] = (dp[i + 1][j - 1] + dp[i][j] + mod) % mod;
                  }
              }
          }
          System.out.println(dp[n][m]);
      }
      ```





12. 尚不能分类的动态规划问题

13. 典型动态规划问题

    - 题目内容：【POJ_1065】有`N`个木棒，它们的长度和重量分别是`l`和`w`，需要将木棒按照$l_i$ <= $l_j$并且$w_i$<=$w_j$的顺序排列，如果不能在一组中做到，就可以另起炉灶，求通过怎样分配能够使得组数最小？不需要返回分配方案要返回最小组数。

      > 答案就等于第二个未排序维度的最长下降子序列的长度。（暂时不会证明）

      ```java
      // ACM
      public static void main(String[] args) throws Exception {
          Scanner sc = new Scanner(System.in);
          int turn = sc.nextInt();
          while (turn-- > 0){
              int length = sc.nextInt();
              int[][] sticks = new int[length][2];
              for(int i = 0; i < length; i++){
                  sticks[i][0] = sc.nextInt();
                  sticks[i][1] = sc.nextInt();
              }
              Arrays.sort(sticks, new Comparator<int[]>() {
                  @Override
                  public int compare(int[] o1, int[] o2) {
                      return o1[0] - o2[0] == 0 ? o1[1] - o2[1] : o1[0] - o2[0]; // 升序排列
                  }
              });
              int temp = -1;
              int[] dp = new int[5005];
              for (int i = 0; i < length; i++){
                  dp[i] = 1;
                  for (int j = 0; j < i; j++){
                      if (sticks[i][1] < sticks[j][1]){ // 比较第二个维度，如果出现下降，那么就说明要新开一个数组
                          dp[i] = Math.max(dp[i],dp[j] + 1);
                      }
                  }
                  temp = Math.max(dp[i],temp); // 答案等于最长下降子序列的长度
              }
              System.out.println(temp);
          }
      }
      ```

    - 题目内容：【POJ3046】有`t`组蚂蚁，总数为`a`，同一组蚂蚁没有区别，求`s~e`只蚂蚁可以组成多少个不同的组？

      > 设`dp[i][j]`表示前i种蚂蚁拿出j只能划分成多少组。
      > 则不难推出转移方程：`d[i][j] = sum(d[i-1][j-k])`，其中`k = min(x[i], j)`，`x[i]`为`i`类蚂蚁的个数。
      > 但是这样来递推复杂度太高。
      > 当`j<=x[i]`,将其右边展开得到`d[i][j] = d[i-1][j] + d[i-1][j-1] + ... + d[i-1][0]`。
      > 将第一项`d[i-1][j]`单独抽离出来，就可以发现剩下的相当与`d[i][j-1]`(根据一开始的转移方程)。
      > 所以得到`d[i][j] = d[i-1][j] + d[i][j-1]`。
      > 接下来考虑`j > x[i]`,同样将其展开，右边变成：
      >
      > `d[i-1][j] + d[i-1][j-1] + ... + d[i-1][j-x[i]]`
      >
      > 为了像`j<=x[i]`时将后面凑出一个整项，在这个式子后再添加两项。变成：
      >
      > `d[i-1][j] + d[i-1][j-1] + ... + d[i-1][j-x[i]] + d[i-1][j-1-x[i]] - d[i-1][j-1-x[i]]`
      > 将第一项抽里出来，同样发现剩下的除了最后一项外，中间的所有项可以凑成`d[i][j-1]`，所以此时转移方程如下：
      >
      > `d[i][j] = d[i-1][j] + d[i][j-1] - d[i-1][j-x[i]-1]`

      ```java
      import java.util.*;
      public class Main {
          public static void main(String[] args) throws Exception {
              Scanner sc = new Scanner(System.in);
              int type_of_ants = sc.nextInt();
              int num_of_ants = sc.nextInt();
              int questionOne = sc.nextInt();
              int questionTwo = sc.nextInt();
              int[] type_num = new int[type_of_ants];
              for (int i = 0; i < num_of_ants; i++){
                  type_num[sc.nextInt() - 1]++;
              }
              int k = 0;
              int[][] dp = new int[2][100 * 1005];
              // 初始化
              dp[0][0] = 1;
              dp[1][0] = 1;
              for (int i = 0; i < type_of_ants; i++){
                  k = i & 1;
                  for (int j = 1; j <= num_of_ants; j++){
                      if (j <= type_num[i]) dp[k][j] = (dp[k ^ 1][j] + dp[k][j - 1] + 1000000) % 1000000;
                      else dp[k][j] = (dp[k ^ 1][j] + dp[k][j - 1] - dp[k ^ 1][j - type_num[i] - 1] + 1000000) % 1000000;
                  }
              }
              int ans = 0;
              for (int i = questionOne; i <= questionTwo; i++){
                  if (dp[k][i] >= 0) ans += dp[k][i];
                  ans = ans % 1000000;
              }
              System.out.println(ans);
          }
      }
      ```



    - 

---

## 博弈论

1. 博弈论问题定义：

   博弈论问题一般有如下几个特点：

   > 博弈模型为两人轮流决策的非合作博弈，即两个人轮流进行决策，并且两人都使用最优策略来获取胜利
   >
   > 博弈是有限的，即无论两个人怎样决策，都会在有限步后决出胜负
   >
   > 公平胜负：即两个人进行决策所遵循的规则相同

   博弈是信息学和数学试题中常会出现的一种类型，算法灵活多变是其最大特点，而其中有一类试题更是完全无法用常见的博弈树来进行解答。 $\color{yellow}寻找必败态即为针对此类试题给出一种解题思路$。

2. 博弈论本身非常难，基于ACM或算法题的要求，此处仅涉猎部分内容。

3. 理论铺垫：

   - 定义P-position和N-position：其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-position，也就是“先手必败”，现在轮到move的人有必胜策略的局面是N-position，也就是“先手可保证必胜”。

     无法进行任何移动的局面（也就是terminal position）是P-position；

     可以移动到P-position的局面是N-position；

     所有移动都导致N-position的局面是P-position。

   - P/N状态有如下性质：

     若面临末状态者为获胜则末状态为胜态否则末状态为必败态。
     一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。
     一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态

   - P点： 即必败点，某玩家位于此点，只要对方无失误，则必败；

   - N点： 即必胜点，某玩家位于此点，只要自己无失误，则必胜。

   - 取石子游戏算法实现

     ​	步骤1:将所有终结位置标记为必败点（P点）；

     ​	步骤2: 将所有一步操作能进入必败点（P点）的位置标记为必胜点（N点）

     ​	步骤3:如果从某个点开始的所有一步操作都只能进入必胜点（N点） ，则将该点标记为必败点（P点） ；

     ​	步骤4: 如果在步骤3未能找到新的必败（P点），则算法终止；否则，返回到步骤2

4. 常用的几个模型（通常是`Alice`先手，`Bob`后手）

   - 巴什博弈（`Bash Game`）

     > 题目内容：有`n`个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取`m`个，最后拿光的人获胜。
     >
     > 分析：如果$n = m + 1$，那么由于一次最多拿`m`个，所以无论先取者拿走了多少个，后者都能一次取光并获胜。因此取胜法则在于：如果$n = (m + 1) * r + s$，那么只要先取者拿走`s`个物品，后手者拿走`k`个，先手再拿走`m + 1 - k`个就能保证先手者必胜。总之给对手留下`(m + 1)`的倍数，就能最后获得胜利；如果$(n - 1) \% (m + 1) == 0$则后手胜利。

     ```java
     // 先手必胜的条件就是 s! = 0
     if (n % (m + 1) != 0){
         return "Alice";
     } else {
         // 否则后手必胜
         return "Bob";
     }
     ```

   - 威佐夫博弈（`Wythoff's game`）

     > 题目内容：有两堆各若干个物品，两个人轮流从某一堆或者同时从两堆中取同样多的物品，规定每次至少取一个，多者不限。
     >
     > 解决思路：设$(a_i,b_i)$表示两堆物品的数量并称其为局势，如果Alice面对$(0,0)$，那么Alice已经失败了，这种局势我们称其为奇异局势。
     >
     > 奇异局势的计算公式：$a_k = [k (1 + \sqrt5) / 2], b_k = a_k + k$。
     >
     > 【首先求出差值，差值*黄金分割比 == 最小值则是奇异局势】
     >
     > 简单来说，如果开局满足奇异局势的条件，则先手必败；反之后手必败。

     ```java
     public String Wgame(int a, int b){
         double r = (Math.sqrt(5.0) + 1) / 2;
         int d = (int)(Math.abs(a - b) * r);
         if (d != min(a,b)){
             // 不满足奇异局势，先手必胜
             return "Alice";
         } else {
             return "Bob";
         }
     }
     ```

   - 尼姆博弈`Nim game`

     > 题目内容：给定`n`堆物品，第`i`堆物品有$A_i$个，两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品获胜，两人都采取最优策略，问是否先手必胜？
     >
     > 解决思路：用$(A_1,A_2,A_3,A_4...)$代表当前的状态，还是一样要寻找必败状态，或者是奇异状态。
     >
     > 公式：将每堆石子的数量转化成二进制，如果异或结果为0，那么先手必败。

     ```java
     public String Ngame(int[] stones){
         int answer = 0;
         for (int i = 0; i < stones.length; i++){
             answer ^= stones[i];
         }
         if (answer == 0){
             // 是奇异状态，先手必败
             return "Bob";
         } else {
             // 非奇异状态，先手必胜
             return "Alice";
         }
     }
     ```

   - 斐波那契博弈

     > 问题定义：有一堆石子个数为`n`，游戏双方轮流取石子，满足：1）先手不能在第一次把所有的石子都取完；2）之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含）。约定取完最后一个石子的人获胜。
     >
     > 解决思路：寻找必败状态和奇异状态。根据“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。如n=83 = 55+21+5+2，我们看看这个分解有什么指导意义：假如先手取2颗，那么后手无法取5颗或更多，而5是一个Fibonacci数，那么一定是先手取走这5颗石子中的最后一颗，同理，接下去先手取走接下来的后21颗中的最后一颗，再取走后55颗中的最后一颗，那么先手赢。
     > 公式：如果`n`是斐波那契数，先手必败；

     ```java
     public String Fgame(int n){
         if (/*n是斐波那契数*/){
             return "Bob";
         } else {
             return "Alice";
         }
     }
     ```

5. 针对于ACM的一般博弈问题【高端】求解过程：

   ```mermaid
   graph LR
   	S("开始")
   	A("将博弈问题抽象为ICG问题")
   	B("使用SG函数")
   	C("构建为尼姆博弈问题")
   	D("求解")
   	E("结束")
   	S-->A
   	A-->B
   	B-->C
   	C-->D
   	D-->E
   ```

    - 前期准备：

      - 定义$mex$运算，这是一个施加于集合的运算，表示$最小的不属于这个集合的非负整数$。例如：$mex(0,1,2,4) = 3$

      - 对于一个给定的有向无环图，定义关于图的每个顶点的$SG$函数：$SG(x) = mex(SG(y)|y是x的后继)$

      - $SG$函数的基本求法框架：

        1. 找出必败态

        2. 找出当前所有状态的前驱结点

        3. 根据定义计算结点SG值

        4. 重复上述步骤，直到整棵树建立完成

    - $ICG$问题的定义【公平组合博弈（`Impartial Combinatori Games`）】

      1. 两人参与
      2. 游戏局面的状态集合是有限的
      3. 对于同一个局面，两个游戏者可操作的集合完全相同
      4. 游戏者轮流进行游戏
      5. 当无法进行操作时游戏结束，此时不能进行操作的一方算输
      6. 无论游戏如何进行，总可以在有限步数之内结束

      模型：事实上，这个游戏可以认为是所有公平组合游戏（ICG）的抽象模型。其实，任何一个ICG都可以通过把每个局势看成一个顶点，对每个局势和它的子局势连一条有向边来抽象成这个“有向图游戏”。

    - 如何通过$SG$函数来解决问题？

      对于$n$个棋子，设它们对应的顶点的$SG$值分别是$(a_1,a_2,...,a_3)$，再设局面$(a_1,a_2,...,a_3)$时的$Nim$游戏的一种必胜策略是把$a_i$变成$k$，那么原游戏的一种必胜策略就是把第$i$枚棋子移动到一个$SG$值为$k$的顶点。

      简单来讲，我们让每个节点都拥有一个$SG$值（假设这个值为$x$），那么对于任意一个玩家操作（移动到当前节点的某个后继节点）实际上就是把棋子移动到$\{0,...,x-1\}$的某个节点上，等价的就是从$x$个物品中取走至少一个，至多$x$个。

   > 1、性质：
   >
   > （1）所有的终结点所对应的顶点，其SG值为0，因为它的后继集合是空集——所有终结点是必败点（P点）。
   >
   > （2）对于一个`sg(x)=0`的顶点`x`，它的所有后继`y`都满足`sg(y)!=0`——无论如何操作，从必败点（P点）都只能进入必胜点（N点）【对手走完又只能把N留给我们】。
   >
   > （3）对于一个`sg(x)!=0`的顶点，必定存在一个后继点`y`满足`sg(y)=0`——从任何必胜点（N点）操作，至少有一种方法可以进入必败点（P点）【就是那种我们要走的方法。
   >
   > 2、应用：
   >
   > （1）可选步数为1-m的连续整数，直接取模即可，`SG(x) = x % (m+1)`；
   >
   > （2）可选步数为任意步，`SG(x) = x`;
   >
   > （3）可选步数为一系列不连续的数，用`mex(计算每个节点的值) `

6. 动态规划与博弈论结合【博弈论系列问题的标准常规解法】

   $\color{yellow}动态规划 + 博弈论的核心思想：在二维 dp 的基础上使用元组分别存储两个人的博弈结果。$

    - 例题：你和你的朋友面前有一排石头堆，用一个数组`piles[]`表示，`piles[i] `表示第 `i `堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。设计一个算法，求二者最后的石头数目之差。

      - 首先是对DP数组的定义

        $dp[i][j].first := 对于piles[i...j]这部分石头堆，先手能够获得的最高分数$

        $dp[i][j].second:= 对于piles[i...j]这部分石头堆，后手能够获得的最高分数$

      - 我们想求的问题可以转化为，先手和后手最终分数的差值，也就是$dp[0][n - 1].first - dp[0][n - 1].second$

      - 写状态转移方程比较简单，首先要找到所有状态和每个状态可以做的选择，然后择优。

        一个大致的框架是：

        ```java
        int n == piles.length;
        for 0 <= i < n:
            for j <= i < n:
                for who in {first,second}:
                    dp[i][j][who] = max(left, right); // 择优
        ```

        这道题的难点在于，两人是交替选择的，先手的选择会堆后手有影响，怎样表达呢？

        ```java
        dp[i][j].first = Math.max(piles[i] + dp[i + 1][j].second, piles[j] + dp[i][j - 1].second);
        // 解释：我作为先手，面对piles[i...j]时，有两种选择：
        // 我选左边的：然后面对piles[i + 1...j]
        // 然后此时轮到对方，我是后手
        // 我选右边的：然后面对piles[i...j - 1]
        // 然后此时轮到对方，我是后手
        if (piles[i] + dp[i + 1][j].second > piles[j] + dp[i][j - 1].second ){
            // 代表选择了左边
            dp[i][j].second = dp[i + 1][j].first;
        } else {
            // 先手选择了右边
            dp[i][j].second = dp[i][j - 1].first;
        }
        // 解释：我作为后手，要先等先手选择，有两种情况：
        // 如果先手选择了最左边那堆，给我剩下了piles[i + 1...j]
        // 此时轮到我，我是先手
        // 如果先手选择了最右边那堆，给我剩下了piles[i...j - 1]
        // 此时轮到我，我是先手
        
        ```

        一个很重要的点是，我们要斜着更新数组，这样才能保证是从中心开花向最终答案逐步靠近

        ```java
        public int stoneGame(int[] piles){
            int n = piles.length;
            int[][][] dp = new int [n][n][2]; // 0表示先手，也就是first，1表示后手，也就是second	
            for (int length = 2; l <= n; l++){ // 斜着更新的妙用，从2开始
                for (int i = 0; i <= n - 1; i++){ // 行数
                    int j = l + i - 1; // 行数对应的位置
                    int left = piles[i] + dp[i + 1][j][1];
                    int right = piles[j] + dp[i][j - 1][1];
                    if (left > right){
                        dp[i][j][0] = left;
                        dp[i][j][1] = dp[i + 1][j][0];
                    } else {
                        dp[i][j][0] = right;
                        dp[i][j][1] = dp[i][j - 1][0];
                    }
                }
            }
            return dp[0][n - 1][0] - dp[0][n - 1][1];
        }
        ```

      - 引申：由于动态规划的本质就是记忆化搜索，其实面对一些博弈问题是可以采用记忆化搜索的形式降低思考难度的



---

## 图论

1. 图的基础知识

    - 图的概况：图是一种非常重要的数据结构，用来表示物体与物体之间的关系。图由若干节点及节点之间的边组成。物体对应图中的节点，如果两个物体之间存在某种关系，那么它们在途中应该有一条边相连。

    - 图`G=(V,E)`由顶点`V`和边`E`组成。顶点代表对象，边表示两个对象之间的连接关系。连接两个点`u`和`e`的边用`e=(u,v)`表示。

    - 图的分类：

      图可以分成有向图和无向图，给边规定了方向的图就是有向图，没有规定的话就是无向图。有向图的边用箭头表示。

    - 无向图的术语：

      - 两个顶点之间如果有边连接，那么就视为两个顶点相邻。相邻顶点的序列成为路径。起点和终点重合的路径叫做圈。任意两点之间都有路径连接的图叫做连通图，顶点连接的边数叫做这个顶点的度。

      - 没有圈的连通图叫做树，没有圈的非连通图叫做森林。一棵树的边数恰好是顶点数-1。反之，边数等于顶点数-1的连通图就是一棵树。

      - 如果在树上选择一个顶点叫做根，就可以把根提到最上面，而离根越远的顶点越往下按排其位置。这样的树叫做有根树。

    - 有向图的术语：

      - 没有圈的有向图叫做DAG。
      - 对于每个顶点给一个编号，第$$i$$号叫做$$v_{i}$$，那么存在从顶点$$v_{i}$$到$$v_{j}$$的边时就有$$i<j$$成立，这样的编号方式叫做拓扑序。（如果把图的顶点按照拓扑序排列，那么所有的边都是从左指向右的，因此某些图的问题就可以通过动态规划解决了）

    - 图的表示：图可以使用邻接表或者邻接矩阵表示。

      - 邻接表【有向图】：

      | 顶点 | 相邻顶点列表 |
      | ---- | ------------ |
      | 0    | 1            |
      | 1    | 3            |
      | 2    | 1            |
      | 3    | 0, 2         |
      | 4    | 3            |

      - 邻接矩阵：【无向图】，节点之间相连用`1`记录，否则用`0`记录；`g[i][j] = g[j][i].`

        > $$\begin{array}{c|ccc} & 0 & 1 & 2 & 3\\ \hline 0 & 0 & 1 & 0 & 1 \\ 1 & 1 & 0 & 1 & 0 \\ 2 & 0 & 1 & 0 & 1 \\ 3 & 1 & 0 & 1 & 0  \end{array}$$

      - 邻接矩阵：【有向图】，$$i$$出发指向$$j$$，则`g[i][j] = 1`，有向图不要求`g[i][j] = g[j][i]`

        > $$\begin{array}{c|ccc} & 0 & 1 & 2 & 3\\ \hline 0 & 0 & 1 & 0 & 1 \\ 1 & 0 & 0 & 1 & 0 \\ 2 & 1 & 0 & 0 & 0 \\ 3 & 0 & 0 & 1 & 0  \end{array}$$
    
    - 带权图中，邻接矩阵中的数字代表权重，但是对于权重为0的就不好区分是权重为零还是不相连，因此对于不相连可以采用INF来代替。
    
    - 邻接矩阵非常浪费空间，边很少的稀疏图中非常浪费空间。
    
    - 邻接矩阵还有一个弱点，它不能保存在两个节点之间的多条带权路径，比如A和B之间有一条权重为5的边，也有一条权重为6的边，这种情况就没办法保存了。
    
    - 图的表示要根据具体场景，如果节点数目非常大而且边的数目比较稀少，那么就可以使用邻接表，这样会节省空间。

2. 图的搜索

   图的搜索有两种基本方法，分别是深度优先搜索和广度优先搜索，两种搜索方法有各自的适用场景，要具体分析。

   最简单的记忆方式：最短距离——采用广度优先搜索；符合条件的路径——采用深度优先搜索。

    - 深度优先搜索：沿着途中的边尽可能深入地搜索。

      实现上，我们需要一个先进后出的栈帮助我们实现深度优先搜索；或我们也可以使用循环实现深度优先遍历。

      深度优先搜索主要适用于寻找$\color{yellow}一条路径$，很容易知道从源点到目标节点路上所经历过的内容。

      ```java
      // 图的深度优先搜索示例
      
      ```

    - 广度优先搜索：系统地展开并检查途中的所有节点以找寻结果。

      实现上，我们需要一个先进先出的队列帮助我们实现广度优先搜索。

      广度优先搜索主要适用于寻找$\color{yellow}最短路径$，因为广度优先搜索每一次新遍历的节点到源点的距离都是相同的，所以会保证到达目标节点的时候一定是众多答案中距离最短那一个，从算法上绝对保证了路径的最短。

      ```java
      // 图的广度优先搜索示例
      
      ```

    - 广度优先搜索会把状态逐个加入队列，因此通常需要与状态数成正比的内存空间。反之，深度优先搜索是与最大的递归深度成正比的。一般与状态数相比，递归的深度不会太大，所以可以认为深度优先搜索更加节省内存。

3. 关于图论的代码实现

    - 图在遍历过程中非常需要记录已经遍历过的节点或位置，所以实现的时候通常会创建一个与原图大小相同的`boolean`数组，用`true`表示已经访问过，而`false`用来表示没有访问过。

4. 【图论问题一】图的搜索：二分图判定

    - **二分图**定义：如果能将一个图的节点集合分割成两个独立的子集 `A` 和 `B` ，并使图中的每一条边的两个节点一个来自 `A` 集合，一个来自 `B` 集合，就将这个图称为**二分图**。二分图可以用染色的思路来解决。

    > 问题概述：给定一个图，判断这个图是不是二分图。
    >
    > ```java
    > // LeetCode Q785
    > // graph是无向图的邻接表，注意不是邻接矩阵
    > public boolean isBipartite(int[][] graph) {
    > 
    > }
    > ```
    >
    > 
    >
    > 
    >
    > 

5. 【图论问题二】最短路问题

    | 算法                 | 特点                            | 时间复杂度                                      |
    | -------------------- | ------------------------------- | ----------------------------------------------- |
    | `Dijkstra`算法       | 单源最短路径 + 边的权重都是正数 | 朴素版本$$O(|V|^2)$$、堆优化$$O(|E| * log|V|)$$ |
    | `Bellman Ford`算法   | 单源最短路径 + 权重可以是负数   | $$O(|V| * |E|)$$                                |
    | `SPFA`算法           | `Bellman Ford`算法的优化版本    |                                                 |
    | `Floyd-Warshall`算法 | 多源最短路径 + 权重可以是负数   | $$O(|V| ^ 3)$$                                  |

    - 单源最短路问题`Dijkstra`算法【`LeetCode Q743`】

      - `Dijkstra`算法适用于**<font color='yellow'>最短路问题</font>**中，单源最短路（只有一个起点），并且每条边的<font color='yellow'>权重都是正数</font>的情况
      - 本质上是贪心思想，每次都取距离最小的边开始进行遍历。
      - 问题描述：在一个带权图中，给定一个源点，求各个顶点到这个源点的最短路径。

      - 算法说明：

        - 算法辅助集合

          - `set`集合，用于记录已经计算过的节点
          - `dist[]`数组，用于记录当前的最短距离，如果根据当前的`set`集合不能判断，就初始化为`INF`

          - `path[]`数组，用于记录当前节点到源节点的最短路径的前驱节点

        - 算法流程描述

          - 初始化：将源节点加入`set`集合；`dist[]`的源节点初始化为0，源节点相连的其他节点初始化为源节点到对应节点的权值；`path[]`的初始值都是`-1`

          - 从不在`set`集合中的节点中，选出`dist`值最小的一个<font color='yellow'>（这个地方有一定的优化空间，可以使用堆来实现）</font>，将该节点放入`set`集合中，并对`dist`进行更新，顺便对`path`也进行更新，更新规则：如果`dist[j] + Edge[j][k] < dist[k]`，那么说明经过`j`到达源节点更短，因此更新`dist[k]`和`path[j]`，`dist[k] = dist[j] + Edge[j][k]`，并修改`path[k] = j`，代表从`k`到`j`的最短路径的前驱节点是`j`。
          - 逐渐将所有的节点都加入集合，`dist[]`都更新一遍，`path[]`也都更新一遍。

      - 算法实现

      > ```java
      > public void Dijkstra(int[][] graph, int[][] weight) {
      >     // 用于记录遍历过的节点的集合
      >     Set<Integer> set = new HashSet<>();
      >     // 用于记录最短距离的数组
      >     int[] dist = new int[graph.length];
      >     Arrays.fill(dist, Integer.MAX_VALUE);
      >     // 用于记录前序节点的数组
      >     int[] path = new int[graph.length];
      >     Arrays.fill(path, -1);
      >     // 0,1,2,3,4,5,6
      >     // 假定源节点是 2
      >     set.add(2);
      >     // 源节点到自身的距离必须是0
      >     dist[2] = 0;
      >     for (int node : graph[2]) {
      >         dist[node] = weight[2][node];
      >         path[node] = 2;
      >     }
      >     while (true) {
      >         int newNode = find(dist, set);
      >         if (newNode == -1) {
      >             break;
      >         } else {
      >             set.add(newNode);
      >             for (int node : graph[newNode]) {
      >                 // 如果dist中记录的距离，比现在的方案大，代表现在的方案更好，准备更新
      >                 if (dist[node] > dist[newNode] + weight[newNode][node]) {
      >                     path[node] = newNode;
      >                     dist[node] = dist[newNode] + weight[newNode][node];
      >                 }
      >             }
      >         }
      >     }
      >     // 返回某一个节点到源点的最短距离
      >     // return dist[j]
      >     // 返回某一个节点到源点的具体路径，使用path还原就行了
      >     // List<Integer> route = new ArrayList<>();
      >     // while (path[j] != -1){
      >     //     route.add(path[j]);
      >     //     j = path[j];
      >     // }
      >     // return route;
      > }
      > 
      > // 该方法可以使用堆优化
      > public int find(int[] dist, Set<Integer> set) {
      >     int minValue = Integer.MAX_VALUE;
      >     int minPos = -1;
      >     // 在边数比较小的时候，大部分时间用在了寻找节点上
      >     for (int i = 0; i < dist.length; i++) {
      >         if (set.contains(i)) {
      >             continue;
      >         } else {
      >             if (minValue > dist[i]) {
      >                 minValue = dist[i];
      >                 minPos = i;
      >             }
      >         }
      >     }
      >     return minPos;
      > }
      > ```

    - 单源最短路问题`Bellman Ford`算法【`LeetCode Q787`】

      - `Bellman Ford`算法适用于求解单源、有负权边的最短路问题；而且可以检测负权回路；该算法还可以实现<font color='yellow'>通过`m`次迭代求出从起点到终点不超过`m`条边构成的最短路径</font>

      - 该算法的核心就是松驰，没有贪心策略。我们要明白的是：对于第一次循环$$(i = 0)$$，获得了仅仅迈出一步到源点的最小距离；第二次循环，获得了如果仅仅走两步，能够求得的最小距离...以此类推。 因此，如果在第$$|V|$$次遍历（$$V$$ = 节点数目，`i = V - 1`）时，发现还在更新，就代表获得了走`V`步获得的最小距离，但是我们知道，`V`个点之间最多走`V - 1`步就能全部到达，因此走`V`步还在更新的结果就是存在负环。

      - 问题描述：在一个带负权边的图中，到达某一个源点的最短距离（代价）是多少？

      - 算法说明：

        - 算法辅助集合：

          - `dist[]`数组，用于记录距离
          - `backUp[]`数组，用于对上一次的`dist[]`做备份
          - `path[]`数组，用于记录前驱节点

        - 算法流程描述：

          - 初始化`dist[]`数组，`dist[0] = 0`，其他的节点为`INF`
          - 【初始版本】针对于每个节点进行第一层循环，针对该节点下面的边进行第二层循环，如果发现`dist[from] + weight[from][to] < dist[to] `，那就进行松弛操作，`dist[to] = dist[from] + weight[from][to]`，`path[to] = from`
          - 【判断负环】如果外层循环是从`0`开始的，到达第`V - 1`次循环时还在更新，就说明存在负环。
          - 【提前跳出优化】如果某一次迭代发现没有更新了，就可以结束。
          - 【有限制步数的迭代】由于外层循环的特殊含义，外层循环的次数表示走多少步到达源点的最小距离，因此在某些给定了步数限制的情况下，可以限制外层迭代的次数来求解。

        - 算法注意事项：

          - 串联问题：由于我们只有一个`dist[]`数组，如果在更新的过程中，上一次的更新结果被这一次的覆盖了，而这一次的遍历以新一轮的迭代结果为基准，就会出现问题。

            ```java
            // 1 --(1)-- 2 --(1)-- 3
            // |                   |
            // |--------(3)--------|
            // 如果遍历边的顺序是 1-2 1-3 2-3
            // dist[] = {INF, 0, 1, INF}
            // dist[] = {INF, 0, 1, 3}
            // dist[] = {INF, 0, 1, 2} 相当于走了两步
            // 要用一个备份数组来承接
            ```

      - 算法实现

      > ```java
      > // 初始版本
      > // V : 节点数量
      > // E : 边的数量
      > // edges[E][3] : [[i,j,cost]]
      > // source : 源节点
      > public void BellmanFord(int V, int E, int[][] edges, int source) {
      >     // 距离记录数组
      >     int[] dist = new int[V + 1];
      >     Arrays.fill(dist, Integer.MAX_VALUE);
      >     dist[source] = 0;
      >     // 前驱节点记录数组
      >     int[] path = new int[V + 1];
      >     Arrays.fill(path, -1);
      >     for (int i = 0; i < V; i++) {
      >         // 备份数组
      >         int[] backUp = Arrays.copyOf(dist, dist.length);
      >         for (int j = 0; j < E; j++){
      >             int[] edge = edges[j];
      >             int from = edge[0];
      >             int to = edge[1];
      >             int cost = edge[2];
      >             // 这个地方需要注意，backUp存储的是上一轮的数据，dist存储的是本轮最小的数据
      >             // 如果从上一轮已经确定k步的距离继续走一步，
      >             // 本轮的目的是找走k+1步中cost最小的
      >             // 因此，backUp代表上一步的精准cost + 本轮新迈一步的cost
      >             // 用减法保证不溢出
      >             if (backUp[from] < dist[to] - cost) {
      >                 dist[to] = backUp[from] + cost;
      >                 path[to] = from;
      >             }
      >         }
      >     }
      >     // 如果需要遍历距离：
      >     // dist[]
      >     // 如果需要还原路径
      >     // path[]
      > }
      > ```
      >
      > ```java
      > // 判定是否存在负环
      > public boolean BellmanFordExistCircle(int V, int E, int[][] edges, int source){
      >     // 用于记录距离的数组
      >     int[] dist = new int[V + 1];
      >     Arrays.fill(dist, Integer.MAX_VALUE);
      >     dist[source] = 0;
      >     for (int i = 0; i < V; i++){
      >         boolean update = false;
      >         int[] backUp = Arrays.copyOf(dist, dist.length);
      >         for (int j = 0; j < E; j++){
      >             int[] edge = edges[j];
      >             int from = edge[0];
      >             int to = edge[1];
      >             int cost = edge[2];
      >             if (backUp[from] < dist[to] - cost){
      >                 dist[to] = backUp[from] + cost;
      >                 update = true;
      >             }
      >         }
      >         // 如果第V次遍历还在更新，就代表已经走了V步
      >         // V个节点的最短路径最多走V - 1步，代表出现了重复节点
      >         if (i == V - 1 && update){
      >             // 表示存在负环
      >             return true;
      >         }
      >     }
      >     return false;
      > }
      > ```
      >
      > ```java
      > // 提前跳出优化
      > public void BellmanFordBetter(int V, int E, int[][] edges, int source) {
      >     int[] dist = new int[V + 1];
      >     Arrays.fill(dist, Integer.MAX_VALUE);
      >     dist[source] = 0;
      >     for (int i = 0; i < V; i++) {
      >         boolean update = false;
      >         int[] backUp = Arrays.copyOf(dist, dist.length);
      >         for (int j = 0; j < E; j++) {
      >             int[] edge = edges[j];
      >             int from = edge[0];
      >             int to = edge[1];
      >             int cost = edge[2];
      >             if (backUp[from] < dist[to] - cost) {
      >                 dist[to] = backUp[from] + cost;
      >                 update = true;
      >             }
      >         }
      >         // 如果没有更新，代表已经都最优了，可以结束了
      >         if (!update){
      >             break;
      >         }
      >     }
      >     // 查询距离
      >     // return dist[]
      > }
      > ```
      >
      > ```java
      > // 有限制步数的迭代
      > // 提前跳出优化
      > public void BellmanFordLimit(int V, int E, int[][] edges, int source, int limit) {
      >     int[] dist = new int[V + 1];
      >     Arrays.fill(dist, Integer.MAX_VALUE);
      >     dist[source] = 0;
      >     for (int i = 0; i < limit; i++) {
      >         int[] backUp = Arrays.copyOf(dist, dist.length);
      >         for (int j = 0; j < E; j++) {
      >             int[] edge = edges[j];
      >             int from = edge[0];
      >             int to = edge[1];
      >             int cost = edge[2];
      >             if (backUp[from] < dist[to] - cost) {
      >                 dist[to] = backUp[from] + cost;
      >             }
      >         }
      >     }
      >     // 查询距离
      >     // return dist[]
      > }
      > ```

    - 单源最短路问题`SPFA`算法

      - 该算法是`Bellman-Ford`算法的队列优化版，同样适用于求解单源、有负权边的最短路径问题。
      - 该算法的基本思想，是基于一个观察：只有一个点在上一轮被松弛成功时，这一轮从这个点连出的点才有可能被成功松弛。因为松弛的本质是，当前路径不是最优的，通过引入一个新的节点，能够降低当前的代价，因此就引入这个节点。如果某一个点到源点的距离没有被更新，那么下次与这个点相连的其他点，也一定不会因为这个点的加入，就改变代价消耗；反之，如果这个点的距离被更新了，那么下一次与这个点相连的其他节点才有更新的可能性。
      - 问题描述：求单源最短路
      - 算法说明：
        - 算法辅助集合：
          - `dist[]`，距离数组
          - `Queue<Integer> queue = new LinkedList<>()`，队列，用于存储松弛节点
          - `count[]`，用于存储每个节点入队几次，如果有节点入队超过`V`次，必然存在负环
        - 算法流程描述：
          - 初始化`dist[]`，将源点的距离设置为0，并将源点加入队列
          - 外层循环是队列，每次从队列中取出一个节点，松弛该节点相连的其他节点，如果新节点被松弛了，加入队列。
          - 循环直到队列为空，或者判断出有节点入队超过`V`次（存在负环）
        - 算法注意事项：
          - 为什么考虑队列？因为队列先进先出，可以保证这一轮松弛的点不会在这一轮结束之前取出。
      - 算法实现

      > ```java
      > // edges是用邻接表表示的图
      > // weight[i][j]是i到j的cost
      > public void SPFA(int V, int E, int[][] edges, int[][] weight, int source) {
      >     int[] dist = new int[V + 1];
      >     Arrays.fill(dist, Integer.MAX_VALUE);
      >     dist[source] = 0;
      >     int[] count = new int[V + 1];
      >     Queue<Integer> queue = new LinkedList<>();
      >     queue.add(source);
      >     boolean canNotSolve = false;
      >     while (!queue.isEmpty()) {
      >         Integer node = queue.poll();
      >         count[node]++;
      >         if (count[node] > V){
      >             // 代表存在负环
      >             canNotSolve = true;
      >             break;
      >         }
      >         int[] backUp = Arrays.copyOf(dist, dist.length);
      >         for (int i = 0; i < edges[node].length; i++) {
      >             int from = node;
      >             int to = edges[node][i];
      >             int cost = weight[from][to];
      >             if (backUp[from]< dist[to] - cost) {
      >                 dist[to] = backUp[from] + cost;
      >                 // 将松弛了的点入队
      >                 queue.offer(to);
      >             }
      >         }
      >     }
      >     if (canNotSolve) {
      >         // 存在负环的逻辑
      >     } else {
      >         // dist中查看距离
      >     }
      > }
      > ```

    - 任意两点间最短路算法`Floyd-Warshall`算法`LeetCode Q1334`

      - `Floyd-Warshall`算法适用于计算一个图中所有节点之间的最短距离，图中可以包含负权边。缺点是复杂度太高了，节点稍微多一点就不能支持了。
        - 该算法也叫“插点法”，如果从`a`到`b`的直接路径不是最短的，那么肯定需要经过其他节点，这个时候我们讲这个节点引入，例如`c`节点，引入该节点后计算，`dist[a][b] > dist[a][c] + dist[c][b]`成立么，如果成立就说明经过该节点可以缩短距离，否则不更新。
      - 问题描述：求图中任意两点之间的最短路
      - 算法说明：
        - 算法辅助集合：
          - `dist[i][j]`，一个二维数组，用于记录两点之间的距离
        - 算法流程描述：
          - 初始化，每个节点到自身的距离初始化为0，其他的距离初始化为INF。
          - 最外层迭代，选择要插入的点；内层分别迭代起点和终点。
      - 算法实现

      > ```java
      > // weight中存储了两点之间的直接距离
      > public void FloydWarshall(int V, int E, int[][] weight){
      >     // 初始化
      >     int[][] dist = new int[V + 1][V + 1];
      >     for (int i = 1; i <= V; i++){
      >         for (int j = 1; j <= V; j++){
      >             if (i == j){
      >                 dist[i][j] = 0;
      >             } else {
      >                 dist[i][j] = weight[i][j];
      >             }
      >         }
      >     }
      > 
      >     for (int i = 1; i <= V; i++){
      >         for (int from = 1; from <= V; from++){
      >             for (int to = 1; to <= V; to++){
      >                 if (dist[from][i] < dist[from][to] - dist[i][to]){
      >                     dist[from][to] = dist[from][i] + dist[i][to];
      >                 }
      >             }
      >         }
      >     }
      > }
      > ```
      >
      > ```java
      > // 路径还原版本
      > public void FloydWarshall(int V, int E, int[][] weight) {
      >     // 初始化
      >     int[][] dist = new int[V + 1][V + 1];
      >     // 前驱节点记录数组
      >     int[][] pre = new int[V + 1][V + 1];
      >     for (int i = 1; i <= V; i++) {
      >         for (int j = 1; j <= V; j++) {
      >             if (i == j) {
      >                 dist[i][j] = 0;
      >                 pre[i][j] = 0;
      >             } else {
      >                 dist[i][j] = weight[i][j];
      >                 pre[i][j] = j;
      >             }
      >         }
      >     }
      > 
      >     for (int i = 1; i <= V; i++) {
      >         for (int from = 1; from <= V; from++) {
      >             for (int to = 1; to <= V; to++) {
      >                 if (dist[from][i] < dist[from][to] - dist[i][to]) {
      >                     dist[from][to] = dist[from][i] + dist[i][to];
      >                     // from -- i -- to
      >                     // 记录 from -- i
      >                     // 意味着从from到to，先去找从from到i
      >                     pre[from][to] = pre[from][i];
      >                 }
      >             }
      >         }
      >     }
      >     // 路径还原
      >     // pre[from][to] --> pre[from][ pre[from][to] ]
      >     // int log = pre[src][dis];
      >     // while (log != j) {
      >     //     List<Integer> path = new ArrayList<>();
      >     //     path.add(log);
      >     //     log = pre[src][log];
      >     // }
      > }
      > ```

    - 路径还原

      使用`path[]`数组记录前驱节点，不断迭代还原就可以了。

6. 【图论问题三】最小生成树（`Minimum Spanning Tree`，简称`MST`）

    - 最小生成树的`Prim`算法

      - 问题描述

        给定一个连通的无向图，最小生成树是指包含图中所有顶点的一棵树，且该树的所有边的权重之和最小。

        > 三大要素：
        >
        > 连通性、无环、权重之和最小

      - 算法说明

        - 算法辅助集合：

          - `dist[]`数组，用于记录集合到节点的最短距离
          - `Set<Integer> visited`，用于记录访问过的所有节点

        - 算法流程描述：

          - 初始化`dist`数组为`INF`，表示所有的节点到集合的距离为无穷大
          - 选择一个起始节点作为最小生成树的起点（任意选择），更改`dist[start] = 0`
          - 将该起始节点加入最小生成树集合，并将其标记为已访问
          - 在所有与最小生成树已经访问过的节点集合相邻的边中，在所有没有访问过的节点中，选择权重最小的边
          - 将该边和节点加入最小生成树集合，并将该节点标记为已访问
          - 更新`dist[v] = Math.min(dist[v], g[u][v])`
          - 重复上述步骤，直到最小生成树集合包含了图中的所有节点

          - 【朴素版】找最小边的过程需要遍历
          - 【堆优化版】找最小边的过程使用堆进行优化
          - 【带路径输出版】：

        - 算法注意事项

          - 无向图中，边的权重需要赋值两次，包括从`a->b`和`b->a`的。

      - 算法实现

      ```java
      // 朴素版
      public int prim(int[][] weights, int N) {
          int distSum = 0;
          int[] dist = new int[N];
          boolean[] visited = new boolean[N];
          dist[0] = 0;
          for (int i = 0; i < N; i++) {
              // 寻找下一个距离最近的点，线性时间复杂度，可以用堆优化
              int flag = -1;
              int distFlag = Integer.MAX_VALUE;
              for (int j = 0; j < N; j++) {
                  if (!visited[j] && distFlag > dist[j]) {
                      flag = j;
                      distFlag = dist[j];
                  }
              }
              // 代表第 i 次添加节点失败，图构不成最小生成树
              if (flag == -1) {
                  return Integer.MAX_VALUE;
              }
              // 确定访问这个节点
              distSum += dist[flag];
              visited[flag] = true;
              for (int j = 0; j < N; j++) {
                  // 如果这个节点可达，就更新距离
                  if (weights[flag][j] != Integer.MAX_VALUE) {
                      dist[j] = Math.min(dist[j], weights[flag][j]);
                  }
              }
          }
          return distSum;
      }
      ```

      ```java
      // 堆优化版
      public int prim(int[][] weights, int N) {
          int distSum = 0;
          int[] dist = new int[weights.length];
          Arrays.fill(dist, Integer.MAX_VALUE);
          Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[1]));
          queue.offer(new int[]{0, 0});
          boolean[] visited = new boolean[N];
          while (!queue.isEmpty()) {
              // 取一个最小距离的节点
              int[] poll = queue.poll();
              // 已经访问了，pass
              if (visited[poll[0]]) {
                  continue;
              } else {
                  // 没有访问过的话，访问
                  visited[poll[0]] = true;
                  distSum += poll[1];
                  // 访问后把对应的边加入集合
                  for (int i = 0; i < weights.length; i++) {
                      if (weights[poll[0]][1] != Integer.MAX_VALUE && dist[poll[0]] > poll[1]) {
                          dist[poll[0]] = poll[1];
                          queue.offer(new int[]{i, poll[1]});
                      }
                  }
              }
          }
          return distSum;
      }
      ```

      ```java
      // 没有经过测试
      // 带路径输出版
      // 路径输出版
      public int prim(int[][] weights, int N) {
          int distSum = 0;
          int[] dist = new int[weights.length];
          List<int[]> edges = new ArrayList<>();
          // 用于记录dist中最小的距离前序节点是谁
          int[] path = new int[weights.length];
          Arrays.fill(dist, Integer.MAX_VALUE);
          Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[1]));
          queue.offer(new int[]{0, 0});
          boolean[] visited = new boolean[N];
          while (!queue.isEmpty()) {
              // 取一个最小距离的节点
              int[] poll = queue.poll();
              // 将节点对应的路径取出来
              edges.add(new int[]{poll[0], path[poll[0]]});
              // 已经访问了，pass
              if (visited[poll[0]]) {
                  continue;
              } else {
                  // 没有访问过的话，访问
                  visited[poll[0]] = true;
                  distSum += poll[1];
                  // 访问后把对应的边加入集合
                  for (int i = 0; i < weights.length; i++) {
                      if (weights[poll[0]][1] != Integer.MAX_VALUE && dist[poll[0]] > poll[1]) {
                          // from = poll[0]
                          // to = i 
                          // weight = poll[1]
                          path[poll[0]] = i;
                          dist[poll[0]] = poll[1];
                          queue.offer(new int[]{i, poll[1]});
                      }
                  }
              }
          }
          // return edges;
          return distSum;
      }
      ```

    - 最小生成树的`Kruskal`算法

      ```java
      
      ```

7. 【图论问题四】拓扑排序——拓扑排序可以：对无环图进行排序或者对有向图判环。

8. 【图论问题五】欧拉回路——

9. 图的特殊表示形式——链式前向星

    > 图的存储一般有两种，邻接矩阵和邻接表。邻接表中有一种存储图的数据结构叫做链式前向星。如果图的边很少，开二维数组非常浪费；如果图的点很多，二维数组又会在初始化时即爆炸。于是便引入了链式前向星。
    >

    - 链式前向星的特点
      - 和邻接表一样，因为链式前向星采用头插法进行链接，所以边的顺序不同，创建的链式前向星也不同
      - 对于无向图，一条边当两条边处理就行
      - 链式前向星具有边集数组和邻接表的功能，是一种静态链表，不需要频繁创建节点，应用起来十分灵活

    - 思想：引入两个数组

      - `head[]`数组，初始化为`-1`，代表某一个节点

      - `edge[]`数组，存储`head[]`的临接点，`edge[0]`代表当前`head`的指向边，`edge[1]`代表权重，`edge[2]`存着下一个与本`head`相连的`edge[]`的下标

      - 两个数组的关系，类似于HashMap的拉链法

        ```java
        //     图 结构
        // head 1
        // 1 --> 4 weight = 2
        // 1 --> 2 weight = 6
        
        // head 2
        
        // head 3
        // 3 --> 1 weight = 5
        // 3 --> 4 weight = 8
        
        // head 4
        // 4 --> 2 weight = 3
        ```

        ```java
        //                      链式前向星 结构 
        //   head                     edge
        // head[1] 1   --> edge[1] {4, 2, 0} --> edge[0] {2, 6, -1}
        // head[2] -1  
        // head[3] 1   --> edge[3] {4, 8, 2} --> edge[2] {1, 5, -1}
        // head[4] 4   --> edge[4] {2, 3, -1}
        ```

    - 代码实现

      - 构建

        ```java
        class Edge {
            // 与当前head相连的节点，这个边的出度
            int to;
            // 这个边的权重
            int weight;
            // 下一个节点在edge数组中的位置
            int next;
        }
        
        class Solve {
            int[] head;
            Edge[] edges;
            int edgeCount; // 用于记录新的节点往edge的哪个位置存储
            // 初始化 
            public void init() {
                // V节点数量 E边数量
                head = new int[V + 1];
                edges = new Edge[E + 1];
                Arrays.fill(head, -1);
                edgeCount = 0;
            }
            // 添加边
            public void add(int from, int to, int weight) {
                Edge edge = new Edge();
                edge.to = to;
                edge.weight = weight;
                edge.next = head[from];
                edges[edgeCount] = edge;
                head[from] = edgeCount++;
            }
            // 使用图
            public void print(int[] head, Edge[] edges) {
                for (int i = 0; i < head.length; i++) {
                    System.out.println("当前节点是：" + i);
                    int cur = i;
                    while (cur != -1 && cur < edges.length && edges[cur] != null) {
                        Edge edge = edges[cur];
                        // int from = i;
                        // int to = edge.to;
                        // int weight = edge.weight;
                        System.out.println("与当前节点相连的节点是：" + edge.to + "，这个边的权重是：" + edge.weight);
                        cur = edge.next;
                    }
                }
            }
        }
        
        // @Test方法
        public static void main(String[] args) {
            Solve solve = new Solve();
            solve.init();
            solve.add(0, 1, 2);
            solve.add(1, 2, 3);
            solve.print(solve.head, solve.edges);
        }
        ```

        

---

