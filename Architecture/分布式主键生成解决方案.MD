# 分布式主键生成解决方案

## 一、技术层面
### （一）数据库层面
1. 单库+单表 场景
   1. 单库单表场景下，最简单的就是数据库的自增机制
   2. 自增机制的缺点就是与表的字段强相关，也就是说一个库的一个表，具有一个自增的主键
2. 单库+多表 场景
   1. 单库多表场景下，可以考虑采用`sequence`机制
   2. `sequence`机制介绍
      1. `sequence`是一个独立的数据库对象，它用于生成全局唯一的数字序列，可被多表、多列共享
      2. 与自增的机制完全不同，它可以保证整个数据库中所有记录的唯一性
      3. `sequence`机制的使用上，包含下列几个参数：起始值、步长、最大值、最小值、是否循环、是否包含缓存
         1. 是否循环：到达最大值或者最小值之后是否允许重新循环
         2. 是否包含缓存：缓存中预存了一些生成好的主键id，一般是20个，如果这些没有用完就关闭数据库，没有使用的就丢失了，所以使用缓存的时候不能保证序列是强连续的
      4. `sequence`机制原理
         1. 【缓存】`sequence`配置缓存：每次会在内存中预先分配20个id，用完再分配
            1. Oracle、MySQL：使用`cache`后没用完数据库崩溃，序列值会跳跃
            2. PostgreSQL：WAL机制（预写机制），崩溃后可以恢复保证连续性
         2. 【预分配】缓存中每次预先分配一些待使用的id
         3. 【独立维护】`sequence`在内存级别维护一个值，而不是将每次要生成的id直接写入表中
         4. 【原子性】通过锁机制，多线程下也保持正确
   3. `sequence`机制保证了同一个数据库下多个表之间（比如修改单据id + 取消单据id + 咨询单据id）之间的id唯一性
   4. 缺点： 
      - 高并发场景下，`sequence`机制无法保证高并发
      - 安全性堪忧，爬虫从`id`开始递增爬就可以了
3. 多库 场景
   1. 必须依赖下面的中间件或者算法层面来保证唯一性了

### （二）中间件层面
1. 使用Redis的原子操作来实现
2. Redis天然具有快、自增的功能

### （三）算法层面
1. 雪花算法
   1. 基本内容：雪花算法由Twitter开源，其核心思想是通过一定的位运算，将时间戳、机器ID和序列号组合成一个64位的长整型ID。具体结构如下：
      1. 时间戳（41位）：记录当前时间与特定起始时间的差值，单位通常为毫秒。 
      2. 机器ID（10位）：支持部署最多1024个节点（包括机器和数据中心）。 
      3. 序列号（12位）：支持同一毫秒内生成最多4096个ID。
      ```bash
      | 1 位符号位 | 41 位时间戳 | 10 位机器ID | 12 位序列号 |
      ```
   2. 最大支持并发量
      1. 标准雪花算法的理论上限是4096qps/ms，或者是400w/s
      2. 若当前时间戳的序列空间已耗尽，会自旋等待下一个时间戳。
   3. 时钟回拨问题（雪花算法高度依赖时间，如果时间因为某些情况出现了异常，会导致出现id重复，也就是时钟回拨问题）
      1. 解决方案1：记录上一次生成ID的时间戳，如果对比两次后发现倒退，则拒绝生成或者等待时间追上
         1. 美团leaf架构：如果回拨的时间较短，等待时间追上后，再进行生成
         2. 百度UID生成：回拨后直接抛出异常
         3. 携程IDGen生成：记录上一次使用的时间戳，若发现当前时间戳小于上次时间戳，则基于上次时间戳生成ID，序列号用尽后再拒绝请求
      2. 解决方案2：Butterfly架构，使用逻辑时钟
         1. 逻辑时钟：进程启动时间作为当前的逻辑起始时间，不再依赖真实的时间而是基于逻辑时间自增
         2. 序列号与时间戳联合自增：当序列号用满之后，逻辑时间戳+1，序列号归零
         3. 预生成id应对突发流量
2. UUID通用唯一识别码（Universally Unique Identifier），利用当前日期和时间、时钟序列、以太网MAC地址等信息组合形成编号，形如“550e8400-e29b-41d4-a716-446655440000”，能够保证在同一时空的所有机器中唯一。UUID是一种构建标准，微软的GUID是其最广泛的一种应用
   1. 优点：1）客户端本地生成，效率高；2）不存在扩展性问题。
   2. 缺点：1）存储开销大，每个ID至少需要16字节空间；2）字符型ID，查询效率低；3）乱序，无法满足趋势递增。
   3. UUID简介
      1. UUID是一个128位长的标识符，16字节，可以转换为32个16进制字符的组合`4a4c96b0-90cd-43f0-83d7-7b438955ca89`
         ```txt
         字节表示--纯2进制表示
         | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 |
         | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 |
         | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 |
         | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 | 0 1 0 1 0 1 0 1 |
         字节表示
         | 0xAB | 0xAB | 0xAB | 0xAB | 
         | 0xAB | 0xAB | 0xAB | 0xAB | 
         | 0xAB | 0xAB | 0xAB | 0xAB | 
         | 0xAB | 0xAB | 0xAB | 0xAB | 
         16进制字符表示--纯二进制表示
         | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 |
         | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 |
         | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 |
         | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 | 0 1 0 1 |
         16进制字符表示
         | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |
         | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |
         | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |
         | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |
         ```
      2. UUID结构

      |            字段             |   数据类型   | 字节位置  |         备注          |
      |:-------------------------:|:--------:|:-----:|:-------------------:|
      |         time_low          | 无符号32位整数 |  0-3  |       时间戳的低位        | 
      |         time_mid          | 无符号36位整数 |  4-5  |       时间戳的中位        | 
      |    time_hi_and_version    | 无符号16位整数 |  6-7  | 时间戳的高位与版本号，前四位代表版本号 | 
      | clock_seq_hi_and_reserved | 无符号8位整数  |   8   |     时钟序列高位与保留位      | 
      |       clock_seq_low       | 无符号8位整数  |   9   |        时钟的低位        | 
      |           node            | 无符号48位整数 | 10-15 |     空间上唯一的节点标识符     | 

      ```txt
         // 代表十位数字
         0                   1                   2                   3
         // 代表个位数字
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                          time_low                             |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |       time_mid                |         time_hi_and_version   |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                         node (2-5)                            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      ```
         - `xxxxxxxx-xxxx-Vxxx-Yxxx-xxxxxxxxxxxx`中的V只能是1、2、3、4、5，代表的是生成该UUID的版本，V对应的是4个二进制code
      
            | msb0 | msb1 | msb2 | msb3 | version |
            |:----:|:----:|:----:|:----:|:-------:|
            |  0   |  0   |  0   |  1   |    1    |
            |  0   |  0   |  1   |  0   |    2    |
            |  0   |  0   |  1   |  1   |    3    |
            |  0   |  1   |  0   |  0   |    4    |
            |  0   |  1   |  0   |  1   |    5    |
         - 时间戳、时钟、节点标识符
           - 时间戳
             - 版本1和版本2是基于UTC时间，计算当前时间到1582年10月15日0点0分0秒的100纳秒间隔次数
             - 版本3和版本5是基于“名称空间”填充时间戳的部分，比如域名系统或者URL等唯一性标识符，因此保证了在其命名空间内的唯一性
             - 版本4，时间戳是一个随机或者伪随机的60位值，大部分二进制的值是完全随机的，跟时间没有任何关系
           - 时钟：用于避免因系统时间被回溯或者节点ID发生变化时可能出现的重复标识符（时钟回拨问题）
             - 版本1和版本2：若已知先前时钟序列的值，可以直接递增（可以理解为每次生成，在内存中记录当前的值，后面用的时候直接递增）；否则应将其设置为一个随机或高质量的伪随机值。
             - 版本3和版本5：从命名空间中提取的值
             - 版本4：随机或者伪随机
           - 节点标识符
             - 版本1：基于网络适配器的MAC地址或者在没有硬件MAC地址可用时由系统自动生成一个伪随机数
             - 版本2：指向组织结构或其他逻辑意义上的空间划分
             - 版本3和版本5：从一个名称构造而来，也是基于命名空间
             - 版本4：节点字段是一个随机或伪随机生成的值
         - 总结
           - 版本1和版本2，分别使用了系统时钟和时钟序列填充数字（有重复概率，很低）
           - 版本3和版本5，基于命名空间填充了数字（有重复概率，很低）
           - 版本4，基于随机数填充（有重复概率，很低）
   4. UUID是怎样保证唯一性的？
      这要分不同的版本来说明；但是核心思想上，从时间、唯一标识符、随机性上有诸多考量，如果一定较真儿，UUID不能完全保证随机性；现实生活中，只是因为数量太大了，忽略不计其随机的可能性
   5. 以版本4为例，UUID重复需要生成多少次？$$P(n) = 1 - \exp\left(-\frac{n(n-1)}{2 \times 2^{122}}\right)$$
      ```txt
       UUID版本4一共128个信息位，每位是二进制，版本4其中6位是固定的，共122位可用
       如果每秒生成10^9个UUID，需要3.8亿年才能达到生成2^61个UUID，此时的重复概率是39.3%
      ```
3. md5算法

## 二、业务层面组合生成主键
1. 方案描述：例如用户ID + 商品ID，来实现主键
2. 优点：直观，看见id就能联系到业务逻辑
3. 缺点：扩展性比较差



参考文档
1. https://cloud.tencent.com/developer/article/2457482
2. SEATA：https://seata.apache.org/zh-cn/blog/seata-analysis-UUID-generator/
3. https://blog.csdn.net/qq_37679639/article/details/146876485
4. UUID官方文档（或参考doc文件夹）：https://www.rfc-editor.org/rfc/rfc4122#section-4.1.2 
5. UUID说明：https://blog.csdn.net/u012397879/article/details/136999310
