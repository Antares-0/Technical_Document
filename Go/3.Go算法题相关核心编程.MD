# Go算法题相关核心编程

## 一、go的数据类型
1. 核心概念区分：从原子--化合物的角度理解「基本数据类型与派生数据类型」，区别在于数据的“纯净程度”
   - 基本数据类型（是值类型的子集）
     - 数值类型（int家族）
     - 字符类型（byte）：保存单个字母字符
     - 符文类型（rune）：保存字符
     - 布尔类型（bool）
     - 字符串类型（string）：特殊的基本类型，虽然是值类型但是有引用的语义
     - 复数类型（complex）
   - 派生数据类型
     - 指针（pointer）
     - 数组（array）
     - 结构体（struct）：是值类型
     - 管道（channel）
     - 切片（slice）
     - 函数（func）
     - 接口（interface）
     - 映射表（map）
2. 核心概念区分：从内存初始化角度理解「值类型与引用类型」，区别在于数据的内存分配
   - 值类型：直接存储数据本身，内存通常分配在栈，修改副本不会影响原始数据；当使用等号进行赋值时，实际上是进行了深拷贝
     - 整数（int）
     - 浮点数（float）
     - 布尔值（bool）
     - 字符串（string）
     - 数组（array）
     - 结构体（struct）
   - 引用类型：存储指向数据的指针或者地址，通常在堆上分配；引用类型仅仅声明是不能使用的，还需要进行初始化；因此仅仅使用new创建下列对象，是不足够的
     - 切片（slice）
     - 映射（map）
     - 通道（chan）
     - 指针（pointer）
     - 函数（func）
3. 核心特点
   - 值类型的核心特点
     - 赋值是深拷贝
     - 声明后就可以使用，内存结构是确定的，占用空间的大小是确定的
   - 基本数据类型的核心特点：最简单易懂的类型
4. 启发
   - 如果方法外面只访问一个结构体对象，是可以直接传这个值的
     - 因为go是值拷贝，而结构体是值类型，因此对值类型进行值传递是没有问题的，访问不会出错
     - 但是如果访问结构体对象并要求修改，那就不合适了
     ```go
     type Student struct {
         name string
         age  int
     }

     func main() {
         student := Student{
             name: "aaa",
             age:  20,
         }
         fmt.Printf("student address:%p\n", &student)
         fmt.Printf("student inner:%v\n", student)
         // 对值类型进行值传递
         // 下面的函数可以正常访问
         getName(student)
     }
     
     func getName(student Student) string {
        fmt.Printf("student address:%p\n", &student)
        fmt.Printf("student inner:%v\n", student)
     	return student.name
     }
     ```
   - 

## 二、基本数据类型
1. go的数字类型太多了，与Java完全不同，go设计这么多数据类型的初衷是实现最高效的空间利用，尽可能少地使用空间
2. 基本数据类型分类
   - 整数：
     - 无符号整数：
       - uint8(0, 255) 
       - uint16(0, 65535) 
       - uint32(0, 4294967295) 
       - uint64(0, 18446744073709551615) 
       - uint(取决于操作系统位数)
     - 有符号整数：
       - int8(-128, 127) 
       - int16(-32768, 32767) 
       - int32(-2147483648, 2147483647) 
       - int64(-9223372036854775808, 9223372036854775807) 
       - int(取决于操作系统位数)，<font color='yellow'>默认声明类型</font>
     - 特殊整数类型：uintptr(), 无符号整数类型，用于存储指针地址，其大小足以容纳所在平台的指针值(uint类型)
   - 浮点数：
     - 单精度浮点数：float32
     - 双精度浮点数：float64，<font color='yellow'>默认声明类型</font>
   - 复数：在浮点数或者十进制整数后添加`i`，会自动变成复数
     - 低精度复数complex64：(float32, float32)
     - 高精度复数complex128：(float64, float64)
   - 布尔值：bool
   - 字符串：string
   - Unicode（符文类型）：rune，实际上是int32的别名，不如utf8格式编码对空间的利用高效
   - byte（字符类型）：byte，实际上是uint8的别名，类似java的char类型。
3. 浮点数
   - 精度丢失：如果想使用高精度的浮点数，建议优先使用float64
     ```go
     func main() {
         var num1 float32 = -123.0000901
         var num2 float64 = -123.0000901
         fmt.Printf("%f\n", num1)
         fmt.Printf("%f\n", num2)
     }
     // 精度丢失
     // -123.000092
     // -123.000090
     ```
4. 字符类型和符文类型（byte & rune）
   - 这两种类型本质上都是数值，是数值的别名实现
   - 直接输出这两类变量得到的就是对应的数值类型，想要获取原始的符文类型，要使用`fmt.Printf("c1=%c", c1)`等获取
   - byte和rune类型是可以直接比较大小和计算加减乘除的
   - 也可以换一种命名方式，直接使用uint8和int32来表示符文类型
5. 字符串
   - 字符串的定义方式：
     - 双引号定义的字符串
       ```go
       str := "hello，世界"
       // 双引号中的字符串会被转义
       ```
     - 反引号定义的字符串（字符串字面量）
       ```go
       str := `go is a tool.
       java is a tool. /n
       `
       // 打印效果不会被转义，所见即所得
       ```
   - len函数与编码格式
     - 获取一个utf8编码的字符串长度，是按照字节计算的
       ```go
       str := "hello, 世界"
       fmt.Println(len(str)) // 13
       fmt.Println(utf8.RuneCountInString(str)) // 9
       ```
     - go的range函数隐式支持了按照utf8遍历的规则
       ```go
       str := "hello, 世界"
	   for i, s := range str {
		   fmt.Printf("%d\t%q\t%d", i, s, i)
		   // 0	'h'	104
		   // 1	'e'	101
		   // 2	'l'	108
		   // 3	'l'	108
		   // 4	'o'	111
		   // 5	','	44
		   // 6	' '	32
		   // 7	'世'	19990
		   // 10	'界'	30028
	   }
       ```
   - 字符串的多行拼接，`+`必须在上一行，原理是go在每一行末尾会加上分号，如果是加号结尾就不加分号了
     ```go
     // 正确
     str := "hello" + 
     "world"
     // 错误
     str := "hello"
     + "world"
     ```
6. 指针与标识符
   - 指针是什么：指针是“存储内存地址的变量”，是一个专门用来存储内存地址的变量
   - 标识符是什么：标识符本质上是一个“符号标签”，它不直接存储数据或代码，而是关联到具体的程序实体，用于标识一段内存空间
   - 指针本质上也是一种变量，但是它是用来记录地址的；标识符不是变量，它只是一个映射关系
   <font color='yellow'>var p *int = &i，p是标识符，不是指针</font>
   ```go
   var i = 10
   // i 是 标识符，用来标识 i 是 10，i仅仅在编译期间存在于符号表中
   // i 本身不参与真实运算，参与真实运算的是 10 本身
   var p *int = &i
   // p 是 标识符，&i是指针
   // &i的含义是指将10的内存地址取出来，将这个地址变量用p来标识，所以p是标识符，p不是指针
   ```
   - 指针的大小：由“内存地址位数”决定
   - 指针的类型：因为指针统一都是一个格式，按照64位内存地址来的，解析引用的时候需要确定数据的结束范围，int指针只会操作4字节大小的内存，char指针仅仅操作一个字节的
7. go语言字符串长度统计与Java显著不同，但是好在range函数是隐式支持的
   ```go
   s := "hello, 世界"
   fmt.Println(len(s)) // 13
   fmt.Println(utf8.RuneCountInString(s)) // 9
   // go统一使用utf8编码
   
   // range函数支持utf8解码
   n := 0
   for _, _ = range s {
      n++
   }
   fmt.Println(n) // 9
   ```

## 三、字符串处理相关库
1. 其他类型转字符串（fmt.Sprintf & strconv），不能直接使用`string(int)`
   ```go
   // Sprintf
   var mychar byte = 78
   str := fmt.Sprintf("%c", mychar)
   // int 类型
   num := 19
   str := strconv.Itoa(num)
   // int64等
   num64 := int64(num)
   str64 := strconv.FormatInt(num64, 10)
   // int8等，需要变成int64或者uint64，然后使用函数打印
   num8 := int8(8)
   str8 := strconv.FormatInt(int64(num8), 10)
   // float
   floatNum := 123.455
   strFloat := strconv.FormatFloat(floatNum, 'f', 10, 64)
   ```
   - Sprintf的占位符说明

   | 占位符     | 说明                 | 示例                                                | 输出             |
   |---------|--------------------|---------------------------------------------------|----------------|
   | `%v`    | 按默认格式打印值           | `fmt.Printf("%v", 123)`                           | `123`          |
   | `%+v`   | 打印结构体时包含字段名        | `fmt.Printf("%+v", struct{Name string}{"Alice"})` | `{Name:Alice}` |
   | `%#v`   | 打印值的 Go 语法表示       | `fmt.Printf("%#v", []int{1,2})`                   | `[]int{1, 2}`  |
   | `%T`    | 打印值的类型             | `fmt.Printf("%T", 3.14)`                          | `float64`      |
   | `%%`    | 打印百分号              | `fmt.Printf("50%%")`                              | `50%`          |
   | `%t`    | 打印布尔值              | `fmt.Printf("%t", true)`                          | `true`         |
   | `%b`    | 二进制表示整数            | `fmt.Printf("%b", 10)`                            | `1010`         |
   | `%c`    | 打印 Unicode 码对应的字符  | `fmt.Printf("%c", 65)`                            | `A`            |
   | `%d`    | 十进制整数              | `fmt.Printf("%d", 0x10)`                          | `16`           |
   | `%o`    | 八进制整数              | `fmt.Printf("%o", 10)`                            | `12`           |
   | `%x`    | 十六进制（小写）           | `fmt.Printf("%x", 255)`                           | `ff`           |
   | `%X`    | 十六进制（大写）           | `fmt.Printf("%X", 255)`                           | `FF`           |
   | `%U`    | Unicode 格式（U+1234） | `fmt.Printf("%U", 65)`                            | `U+0041`       |
   | `%f`    | 浮点数（默认 6 位小数）      | `fmt.Printf("%f", 3.14)`                          | `3.140000`     |
   | `%e`    | 科学计数法（小写 e）        | `fmt.Printf("%e", 1000)`                          | `1.000000e+03` |
   | `%E`    | 科学计数法（大写 E）        | `fmt.Printf("%E", 1000)`                          | `1.000000E+03` |
   | `%g`    | 自动选择 %f 或 %e       | `fmt.Printf("%g", 1000.0)`                        | `1000`         |
   | `%G`    | 自动选择 %f 或 %E       | `fmt.Printf("%G", 1000.0)`                        | `1000`         |
   | `%s`    | 字符串                | `fmt.Printf("%s", "hello")`                       | `hello`        |
   | `%q`    | 带双引号的字符串           | `fmt.Printf("%q", "hello")`                       | `"hello"`      |
   | `%p`    | 指针地址（十六进制）         | `fmt.Printf("%p", &x)`                            | `0x1040a124`   |
   | `%n`    | 将已写的字节数存入变量        | `var n int; fmt.Fprintf(&buf, "%n", &n)`          | -              |
   - strconv的函数【int8等，需要变成int64或者uint64，然后使用函数打印】
     - strconv.FormatBool(b bool) --> string
     - strconv.FormatInt(i int64, base int) --> string
     - strconv.FormatUint(i uint64, base int) --> string
     - strconv.FormatFloat(f float64, fmt byte, prec, bitSize int) --> string
     - strconv.Itoa(i int) --> string
        ```txt
        1. f：要转换的浮点数（float64 类型）
        2. fmt：格式化方式（单字节字符），可选值：
           'b'：二进制表示
           'e'：科学计数法（如 1.234e+5）
           'E'：科学计数法（如 1.234E+5）
           'f'：普通小数形式（如 123.456）
           'g'：自动选择 e 或 f 中更简洁的形式
           'G'：自动选择 E 或 f 中更简洁的形式
        3. prec：精度控制
           对于 'e', 'E', 'f'：表示小数点后的位数
           对于 'g', 'G'：表示有效数字的最大数量
           对于 'b'：该参数无效
        4. bitSize：指定浮点数的来源类型（32 表示 float32，64 表示 float64）
        ```
2. 字符串转其他类型
   - strconv.ParseBool(str string) --> bool
   - strconv.ParseInt(str string, base int, bitSize int) --> int(?)
     ```go
     // base：表示进制（2-36） ，bitsize表示结果类型（8、16、32、64）
     str := "788"
     num64, _ := strconv.ParseInt(str, 10, 64)
     num32, _ := strconv.ParseInt(str, 10, 32)
     ```
   - strconv.ParseUint(str string, base int, bitSize int) --> uint(?)
   - strconv.ParseFloat(s string, bitSize int) --> float(?)
3. 字符串遍历，按照符文类型处理，先用`[]rune(str)`处理一下
4. 字符串转byte数组，`var bytes := []byte(str)`
5. strings包，字符串处理（子串、替换、拆分、转换、去掉空格、前缀后缀）
   - 查找字符串中是否存在固定的子串：`strings.Contains(str, subStr)`，存在返回true
   - 返回一个字符串中存在多少个子串：`strings.Count(str, subStr)`
   - 不区分大小写的字符串比较：`strings.EqualFold("abc", "ABC")`，忽略大小写相等就是true 
   - 查找字符串中第一次出现子串的下标：`strings.Index("aaaa", "a")`，不存在返回-1
   - 查找字符串中最后一次出现子串的下标：`strings.LastIndex("golanggo", "go")`
   - 替换字符串中符合条件的子串变成另一个子串，重复n次（n为-1全部替换）：`string.Replace("gogogo", "golang", 2)`
   - 按照某个指定的字符拆分：`strings.Split("hello,1,2,2", ",")`
   - 大小写转换：`strings.ToLower(str)`和`strings.ToUpper(str)`
   - 去掉左右的空格：`strings.TrimSpace(str)`
   - 去掉左右指定的字符：`strings.Trim(str, trimStr)`
     - 需要注意，是将trimStr中全部的字符，只要出现在开头和结尾，都会被去掉，而不是按照trimStr的顺序
     ```go
     func main() {
         trim := strings.Trim("abc[inner]bbfbcba", "abc")
         fmt.Println(trim) //  [inner]bbf 
         trim1 := strings.Trim("abc[inner]bbbcba", "abc")
         fmt.Println(trim1) //  [inner] 注意bbb都被去掉了
     }
     ```
   - 去掉左边或者右边的指定字符：`strings.TrimLeft(str, trimStr)`和`strings.TrimRight(str, trimStr)`
   - 前缀与后缀：`strings.HasPrefix("http://122.2.2.2", "http")`和`strings.HasSuffix("http://122.2.2.2", "jpg")`，返回布尔值
6. 

## 四、标准库（除字符串处理）
1. math包
   - math.MaxInt64、math.MaxUint64、math.MaxFloat64等，表示该数据类型支持的最大值
   - rand.Intn(100)，随机生成[0,100)区间内的数字
2. fmt包：格式化输出
    - 获取键盘输入：
      - `fmt.Scanln()`：获取一行，推荐
        ```go
        var name string
        fmt.Scanln(&name)
        fmt.Printf("name is %v", name)
        ```
      - `fmt.Scanf()`：按照格式规范化获取
        ```go
        var name string
        fmt.Scanf("%s", &name)
        fmt.Printf("name is %v", name)
        ```
    - 输出到控制台
      - `fmt.Print()`
      - `fmt.Printf()`
      - `fmt.Println()`
3. time包：休眠、年月日、格式化输出
   - 获取当前时间`now := time.Now()`
   - 获取年月日`now.Year()``int(now.Month())``now.Day()``now.Hour()``now.Minute()``now.Second()`，注意月会输出英文格式，可以直接转成int
   - 格式化日期：`now.Format("2006/01/02 15:04:05")``now.Format("15:04:05")`，实际上可以理解为`1月2日3点4分5秒2006年`是一种类似索引的格式化标识
   - 常量`time.Millisecond``time.MicroSecond``time.Second`
   - 休眠`time.Sleep(100 * time.Millisecond)`
   - 获取时间戳`now.Unix()`获取微秒，`now.UnixNano`获取纳秒

## 五、集合
1. 数组：数组是具有固定长度，拥有多个相同数据类型元素的序列
   - 数组的长度必须是常量表达式，数组的长度在创建的时候就必须确定
   - 创建数组的写法
   ```go
   // 普通数组声明
   var a [3]int
   // 数组字面量
   var b [3]int = [3]int{1, 2, 3}
   var c = [3]int{1, 2} // 第三个是0
   d := [...]int{1, 2, 3} // 长度由真实数据长度决定
   ```
   - 如果数组中的元素是可以比较的，则数组可以直接比较，如果数组中的长度和其中各个位置的数据全部相等，则两个数组相等
2. slice：拥有相同类型元素的可变长度的序列
   - slice的基本概念
     - 底层数组：slice是上层的一种“视图结构”，真正存储数据的是底层数组
     - 指针：指向**底层数组**中第一个可以从slice中访问的元素
     - 长度：slice的长度，用`len`获取
     - 容量：slice从指针到底层数组的最后一个元素的长度，用`cap`获取
   - slice与数组如何区分？简单来说，没有确定长度的，一律都是slice，就看方括号里面有没有数字
     - `var arr1 []int`：无长度定义，是slice
     - `arr2 := make([]int, 5)`：make定义的一定是slice
     - `arr3 := []int{}`：无长度定义，是slice
     - `arr4 := []int{1, 2, 3}`：无长度定义，是slice
     - `arr5 := [...]int{1, 2, 3}`：不定长度，但有定义定义，是数组
     - `var arr6 [5]int`：有长度定义，则是数组
     - <font color="yellow">如果在中括号中没有任何定义，是slice，哪怕后面的数量是确定的</font>
       - ```go
         func main() {
             // 数组
             a := [...]int{1, 2, 3}
             // slice
             b := []int{1, 2, 3}
             fmt.Printf("Type of a: %T\n", a)
             fmt.Printf("Type of b: %T\n", b)
		 }
         // Type of a: [3]int
         // Type of b: []int
         ```
   - 方法名上声明了`[]int`，只有slice才可以，数组不可以







参考文档
1. 数组与slice如何区分：https://www.cnblogs.com/sinclairni/p/14106519.html
2. 值类型、基本类型、引用类型、派生数据类型：https://blog.csdn.net/weixin_44211968/article/details/121221309
3. 











