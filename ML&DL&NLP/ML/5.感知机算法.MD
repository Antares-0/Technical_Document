# 感知机算法

## 一、感知机算法简介
1. 是二分类模型，接收多个信号，输出一个信号。感知机的信号只有0、1两种取值；它模拟的是人类的神经网络模型
2. `x1`和`x2`是输入信号，`y`是输出信号，`w1`和`w2`是权重，当计算的值送盒超过阈值的时候，神经元被激活
   $$
   y=
   \begin{cases}
   0 & (w_1 x_1 + w_2 x_2 \leq \theta) \\
   1 & (w_1 x_1 + w_2 x_2 > \theta)
   \end{cases}
   $$
3. 感知机的多个输入信号都有各自的权重，这些权重发挥着控制各个信号的重要性的作用，权重越大，对应信号的重要性越高
4. 感知机是神经网络的基础
5. 感知机可以用于实现与门、与非门、或门电路，只要选择的$(w1, w2, \theta)$合适，就可以实现

## <font color='yellow'>**二、关键点**</font>
1. 感知机的局限性——感知机没有办法直接表示异或逻辑
   - 感知机的局限性就在于它只能表示由一条直线划分的空间
   - 异或逻辑是(0,1)和(1,0)一类，(0,0)和(1,1)一类
   - 由曲线划分的空间称为非线性空间，由直线划分的空间称为线性空间
2. 多层感知机——使用多层感知机器，可以实现更复杂的功能
   - 第0层的两个神经元接收输入信号，并将信号发送给第1层的神经元；第1层的神经元将信号发送给第2层的神经元；第2层的神经元输出结果
   - 通过叠加层，感知机能进行更加灵活的表示逻辑


## 三、实战（没有什么意义）
1. 实现逻辑门电路
   ```python
   def AND(x1, x2):
       x = np.array([x1, x2])
       w = np.array([0.5, 0.5])
       b = -0.7
       # 直接用矩阵运算的形式计算结果
       res = w @ x + b
       if res <= 0:
           return 0
       else:
           return 1

   # 与非门
   def NAND(x1, x2):
       x = np.array([x1, x2])
       w = np.array([-0.5, -0.5])
       b = 0.7
       # 直接用矩阵运算的形式计算结果
       res = w @ x + b
       if res <= 0:
           return 0
       else:
           return 1
   
   # 或门
   def OR(x1, x2):
       x = np.array([x1, x2])
       w = np.array([0.5, 0.5])
       b = -0.2
       # 直接用矩阵运算的形式计算结果
       res = w @ x + b
       if res <= 0:
           return 0
       else:
           return 1
   
   # 测试
   print( AND(0, 0) )
   print( AND(0, 1) )
   print( AND(1, 0) )
   print( AND(1, 1) )
   
   print( NAND(0, 0) )
   print( NAND(0, 1) )
   print( NAND(1, 0) )
   print( NAND(1, 1) )
   
   print( OR(0, 0) )
   print( OR(0, 1) )
   print( OR(1, 0) )
   print( OR(1, 1) )
   ```
2. 多层感知机实现异或门
   ```python
   # 异或门
   def XOR(x1, x2):
       s1 = NAND(x1, x2)
       s2 = OR(x1, x2)
       y = AND(s1, s2)
       return y
   
   print( XOR(0, 0) )
   print( XOR(0, 1) )
   print( XOR(1, 0) )
   print( XOR(1, 1) )
   ```

参考资料：
1. 尚硅谷机器学习视频：https://www.bilibili.com/video/BV1BYe4z5E9z